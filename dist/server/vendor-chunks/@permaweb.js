"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@permaweb";
exports.ids = ["vendor-chunks/@permaweb"];
exports.modules = {

/***/ "(ssr)/./node_modules/@permaweb/aoconnect/dist/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@permaweb/aoconnect/dist/browser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   createDataItemSigner: () => (/* binding */ createDataItemSigner2),\n/* harmony export */   dryrun: () => (/* binding */ dryrun),\n/* harmony export */   message: () => (/* binding */ message),\n/* harmony export */   monitor: () => (/* binding */ monitor),\n/* harmony export */   result: () => (/* binding */ result),\n/* harmony export */   results: () => (/* binding */ results),\n/* harmony export */   serializeCron: () => (/* binding */ serializeCron),\n/* harmony export */   spawn: () => (/* binding */ spawn),\n/* harmony export */   unmonitor: () => (/* binding */ unmonitor)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/obliterator/iterator.js\nvar require_iterator = __commonJS({\n  \"node_modules/obliterator/iterator.js\"(exports, module) {\n    function Iterator(next) {\n      if (typeof next !== \"function\")\n        throw new Error(\"obliterator/iterator: expecting a function!\");\n      this.next = next;\n    }\n    if (typeof Symbol !== \"undefined\")\n      Iterator.prototype[Symbol.iterator] = function() {\n        return this;\n      };\n    Iterator.of = function() {\n      var args = arguments, l = args.length, i = 0;\n      return new Iterator(function() {\n        if (i >= l) return { done: true };\n        return { done: false, value: args[i++] };\n      });\n    };\n    Iterator.empty = function() {\n      var iterator = new Iterator(function() {\n        return { done: true };\n      });\n      return iterator;\n    };\n    Iterator.fromSequence = function(sequence) {\n      var i = 0, l = sequence.length;\n      return new Iterator(function() {\n        if (i >= l) return { done: true };\n        return { done: false, value: sequence[i++] };\n      });\n    };\n    Iterator.is = function(value) {\n      if (value instanceof Iterator) return true;\n      return typeof value === \"object\" && value !== null && typeof value.next === \"function\";\n    };\n    module.exports = Iterator;\n  }\n});\n\n// node_modules/obliterator/support.js\nvar require_support = __commonJS({\n  \"node_modules/obliterator/support.js\"(exports) {\n    exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== \"undefined\";\n    exports.SYMBOL_SUPPORT = typeof Symbol !== \"undefined\";\n  }\n});\n\n// node_modules/obliterator/foreach.js\nvar require_foreach = __commonJS({\n  \"node_modules/obliterator/foreach.js\"(exports, module) {\n    var support = require_support();\n    var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\n    var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n    module.exports = function forEach(iterable, callback) {\n      var iterator, k2, i, l, s;\n      if (!iterable) throw new Error(\"obliterator/forEach: invalid iterable.\");\n      if (typeof callback !== \"function\")\n        throw new Error(\"obliterator/forEach: expecting a callback.\");\n      if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === \"string\" || iterable.toString() === \"[object Arguments]\") {\n        for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);\n        return;\n      }\n      if (typeof iterable.forEach === \"function\") {\n        iterable.forEach(callback);\n        return;\n      }\n      if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== \"function\") {\n        iterable = iterable[Symbol.iterator]();\n      }\n      if (typeof iterable.next === \"function\") {\n        iterator = iterable;\n        i = 0;\n        while (s = iterator.next(), s.done !== true) {\n          callback(s.value, i);\n          i++;\n        }\n        return;\n      }\n      for (k2 in iterable) {\n        if (iterable.hasOwnProperty(k2)) {\n          callback(iterable[k2], k2);\n        }\n      }\n      return;\n    };\n  }\n});\n\n// node_modules/mnemonist/utils/typed-arrays.js\nvar require_typed_arrays = __commonJS({\n  \"node_modules/mnemonist/utils/typed-arrays.js\"(exports) {\n    var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;\n    var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;\n    var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n    var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;\n    var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;\n    var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n    exports.getPointerArray = function(size) {\n      var maxIndex = size - 1;\n      if (maxIndex <= MAX_8BIT_INTEGER)\n        return Uint8Array;\n      if (maxIndex <= MAX_16BIT_INTEGER)\n        return Uint16Array;\n      if (maxIndex <= MAX_32BIT_INTEGER)\n        return Uint32Array;\n      throw new Error(\"mnemonist: Pointer Array of size > 4294967295 is not supported.\");\n    };\n    exports.getSignedPointerArray = function(size) {\n      var maxIndex = size - 1;\n      if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n        return Int8Array;\n      if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n        return Int16Array;\n      if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n        return Int32Array;\n      return Float64Array;\n    };\n    exports.getNumberType = function(value) {\n      if (value === (value | 0)) {\n        if (Math.sign(value) === -1) {\n          if (value <= 127 && value >= -128)\n            return Int8Array;\n          if (value <= 32767 && value >= -32768)\n            return Int16Array;\n          return Int32Array;\n        } else {\n          if (value <= 255)\n            return Uint8Array;\n          if (value <= 65535)\n            return Uint16Array;\n          return Uint32Array;\n        }\n      }\n      return Float64Array;\n    };\n    var TYPE_PRIORITY = {\n      Uint8Array: 1,\n      Int8Array: 2,\n      Uint16Array: 3,\n      Int16Array: 4,\n      Uint32Array: 5,\n      Int32Array: 6,\n      Float32Array: 7,\n      Float64Array: 8\n    };\n    exports.getMinimalRepresentation = function(array, getter) {\n      var maxType = null, maxPriority = 0, p2, t, v2, i, l;\n      for (i = 0, l = array.length; i < l; i++) {\n        v2 = getter ? getter(array[i]) : array[i];\n        t = exports.getNumberType(v2);\n        p2 = TYPE_PRIORITY[t.name];\n        if (p2 > maxPriority) {\n          maxPriority = p2;\n          maxType = t;\n        }\n      }\n      return maxType;\n    };\n    exports.isTypedArray = function(value) {\n      return typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(value);\n    };\n    exports.concat = function() {\n      var length = 0, i, o, l;\n      for (i = 0, l = arguments.length; i < l; i++)\n        length += arguments[i].length;\n      var array = new arguments[0].constructor(length);\n      for (i = 0, o = 0; i < l; i++) {\n        array.set(arguments[i], o);\n        o += arguments[i].length;\n      }\n      return array;\n    };\n    exports.indices = function(length) {\n      var PointerArray = exports.getPointerArray(length);\n      var array = new PointerArray(length);\n      for (var i = 0; i < length; i++)\n        array[i] = i;\n      return array;\n    };\n  }\n});\n\n// node_modules/mnemonist/utils/iterables.js\nvar require_iterables = __commonJS({\n  \"node_modules/mnemonist/utils/iterables.js\"(exports) {\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    function isArrayLike2(target) {\n      return Array.isArray(target) || typed.isTypedArray(target);\n    }\n    function guessLength(target) {\n      if (typeof target.length === \"number\")\n        return target.length;\n      if (typeof target.size === \"number\")\n        return target.size;\n      return;\n    }\n    function toArray(target) {\n      var l = guessLength(target);\n      var array = typeof l === \"number\" ? new Array(l) : [];\n      var i = 0;\n      forEach(target, function(value) {\n        array[i++] = value;\n      });\n      return array;\n    }\n    function toArrayWithIndices(target) {\n      var l = guessLength(target);\n      var IndexArray = typeof l === \"number\" ? typed.getPointerArray(l) : Array;\n      var array = typeof l === \"number\" ? new Array(l) : [];\n      var indices = typeof l === \"number\" ? new IndexArray(l) : [];\n      var i = 0;\n      forEach(target, function(value) {\n        array[i] = value;\n        indices[i] = i++;\n      });\n      return [array, indices];\n    }\n    exports.isArrayLike = isArrayLike2;\n    exports.guessLength = guessLength;\n    exports.toArray = toArray;\n    exports.toArrayWithIndices = toArrayWithIndices;\n  }\n});\n\n// node_modules/mnemonist/lru-cache.js\nvar require_lru_cache = __commonJS({\n  \"node_modules/mnemonist/lru-cache.js\"(exports, module) {\n    var Iterator = require_iterator();\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    var iterables = require_iterables();\n    function LRUCache(Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      this.capacity = capacity;\n      if (typeof this.capacity !== \"number\" || this.capacity <= 0)\n        throw new Error(\"mnemonist/lru-cache: capacity should be positive number.\");\n      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n        throw new Error(\"mnemonist/lru-cache: capacity should be a finite positive integer.\");\n      var PointerArray = typed.getPointerArray(capacity);\n      this.forward = new PointerArray(capacity);\n      this.backward = new PointerArray(capacity);\n      this.K = typeof Keys === \"function\" ? new Keys(capacity) : new Array(capacity);\n      this.V = typeof Values === \"function\" ? new Values(capacity) : new Array(capacity);\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = {};\n    }\n    LRUCache.prototype.clear = function() {\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = {};\n    };\n    LRUCache.prototype.splayOnTop = function(pointer) {\n      var oldHead = this.head;\n      if (this.head === pointer)\n        return this;\n      var previous = this.backward[pointer], next = this.forward[pointer];\n      if (this.tail === pointer) {\n        this.tail = previous;\n      } else {\n        this.backward[next] = previous;\n      }\n      this.forward[previous] = next;\n      this.backward[oldHead] = pointer;\n      this.head = pointer;\n      this.forward[pointer] = oldHead;\n      return this;\n    };\n    LRUCache.prototype.set = function(key, value) {\n      var pointer = this.items[key];\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        this.V[pointer] = value;\n        return;\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        delete this.items[this.K[pointer]];\n      }\n      this.items[key] = pointer;\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n    };\n    LRUCache.prototype.setpop = function(key, value) {\n      var oldValue = null;\n      var oldKey = null;\n      var pointer = this.items[key];\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        oldValue = this.V[pointer];\n        this.V[pointer] = value;\n        return { evicted: false, key, value: oldValue };\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        oldValue = this.V[pointer];\n        oldKey = this.K[pointer];\n        delete this.items[oldKey];\n      }\n      this.items[key] = pointer;\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n      if (oldKey) {\n        return { evicted: true, key: oldKey, value: oldValue };\n      } else {\n        return null;\n      }\n    };\n    LRUCache.prototype.has = function(key) {\n      return key in this.items;\n    };\n    LRUCache.prototype.get = function(key) {\n      var pointer = this.items[key];\n      if (typeof pointer === \"undefined\")\n        return;\n      this.splayOnTop(pointer);\n      return this.V[pointer];\n    };\n    LRUCache.prototype.peek = function(key) {\n      var pointer = this.items[key];\n      if (typeof pointer === \"undefined\")\n        return;\n      return this.V[pointer];\n    };\n    LRUCache.prototype.forEach = function(callback, scope) {\n      scope = arguments.length > 1 ? scope : this;\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, values = this.V, forward = this.forward;\n      while (i < l) {\n        callback.call(scope, values[pointer], keys4[pointer], this);\n        pointer = forward[pointer];\n        i++;\n      }\n    };\n    LRUCache.prototype.keys = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var key = keys4[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value: key\n        };\n      });\n    };\n    LRUCache.prototype.values = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, values = this.V, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var value = values[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value\n        };\n      });\n    };\n    LRUCache.prototype.entries = function() {\n      var i = 0, l = this.size;\n      var pointer = this.head, keys4 = this.K, values = this.V, forward = this.forward;\n      return new Iterator(function() {\n        if (i >= l)\n          return { done: true };\n        var key = keys4[pointer], value = values[pointer];\n        i++;\n        if (i < l)\n          pointer = forward[pointer];\n        return {\n          done: false,\n          value: [key, value]\n        };\n      });\n    };\n    if (typeof Symbol !== \"undefined\")\n      LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n    LRUCache.prototype.inspect = function() {\n      var proxy = /* @__PURE__ */ new Map();\n      var iterator = this.entries(), step;\n      while (step = iterator.next(), !step.done)\n        proxy.set(step.value[0], step.value[1]);\n      Object.defineProperty(proxy, \"constructor\", {\n        value: LRUCache,\n        enumerable: false\n      });\n      return proxy;\n    };\n    if (typeof Symbol !== \"undefined\")\n      LRUCache.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = LRUCache.prototype.inspect;\n    LRUCache.from = function(iterable, Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = iterables.guessLength(iterable);\n        if (typeof capacity !== \"number\")\n          throw new Error(\"mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.\");\n      } else if (arguments.length === 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      var cache = new LRUCache(Keys, Values, capacity);\n      forEach(iterable, function(value, key) {\n        cache.set(key, value);\n      });\n      return cache;\n    };\n    module.exports = LRUCache;\n  }\n});\n\n// node_modules/mnemonist/lru-map.js\nvar require_lru_map = __commonJS({\n  \"node_modules/mnemonist/lru-map.js\"(exports, module) {\n    var LRUCache = require_lru_cache();\n    var forEach = require_foreach();\n    var typed = require_typed_arrays();\n    var iterables = require_iterables();\n    function LRUMap(Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      this.capacity = capacity;\n      if (typeof this.capacity !== \"number\" || this.capacity <= 0)\n        throw new Error(\"mnemonist/lru-map: capacity should be positive number.\");\n      else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n        throw new Error(\"mnemonist/lru-map: capacity should be a finite positive integer.\");\n      var PointerArray = typed.getPointerArray(capacity);\n      this.forward = new PointerArray(capacity);\n      this.backward = new PointerArray(capacity);\n      this.K = typeof Keys === \"function\" ? new Keys(capacity) : new Array(capacity);\n      this.V = typeof Values === \"function\" ? new Values(capacity) : new Array(capacity);\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items = /* @__PURE__ */ new Map();\n    }\n    LRUMap.prototype.clear = function() {\n      this.size = 0;\n      this.head = 0;\n      this.tail = 0;\n      this.items.clear();\n    };\n    LRUMap.prototype.set = function(key, value) {\n      var pointer = this.items.get(key);\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        this.V[pointer] = value;\n        return;\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        this.items.delete(this.K[pointer]);\n      }\n      this.items.set(key, pointer);\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n    };\n    LRUMap.prototype.setpop = function(key, value) {\n      var oldValue = null;\n      var oldKey = null;\n      var pointer = this.items.get(key);\n      if (typeof pointer !== \"undefined\") {\n        this.splayOnTop(pointer);\n        oldValue = this.V[pointer];\n        this.V[pointer] = value;\n        return { evicted: false, key, value: oldValue };\n      }\n      if (this.size < this.capacity) {\n        pointer = this.size++;\n      } else {\n        pointer = this.tail;\n        this.tail = this.backward[pointer];\n        oldValue = this.V[pointer];\n        oldKey = this.K[pointer];\n        this.items.delete(oldKey);\n      }\n      this.items.set(key, pointer);\n      this.K[pointer] = key;\n      this.V[pointer] = value;\n      this.forward[pointer] = this.head;\n      this.backward[this.head] = pointer;\n      this.head = pointer;\n      if (oldKey) {\n        return { evicted: true, key: oldKey, value: oldValue };\n      } else {\n        return null;\n      }\n    };\n    LRUMap.prototype.has = function(key) {\n      return this.items.has(key);\n    };\n    LRUMap.prototype.get = function(key) {\n      var pointer = this.items.get(key);\n      if (typeof pointer === \"undefined\")\n        return;\n      this.splayOnTop(pointer);\n      return this.V[pointer];\n    };\n    LRUMap.prototype.peek = function(key) {\n      var pointer = this.items.get(key);\n      if (typeof pointer === \"undefined\")\n        return;\n      return this.V[pointer];\n    };\n    LRUMap.prototype.splayOnTop = LRUCache.prototype.splayOnTop;\n    LRUMap.prototype.forEach = LRUCache.prototype.forEach;\n    LRUMap.prototype.keys = LRUCache.prototype.keys;\n    LRUMap.prototype.values = LRUCache.prototype.values;\n    LRUMap.prototype.entries = LRUCache.prototype.entries;\n    if (typeof Symbol !== \"undefined\")\n      LRUMap.prototype[Symbol.iterator] = LRUMap.prototype.entries;\n    LRUMap.prototype.inspect = LRUCache.prototype.inspect;\n    LRUMap.from = function(iterable, Keys, Values, capacity) {\n      if (arguments.length < 2) {\n        capacity = iterables.guessLength(iterable);\n        if (typeof capacity !== \"number\")\n          throw new Error(\"mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.\");\n      } else if (arguments.length === 2) {\n        capacity = Keys;\n        Keys = null;\n        Values = null;\n      }\n      var cache = new LRUMap(Keys, Values, capacity);\n      forEach(iterable, function(value, key) {\n        cache.set(key, value);\n      });\n      return cache;\n    };\n    module.exports = LRUMap;\n  }\n});\n\n// node_modules/ms/index.js\nvar require_ms = __commonJS({\n  \"node_modules/ms/index.js\"(exports, module) {\n    var s = 1e3;\n    var m2 = s * 60;\n    var h = m2 * 60;\n    var d2 = h * 24;\n    var w3 = d2 * 7;\n    var y2 = d2 * 365.25;\n    module.exports = function(val, options) {\n      options = options || {};\n      var type3 = typeof val;\n      if (type3 === \"string\" && val.length > 0) {\n        return parse2(val);\n      } else if (type3 === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n      }\n      throw new Error(\n        \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n      );\n    };\n    function parse2(str) {\n      str = String(str);\n      if (str.length > 100) {\n        return;\n      }\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (!match) {\n        return;\n      }\n      var n = parseFloat(match[1]);\n      var type3 = (match[2] || \"ms\").toLowerCase();\n      switch (type3) {\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n          return n * y2;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n          return n * w3;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n          return n * d2;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n          return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n          return n * m2;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n          return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n          return n;\n        default:\n          return void 0;\n      }\n    }\n    function fmtShort(ms2) {\n      var msAbs = Math.abs(ms2);\n      if (msAbs >= d2) {\n        return Math.round(ms2 / d2) + \"d\";\n      }\n      if (msAbs >= h) {\n        return Math.round(ms2 / h) + \"h\";\n      }\n      if (msAbs >= m2) {\n        return Math.round(ms2 / m2) + \"m\";\n      }\n      if (msAbs >= s) {\n        return Math.round(ms2 / s) + \"s\";\n      }\n      return ms2 + \"ms\";\n    }\n    function fmtLong(ms2) {\n      var msAbs = Math.abs(ms2);\n      if (msAbs >= d2) {\n        return plural(ms2, msAbs, d2, \"day\");\n      }\n      if (msAbs >= h) {\n        return plural(ms2, msAbs, h, \"hour\");\n      }\n      if (msAbs >= m2) {\n        return plural(ms2, msAbs, m2, \"minute\");\n      }\n      if (msAbs >= s) {\n        return plural(ms2, msAbs, s, \"second\");\n      }\n      return ms2 + \" ms\";\n    }\n    function plural(ms2, msAbs, n, name) {\n      var isPlural = msAbs >= n * 1.5;\n      return Math.round(ms2 / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n  }\n});\n\n// node_modules/debug/src/common.js\nvar require_common = __commonJS({\n  \"node_modules/debug/src/common.js\"(exports, module) {\n    function setup(env) {\n      createDebug.debug = createDebug;\n      createDebug.default = createDebug;\n      createDebug.coerce = coerce2;\n      createDebug.disable = disable;\n      createDebug.enable = enable;\n      createDebug.enabled = enabled;\n      createDebug.humanize = require_ms();\n      createDebug.destroy = destroy;\n      Object.keys(env).forEach((key) => {\n        createDebug[key] = env[key];\n      });\n      createDebug.names = [];\n      createDebug.skips = [];\n      createDebug.formatters = {};\n      function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\n          hash |= 0;\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n      }\n      createDebug.selectColor = selectColor;\n      function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug2(...args) {\n          if (!debug2.enabled) {\n            return;\n          }\n          const self = debug2;\n          const curr = Number(/* @__PURE__ */ new Date());\n          const ms2 = curr - (prevTime || curr);\n          self.diff = ms2;\n          self.prev = prevTime;\n          self.curr = curr;\n          prevTime = curr;\n          args[0] = createDebug.coerce(args[0]);\n          if (typeof args[0] !== \"string\") {\n            args.unshift(\"%O\");\n          }\n          let index = 0;\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n            if (match === \"%%\") {\n              return \"%\";\n            }\n            index++;\n            const formatter = createDebug.formatters[format];\n            if (typeof formatter === \"function\") {\n              const val = args[index];\n              match = formatter.call(self, val);\n              args.splice(index, 1);\n              index--;\n            }\n            return match;\n          });\n          createDebug.formatArgs.call(self, args);\n          const logFn = self.log || createDebug.log;\n          logFn.apply(self, args);\n        }\n        debug2.namespace = namespace;\n        debug2.useColors = createDebug.useColors();\n        debug2.color = createDebug.selectColor(namespace);\n        debug2.extend = extend;\n        debug2.destroy = createDebug.destroy;\n        Object.defineProperty(debug2, \"enabled\", {\n          enumerable: true,\n          configurable: false,\n          get: () => {\n            if (enableOverride !== null) {\n              return enableOverride;\n            }\n            if (namespacesCache !== createDebug.namespaces) {\n              namespacesCache = createDebug.namespaces;\n              enabledCache = createDebug.enabled(namespace);\n            }\n            return enabledCache;\n          },\n          set: (v2) => {\n            enableOverride = v2;\n          }\n        });\n        if (typeof createDebug.init === \"function\") {\n          createDebug.init(debug2);\n        }\n        return debug2;\n      }\n      function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n      }\n      function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for (i = 0; i < len; i++) {\n          if (!split[i]) {\n            continue;\n          }\n          namespaces = split[i].replace(/\\*/g, \".*?\");\n          if (namespaces[0] === \"-\") {\n            createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n          } else {\n            createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n          }\n        }\n      }\n      function disable() {\n        const namespaces = [\n          ...createDebug.names.map(toNamespace),\n          ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n      }\n      function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n          return true;\n        }\n        let i;\n        let len;\n        for (i = 0, len = createDebug.skips.length; i < len; i++) {\n          if (createDebug.skips[i].test(name)) {\n            return false;\n          }\n        }\n        for (i = 0, len = createDebug.names.length; i < len; i++) {\n          if (createDebug.names[i].test(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n      }\n      function coerce2(val) {\n        if (val instanceof Error) {\n          return val.stack || val.message;\n        }\n        return val;\n      }\n      function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n      }\n      createDebug.enable(createDebug.load());\n      return createDebug;\n    }\n    module.exports = setup;\n  }\n});\n\n// node_modules/debug/src/browser.js\nvar require_browser = __commonJS({\n  \"node_modules/debug/src/browser.js\"(exports, module) {\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = localstorage();\n    exports.destroy = /* @__PURE__ */ (() => {\n      let warned = false;\n      return () => {\n        if (!warned) {\n          warned = true;\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n      };\n    })();\n    exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      if (typeof window !== \"undefined\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs)) {\n        return true;\n      }\n      if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n      }\n      let m2;\n      return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window !== \"undefined\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator !== \"undefined\" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n      if (!this.useColors) {\n        return;\n      }\n      const c2 = \"color: \" + this.color;\n      args.splice(1, 0, c2, \"color: inherit\");\n      let index = 0;\n      let lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        if (match === \"%%\") {\n          return;\n        }\n        index++;\n        if (match === \"%c\") {\n          lastC = index;\n        }\n      });\n      args.splice(lastC, 0, c2);\n    }\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        if (namespaces) {\n          exports.storage.setItem(\"debug\", namespaces);\n        } else {\n          exports.storage.removeItem(\"debug\");\n        }\n      } catch (error) {\n      }\n    }\n    function load() {\n      let r18;\n      try {\n        r18 = exports.storage.getItem(\"debug\");\n      } catch (error) {\n      }\n      if (!r18 && typeof process !== \"undefined\" && \"env\" in process) {\n        r18 = process.env.DEBUG;\n      }\n      return r18;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch (error) {\n      }\n    }\n    module.exports = require_common()(exports);\n    var { formatters } = module.exports;\n    formatters.j = function(v2) {\n      try {\n        return JSON.stringify(v2);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }\n});\n\n// node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1) validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"node_modules/ieee754/index.js\"(exports) {\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m2;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d2 = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d2;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d2, nBits -= 8) {\n      }\n      m2 = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m2 ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m2 = m2 + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m2, c2;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d2 = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m2 = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c2 = Math.pow(2, -e)) < 1) {\n          e--;\n          c2 *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt2 / c2;\n        } else {\n          value += rt2 * Math.pow(2, 1 - eBias);\n        }\n        if (value * c2 >= 2) {\n          e++;\n          c2 /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m2 = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m2 = (value * c2 - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m2;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d2] |= s * 128;\n    };\n  }\n});\n\n// node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer3;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto2 = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto2, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto2);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer3.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this)) return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer3.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this)) return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function Buffer3(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer3.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer3.from(valueOf, encodingOrOffset, length);\n      }\n      const b2 = fromObject(value);\n      if (b2) return b2;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer3.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer3.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer3, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer3.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer3.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer3.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer3.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer3.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer3.alloc(+length);\n    }\n    Buffer3.isBuffer = function isBuffer(b2) {\n      return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;\n    };\n    Buffer3.compare = function compare(a, b2) {\n      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);\n      if (isInstance(b2, Uint8Array)) b2 = Buffer3.from(b2, b2.offset, b2.byteLength);\n      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b2) return 0;\n      let x3 = a.length;\n      let y2 = b2.length;\n      for (let i = 0, len = Math.min(x3, y2); i < len; ++i) {\n        if (a[i] !== b2[i]) {\n          x3 = a[i];\n          y2 = b2[i];\n          break;\n        }\n      }\n      if (x3 < y2) return -1;\n      if (y2 < x3) return 1;\n      return 0;\n    };\n    Buffer3.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer3.concat = function concat4(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer3.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer3.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer3.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer3.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0) return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding) encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.prototype._isBuffer = true;\n    function swap(b2, n, m2) {\n      const i = b2[n];\n      b2[n] = b2[m2];\n      b2[m2] = i;\n    }\n    Buffer3.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer3.prototype.toString = function toString4() {\n      const length = this.length;\n      if (length === 0) return \"\";\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;\n    Buffer3.prototype.equals = function equals3(b2) {\n      if (!Buffer3.isBuffer(b2)) throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b2) return true;\n      return Buffer3.compare(this, b2) === 0;\n    };\n    Buffer3.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max3 = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max3).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max3) str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;\n    }\n    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer3.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer3.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      let x3 = thisEnd - thisStart;\n      let y2 = end - start;\n      const len = Math.min(x3, y2);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x3 = thisCopy[i];\n          y2 = targetCopy[i];\n          break;\n        }\n      }\n      if (x3 < y2) return -1;\n      if (y2 < x3) return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0) return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer3.from(val, encoding);\n      }\n      if (Buffer3.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j2 = 0; j2 < valLength; j2++) {\n            if (read(arr, i + j2) !== read(val, j2)) {\n              found = false;\n              break;\n            }\n          }\n          if (found) return i;\n        }\n      }\n      return -1;\n    }\n    Buffer3.prototype.includes = function includes2(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer3.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0) encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining) length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding) encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer3.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer3.prototype.slice = function slice3(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start) end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer3.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128)) return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max3, min) {\n      if (!Buffer3.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max3 || value < min) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    }\n    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max3) {\n      checkIntBI(value, min, max3, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max3) {\n      checkIntBI(value, min, max3, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0) value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0) value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max3, min) {\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n      if (offset < 0) throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer3.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start;\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n      if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length) end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer3.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer3.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val) val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E3(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E3(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E3(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E3(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max3, buf, offset, byteLength2) {\n      if (value > max3 || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max3}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type3) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type3);\n        throw new errors.ERR_OUT_OF_RANGE(type3 || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type3 || \"offset\",\n        `>= ${type3 ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2) return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0) break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0) break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0) break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c2, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c2 = str.charCodeAt(i);\n        hi = c2 >> 8;\n        lo = c2 % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type3) {\n      return obj instanceof type3 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type3.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j2 = 0; j2 < 16; ++j2) {\n          table[i16 + j2] = alphabet[i] + alphabet[j2];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn2) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn2;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\n// node_modules/@permaweb/ao-scheduler-utils/dist/browser.js\nvar Qt = { \"@@functional/placeholder\": true };\nfunction k(r18) {\n  return r18 === Qt;\n}\nfunction E(r18) {\n  return function e(t) {\n    return arguments.length === 0 || k(t) ? e : r18.apply(this, arguments);\n  };\n}\nfunction x(r18) {\n  return function e(t, n) {\n    switch (arguments.length) {\n      case 0:\n        return e;\n      case 1:\n        return k(t) ? e : E(function(s) {\n          return r18(t, s);\n        });\n      default:\n        return k(t) && k(n) ? e : k(t) ? E(function(s) {\n          return r18(s, n);\n        }) : k(n) ? E(function(s) {\n          return r18(t, s);\n        }) : r18(t, n);\n    }\n  };\n}\nfunction q(r18, e) {\n  switch (r18) {\n    case 0:\n      return function() {\n        return e.apply(this, arguments);\n      };\n    case 1:\n      return function(t) {\n        return e.apply(this, arguments);\n      };\n    case 2:\n      return function(t, n) {\n        return e.apply(this, arguments);\n      };\n    case 3:\n      return function(t, n, s) {\n        return e.apply(this, arguments);\n      };\n    case 4:\n      return function(t, n, s, a) {\n        return e.apply(this, arguments);\n      };\n    case 5:\n      return function(t, n, s, a, i) {\n        return e.apply(this, arguments);\n      };\n    case 6:\n      return function(t, n, s, a, i, o) {\n        return e.apply(this, arguments);\n      };\n    case 7:\n      return function(t, n, s, a, i, o, u) {\n        return e.apply(this, arguments);\n      };\n    case 8:\n      return function(t, n, s, a, i, o, u, l) {\n        return e.apply(this, arguments);\n      };\n    case 9:\n      return function(t, n, s, a, i, o, u, l, h) {\n        return e.apply(this, arguments);\n      };\n    case 10:\n      return function(t, n, s, a, i, o, u, l, h, v2) {\n        return e.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\nfunction et(r18, e, t) {\n  return function() {\n    for (var n = [], s = 0, a = r18, i = 0, o = false; i < e.length || s < arguments.length; ) {\n      var u;\n      i < e.length && (!k(e[i]) || s >= arguments.length) ? u = e[i] : (u = arguments[s], s += 1), n[i] = u, k(u) ? o = true : a -= 1, i += 1;\n    }\n    return !o && a <= 0 ? t.apply(this, n) : q(Math.max(0, a), et(r18, n, t));\n  };\n}\nvar rn = x(function(e, t) {\n  return e === 1 ? E(t) : q(e, et(e, [], t));\n});\nvar tt = rn;\nfunction ue(r18) {\n  return function e(t, n, s) {\n    switch (arguments.length) {\n      case 0:\n        return e;\n      case 1:\n        return k(t) ? e : x(function(a, i) {\n          return r18(t, a, i);\n        });\n      case 2:\n        return k(t) && k(n) ? e : k(t) ? x(function(a, i) {\n          return r18(a, n, i);\n        }) : k(n) ? x(function(a, i) {\n          return r18(t, a, i);\n        }) : E(function(a) {\n          return r18(t, n, a);\n        });\n      default:\n        return k(t) && k(n) && k(s) ? e : k(t) && k(n) ? x(function(a, i) {\n          return r18(a, i, s);\n        }) : k(t) && k(s) ? x(function(a, i) {\n          return r18(a, n, i);\n        }) : k(n) && k(s) ? x(function(a, i) {\n          return r18(t, a, i);\n        }) : k(t) ? E(function(a) {\n          return r18(a, n, s);\n        }) : k(n) ? E(function(a) {\n          return r18(t, a, s);\n        }) : k(s) ? E(function(a) {\n          return r18(t, n, a);\n        }) : r18(t, n, s);\n    }\n  };\n}\nvar Oe = Array.isArray || function(e) {\n  return e != null && e.length >= 0 && Object.prototype.toString.call(e) === \"[object Array]\";\n};\nfunction wt(r18) {\n  return r18 != null && typeof r18[\"@@transducer/step\"] == \"function\";\n}\nfunction le(r18, e, t) {\n  return function() {\n    if (arguments.length === 0) return t();\n    var n = arguments[arguments.length - 1];\n    if (!Oe(n)) {\n      for (var s = 0; s < r18.length; ) {\n        if (typeof n[r18[s]] == \"function\") return n[r18[s]].apply(n, Array.prototype.slice.call(arguments, 0, -1));\n        s += 1;\n      }\n      if (wt(n)) {\n        var a = e.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return a(n);\n      }\n    }\n    return t.apply(this, arguments);\n  };\n}\nfunction bt(r18) {\n  return r18 && r18[\"@@transducer/reduced\"] ? r18 : { \"@@transducer/value\": r18, \"@@transducer/reduced\": true };\n}\nvar K = { init: function() {\n  return this.xf[\"@@transducer/init\"]();\n}, result: function(r18) {\n  return this.xf[\"@@transducer/result\"](r18);\n} };\nfunction rt(r18) {\n  for (var e = [], t; !(t = r18.next()).done; ) e.push(t.value);\n  return e;\n}\nfunction nt(r18, e, t) {\n  for (var n = 0, s = t.length; n < s; ) {\n    if (r18(e, t[n])) return true;\n    n += 1;\n  }\n  return false;\n}\nfunction St(r18) {\n  var e = String(r18).match(/^function (\\w*)/);\n  return e == null ? \"\" : e[1];\n}\nfunction ee(r18, e) {\n  return Object.prototype.hasOwnProperty.call(e, r18);\n}\nfunction nn(r18, e) {\n  return r18 === e ? r18 !== 0 || 1 / r18 === 1 / e : r18 !== r18 && e !== e;\n}\nvar st = typeof Object.is == \"function\" ? Object.is : nn;\nvar Kt = Object.prototype.toString;\nvar sn = function() {\n  return Kt.call(arguments) === \"[object Arguments]\" ? function(e) {\n    return Kt.call(e) === \"[object Arguments]\";\n  } : function(e) {\n    return ee(\"callee\", e);\n  };\n}();\nvar er = sn;\nvar an = !{ toString: null }.propertyIsEnumerable(\"toString\");\nvar tr = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];\nvar rr = function() {\n  \"use strict\";\n  return arguments.propertyIsEnumerable(\"length\");\n}();\nvar on = function(e, t) {\n  for (var n = 0; n < e.length; ) {\n    if (e[n] === t) return true;\n    n += 1;\n  }\n  return false;\n};\nvar un = typeof Object.keys == \"function\" && !rr ? E(function(e) {\n  return Object(e) !== e ? [] : Object.keys(e);\n}) : E(function(e) {\n  if (Object(e) !== e) return [];\n  var t, n, s = [], a = rr && er(e);\n  for (t in e) ee(t, e) && (!a || t !== \"length\") && (s[s.length] = t);\n  if (an) for (n = tr.length - 1; n >= 0; ) t = tr[n], ee(t, e) && !on(s, t) && (s[s.length] = t), n -= 1;\n  return s;\n});\nvar F = un;\nvar ln = E(function(e) {\n  return e === null ? \"Null\" : e === void 0 ? \"Undefined\" : Object.prototype.toString.call(e).slice(8, -1);\n});\nvar kt = ln;\nfunction nr(r18, e, t, n) {\n  var s = rt(r18), a = rt(e);\n  function i(o, u) {\n    return Me(o, u, t.slice(), n.slice());\n  }\n  return !nt(function(o, u) {\n    return !nt(i, u, o);\n  }, a, s);\n}\nfunction Me(r18, e, t, n) {\n  if (st(r18, e)) return true;\n  var s = kt(r18);\n  if (s !== kt(e)) return false;\n  if (typeof r18[\"fantasy-land/equals\"] == \"function\" || typeof e[\"fantasy-land/equals\"] == \"function\") return typeof r18[\"fantasy-land/equals\"] == \"function\" && r18[\"fantasy-land/equals\"](e) && typeof e[\"fantasy-land/equals\"] == \"function\" && e[\"fantasy-land/equals\"](r18);\n  if (typeof r18.equals == \"function\" || typeof e.equals == \"function\") return typeof r18.equals == \"function\" && r18.equals(e) && typeof e.equals == \"function\" && e.equals(r18);\n  switch (s) {\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n      if (typeof r18.constructor == \"function\" && St(r18.constructor) === \"Promise\") return r18 === e;\n      break;\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n      if (!(typeof r18 == typeof e && st(r18.valueOf(), e.valueOf()))) return false;\n      break;\n    case \"Date\":\n      if (!st(r18.valueOf(), e.valueOf())) return false;\n      break;\n    case \"Error\":\n      return r18.name === e.name && r18.message === e.message;\n    case \"RegExp\":\n      if (!(r18.source === e.source && r18.global === e.global && r18.ignoreCase === e.ignoreCase && r18.multiline === e.multiline && r18.sticky === e.sticky && r18.unicode === e.unicode)) return false;\n      break;\n  }\n  for (var a = t.length - 1; a >= 0; ) {\n    if (t[a] === r18) return n[a] === e;\n    a -= 1;\n  }\n  switch (s) {\n    case \"Map\":\n      return r18.size !== e.size ? false : nr(r18.entries(), e.entries(), t.concat([r18]), n.concat([e]));\n    case \"Set\":\n      return r18.size !== e.size ? false : nr(r18.values(), e.values(), t.concat([r18]), n.concat([e]));\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n    case \"Date\":\n    case \"Error\":\n    case \"RegExp\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"ArrayBuffer\":\n      break;\n    default:\n      return false;\n  }\n  var i = F(r18);\n  if (i.length !== F(e).length) return false;\n  var o = t.concat([r18]), u = n.concat([e]);\n  for (a = i.length - 1; a >= 0; ) {\n    var l = i[a];\n    if (!(ee(l, e) && Me(e[l], r18[l], o, u))) return false;\n    a -= 1;\n  }\n  return true;\n}\nvar cn = x(function(e, t) {\n  return Me(e, t, [], []);\n});\nvar at = cn;\nfunction Tt(r18, e, t) {\n  var n, s;\n  if (typeof r18.indexOf == \"function\") switch (typeof e) {\n    case \"number\":\n      if (e === 0) {\n        for (n = 1 / e; t < r18.length; ) {\n          if (s = r18[t], s === 0 && 1 / s === n) return t;\n          t += 1;\n        }\n        return -1;\n      } else if (e !== e) {\n        for (; t < r18.length; ) {\n          if (s = r18[t], typeof s == \"number\" && s !== s) return t;\n          t += 1;\n        }\n        return -1;\n      }\n      return r18.indexOf(e, t);\n    case \"string\":\n    case \"boolean\":\n    case \"function\":\n    case \"undefined\":\n      return r18.indexOf(e, t);\n    case \"object\":\n      if (e === null) return r18.indexOf(e, t);\n  }\n  for (; t < r18.length; ) {\n    if (at(r18[t], e)) return t;\n    t += 1;\n  }\n  return -1;\n}\nfunction Ot(r18, e) {\n  return Tt(e, r18, 0) >= 0;\n}\nfunction G(r18, e) {\n  for (var t = 0, n = e.length, s = Array(n); t < n; ) s[t] = r18(e[t]), t += 1;\n  return s;\n}\nfunction De(r18) {\n  var e = r18.replace(/\\\\/g, \"\\\\\\\\\").replace(/[\\b]/g, \"\\\\b\").replace(/\\f/g, \"\\\\f\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\v/g, \"\\\\v\").replace(/\\0/g, \"\\\\0\");\n  return '\"' + e.replace(/\"/g, '\\\\\"') + '\"';\n}\nvar Be = function(e) {\n  return (e < 10 ? \"0\" : \"\") + e;\n};\nvar fn = typeof Date.prototype.toISOString == \"function\" ? function(e) {\n  return e.toISOString();\n} : function(e) {\n  return e.getUTCFullYear() + \"-\" + Be(e.getUTCMonth() + 1) + \"-\" + Be(e.getUTCDate()) + \"T\" + Be(e.getUTCHours()) + \":\" + Be(e.getUTCMinutes()) + \":\" + Be(e.getUTCSeconds()) + \".\" + (e.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + \"Z\";\n};\nvar sr = fn;\nfunction Et(r18) {\n  return function() {\n    return !r18.apply(this, arguments);\n  };\n}\nfunction Fe(r18, e, t) {\n  for (var n = 0, s = t.length; n < s; ) e = r18(e, t[n]), n += 1;\n  return e;\n}\nfunction At(r18, e) {\n  for (var t = 0, n = e.length, s = []; t < n; ) r18(e[t]) && (s[s.length] = e[t]), t += 1;\n  return s;\n}\nfunction Ct(r18) {\n  return Object.prototype.toString.call(r18) === \"[object Object]\";\n}\nvar dn = function() {\n  function r18(e, t) {\n    this.xf = t, this.f = e;\n  }\n  return r18.prototype[\"@@transducer/init\"] = K.init, r18.prototype[\"@@transducer/result\"] = K.result, r18.prototype[\"@@transducer/step\"] = function(e, t) {\n    return this.f(t) ? this.xf[\"@@transducer/step\"](e, t) : e;\n  }, r18;\n}();\nfunction Rt(r18) {\n  return function(e) {\n    return new dn(r18, e);\n  };\n}\nvar hn = x(le([\"fantasy-land/filter\", \"filter\"], Rt, function(r18, e) {\n  return Ct(e) ? Fe(function(t, n) {\n    return r18(e[n]) && (t[n] = e[n]), t;\n  }, {}, F(e)) : At(r18, e);\n}));\nvar ar = hn;\nvar pn = x(function(e, t) {\n  return ar(Et(e), t);\n});\nvar ir = pn;\nfunction it(r18, e) {\n  var t = function(i) {\n    var o = e.concat([r18]);\n    return Ot(i, o) ? \"<Circular>\" : it(i, o);\n  }, n = function(a, i) {\n    return G(function(o) {\n      return De(o) + \": \" + t(a[o]);\n    }, i.slice().sort());\n  };\n  switch (Object.prototype.toString.call(r18)) {\n    case \"[object Arguments]\":\n      return \"(function() { return arguments; }(\" + G(t, r18).join(\", \") + \"))\";\n    case \"[object Array]\":\n      return \"[\" + G(t, r18).concat(n(r18, ir(function(a) {\n        return /^\\d+$/.test(a);\n      }, F(r18)))).join(\", \") + \"]\";\n    case \"[object Boolean]\":\n      return typeof r18 == \"object\" ? \"new Boolean(\" + t(r18.valueOf()) + \")\" : r18.toString();\n    case \"[object Date]\":\n      return \"new Date(\" + (isNaN(r18.valueOf()) ? t(NaN) : De(sr(r18))) + \")\";\n    case \"[object Map]\":\n      return \"new Map(\" + t(Array.from(r18)) + \")\";\n    case \"[object Null]\":\n      return \"null\";\n    case \"[object Number]\":\n      return typeof r18 == \"object\" ? \"new Number(\" + t(r18.valueOf()) + \")\" : 1 / r18 === -1 / 0 ? \"-0\" : r18.toString(10);\n    case \"[object Set]\":\n      return \"new Set(\" + t(Array.from(r18).sort()) + \")\";\n    case \"[object String]\":\n      return typeof r18 == \"object\" ? \"new String(\" + t(r18.valueOf()) + \")\" : De(r18);\n    case \"[object Undefined]\":\n      return \"undefined\";\n    default:\n      if (typeof r18.toString == \"function\") {\n        var s = r18.toString();\n        if (s !== \"[object Object]\") return s;\n      }\n      return \"{\" + n(r18, F(r18)).join(\", \") + \"}\";\n  }\n}\nvar mn = E(function(e) {\n  return it(e, []);\n});\nvar jt = mn;\nvar yn = x(function(e, t) {\n  if (e === t) return t;\n  function n(u, l) {\n    if (u > l != l > u) return l > u ? l : u;\n  }\n  var s = n(e, t);\n  if (s !== void 0) return s;\n  var a = n(typeof e, typeof t);\n  if (a !== void 0) return a === typeof e ? e : t;\n  var i = jt(e), o = n(i, jt(t));\n  return o !== void 0 && o === i ? e : t;\n});\nvar or = yn;\nvar gn = function() {\n  function r18(e, t) {\n    this.xf = t, this.f = e;\n  }\n  return r18.prototype[\"@@transducer/init\"] = K.init, r18.prototype[\"@@transducer/result\"] = K.result, r18.prototype[\"@@transducer/step\"] = function(e, t) {\n    return this.xf[\"@@transducer/step\"](e, this.f(t));\n  }, r18;\n}();\nvar _n = function(e) {\n  return function(t) {\n    return new gn(e, t);\n  };\n};\nvar ur = _n;\nvar vn = x(le([\"fantasy-land/map\", \"map\"], ur, function(e, t) {\n  switch (Object.prototype.toString.call(t)) {\n    case \"[object Function]\":\n      return tt(t.length, function() {\n        return e.call(this, t.apply(this, arguments));\n      });\n    case \"[object Object]\":\n      return Fe(function(n, s) {\n        return n[s] = e(t[s]), n;\n      }, {}, F(t));\n    default:\n      return G(e, t);\n  }\n}));\nvar lr = vn;\nvar ot = Number.isInteger || function(e) {\n  return e << 0 === e;\n};\nfunction Ue(r18) {\n  return Object.prototype.toString.call(r18) === \"[object String]\";\n}\nfunction $e(r18, e) {\n  var t = r18 < 0 ? e.length + r18 : r18;\n  return Ue(e) ? e.charAt(t) : e[t];\n}\nvar xn = x(function(e, t) {\n  if (t != null) return ot(e) ? $e(e, t) : t[e];\n});\nvar te = xn;\nvar wn = x(function(e, t) {\n  return lr(te(e), t);\n});\nvar cr = wn;\nvar bn = E(function(e) {\n  return Oe(e) ? true : !e || typeof e != \"object\" || Ue(e) ? false : e.length === 0 ? true : e.length > 0 ? e.hasOwnProperty(0) && e.hasOwnProperty(e.length - 1) : false;\n});\nvar fr = bn;\nvar dr = typeof Symbol < \"u\" ? Symbol.iterator : \"@@iterator\";\nfunction It(r18, e, t) {\n  return function(s, a, i) {\n    if (fr(i)) return r18(s, a, i);\n    if (i == null) return a;\n    if (typeof i[\"fantasy-land/reduce\"] == \"function\") return e(s, a, i, \"fantasy-land/reduce\");\n    if (i[dr] != null) return t(s, a, i[dr]());\n    if (typeof i.next == \"function\") return t(s, a, i);\n    if (typeof i.reduce == \"function\") return e(s, a, i, \"reduce\");\n    throw new TypeError(\"reduce: list must be array or iterable\");\n  };\n}\nfunction Nt(r18, e, t) {\n  for (var n = 0, s = t.length; n < s; ) {\n    if (e = r18[\"@@transducer/step\"](e, t[n]), e && e[\"@@transducer/reduced\"]) {\n      e = e[\"@@transducer/value\"];\n      break;\n    }\n    n += 1;\n  }\n  return r18[\"@@transducer/result\"](e);\n}\nvar Sn = x(function(e, t) {\n  return q(e.length, function() {\n    return e.apply(t, arguments);\n  });\n});\nvar hr = Sn;\nfunction kn(r18, e, t) {\n  for (var n = t.next(); !n.done; ) {\n    if (e = r18[\"@@transducer/step\"](e, n.value), e && e[\"@@transducer/reduced\"]) {\n      e = e[\"@@transducer/value\"];\n      break;\n    }\n    n = t.next();\n  }\n  return r18[\"@@transducer/result\"](e);\n}\nfunction Tn(r18, e, t, n) {\n  return r18[\"@@transducer/result\"](t[n](hr(r18[\"@@transducer/step\"], r18), e));\n}\nvar On = It(Nt, Tn, kn);\nvar pr = On;\nvar En = function() {\n  function r18(e) {\n    this.f = e;\n  }\n  return r18.prototype[\"@@transducer/init\"] = function() {\n    throw new Error(\"init not implemented on XWrap\");\n  }, r18.prototype[\"@@transducer/result\"] = function(e) {\n    return e;\n  }, r18.prototype[\"@@transducer/step\"] = function(e, t) {\n    return this.f(e, t);\n  }, r18;\n}();\nfunction Lt(r18) {\n  return new En(r18);\n}\nvar An = ue(function(r18, e, t) {\n  return pr(typeof r18 == \"function\" ? Lt(r18) : r18, e, t);\n});\nvar ut = An;\nfunction Pt(r18, e) {\n  return function() {\n    return e.call(this, r18.apply(this, arguments));\n  };\n}\nfunction Ve(r18, e) {\n  return function() {\n    var t = arguments.length;\n    if (t === 0) return e();\n    var n = arguments[t - 1];\n    return Oe(n) || typeof n[r18] != \"function\" ? e.apply(this, arguments) : n[r18].apply(n, Array.prototype.slice.call(arguments, 0, t - 1));\n  };\n}\nvar Cn = ue(Ve(\"slice\", function(e, t, n) {\n  return Array.prototype.slice.call(n, e, t);\n}));\nvar mr = Cn;\nvar Rn = E(Ve(\"tail\", mr(1, 1 / 0)));\nvar yr = Rn;\nfunction qe() {\n  if (arguments.length === 0) throw new Error(\"pipe requires at least one argument\");\n  return q(arguments[0].length, ut(Pt, arguments[0], yr(arguments)));\n}\nvar jn = x(function(e, t) {\n  return tt(ut(or, 0, cr(\"length\", t)), function() {\n    var n = arguments, s = this;\n    return e.apply(s, G(function(a) {\n      return a.apply(s, n);\n    }, t));\n  });\n});\nvar gr = jn;\nvar In = x(function(e, t) {\n  return t == null || t !== t ? e : t;\n});\nvar Ge = In;\nvar Nn = function() {\n  function r18(e, t) {\n    this.xf = t, this.f = e, this.found = false;\n  }\n  return r18.prototype[\"@@transducer/init\"] = K.init, r18.prototype[\"@@transducer/result\"] = function(e) {\n    return this.found || (e = this.xf[\"@@transducer/step\"](e, void 0)), this.xf[\"@@transducer/result\"](e);\n  }, r18.prototype[\"@@transducer/step\"] = function(e, t) {\n    return this.f(t) && (this.found = true, e = bt(this.xf[\"@@transducer/step\"](e, t))), e;\n  }, r18;\n}();\nfunction Zt(r18) {\n  return function(e) {\n    return new Nn(r18, e);\n  };\n}\nvar Ln = x(le([\"find\"], Zt, function(e, t) {\n  for (var n = 0, s = t.length; n < s; ) {\n    if (e(t[n])) return t[n];\n    n += 1;\n  }\n}));\nvar Wt = Ln;\nvar Pn = E(function(e) {\n  return gr(function() {\n    return Array.prototype.slice.call(arguments, 0);\n  }, e);\n});\nvar zt = Pn;\nfunction Mt(r18, e) {\n  for (var t = e, n = 0; n < r18.length; n += 1) {\n    if (t == null) return;\n    var s = r18[n];\n    ot(s) ? t = $e(s, t) : t = t[s];\n  }\n  return t;\n}\nvar Zn = x(Mt);\nvar lt = Zn;\nvar Wn = ue(function(e, t, n) {\n  return at(e, te(t, n));\n});\nvar Dt = Wn;\nvar H = class extends Error {\n  name = \"InvalidSchedulerLocation\";\n};\nvar ct = class extends Error {\n  name = \"SchedulerTagNotFound\";\n};\nvar ft = class extends Error {\n  name = \"TransactionNotFound\";\n};\nfunction He(r18 = \"\") {\n  return r18 = r18.trim(), r18.endsWith(\"/\") ? He(r18.slice(0, -1)) : r18;\n}\nvar _r = (r18, { maxRetries: e = 0, delay: t = 300 }) => {\n  let n = (s, a) => Promise.resolve().then(r18).catch((i) => {\n    if (s >= e) return Promise.reject(i);\n    let o = s + 1, u = a + a;\n    return new Promise((l) => setTimeout(l, a)).then(() => n(o, u));\n  });\n  return n(0, t);\n};\nvar vr = (r18) => {\n  if (r18.ok) return r18;\n  throw r18;\n};\nvar zn = \"Url\";\nvar Mn = \"Time-To-Live\";\nvar Dn = \"Scheduler\";\nvar Bt = (r18) => qe(Ge([]), Wt(Dt(r18, \"name\")), Ge({}), te(\"value\"));\nvar xr = (r18) => qe((e) => {\n  if (!e) throw new ft(r18);\n  return e;\n}, te(\"tags\"), Ge([]));\nfunction wr({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t = 0, GRAPHQL_RETRY_BACKOFF: n = 300 }) {\n  return async ({ query: s, variables: a }) => _r(() => r18(e, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ query: s, variables: a }) }).then(vr).then((i) => i.json()), { maxRetries: t, delay: n });\n}\nfunction br({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t, GRAPHQL_RETRY_BACKOFF: n }) {\n  let s = wr({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t, GRAPHQL_RETRY_BACKOFF: n }), a = Ft({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t, GRAPHQL_RETRY_BACKOFF: n }), i = `\n    query GetTransactions ($transactionIds: [ID!]!) {\n      transactions(ids: $transactionIds) {\n        edges {\n          node {\n            tags {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  `;\n  return async (o) => s({ query: i, variables: { transactionIds: [o] } }).then(lt([\"data\", \"transactions\", \"edges\", \"0\", \"node\"])).then(xr(`Process ${o} was not found on gateway`)).then(Bt(Dn)).then((u) => {\n    if (!u) throw new ct('No \"Scheduler\" tag found on process');\n    return a(u);\n  });\n}\nfunction Ft({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t, GRAPHQL_RETRY_BACKOFF: n }) {\n  let s = wr({ fetch: r18, GRAPHQL_URL: e, GRAPHQL_MAX_RETRIES: t, GRAPHQL_RETRY_BACKOFF: n }), a = `\n    query GetSchedulerLocation ($owner: String!) {\n      transactions (\n        owners: [$owner]\n        tags: [\n          { name: \"Data-Protocol\", values: [\"ao\"] },\n          { name: \"Type\", values: [\"Scheduler-Location\"] }\n        ]\n        # Only need the most recent Scheduler-Location\n        sort: HEIGHT_DESC\n        first: 1\n      ) {\n        edges {\n          node {\n            tags {\n              name\n              value\n            }\n          }\n        }\n      }\n    }\n  `;\n  return async (i) => s({ query: a, variables: { owner: i } }).then(lt([\"data\", \"transactions\", \"edges\", \"0\", \"node\"])).then(xr(`Could not find 'Scheduler-Location' owner by wallet ${i}`)).then(zt([Bt(zn), Bt(Mn)])).then(([o, u]) => {\n    if (!o) throw new H('No \"Url\" tag found on Scheduler-Location');\n    if (!u) throw new H('No \"Time-To-Live\" tag found on Scheduler-Location');\n    return { url: o, ttl: u, address: i };\n  });\n}\nvar Ee = typeof performance == \"object\" && performance && typeof performance.now == \"function\" ? performance : Date;\nvar kr = /* @__PURE__ */ new Set();\nvar Ut = typeof process == \"object\" && process ? process : {};\nvar Tr = (r18, e, t, n) => {\n  typeof Ut.emitWarning == \"function\" ? Ut.emitWarning(r18, e, t, n) : console.error(`[${t}] ${e}: ${r18}`);\n};\nvar dt = globalThis.AbortController;\nvar Sr = globalThis.AbortSignal;\nif (typeof dt > \"u\") {\n  Sr = class {\n    onabort;\n    _onabort = [];\n    reason;\n    aborted = false;\n    addEventListener(n, s) {\n      this._onabort.push(s);\n    }\n  }, dt = class {\n    constructor() {\n      e();\n    }\n    signal = new Sr();\n    abort(n) {\n      if (!this.signal.aborted) {\n        this.signal.reason = n, this.signal.aborted = true;\n        for (let s of this.signal._onabort) s(n);\n        this.signal.onabort?.(n);\n      }\n    }\n  };\n  let r18 = Ut.env?.LRU_CACHE_IGNORE_AC_WARNING !== \"1\", e = () => {\n    r18 && (r18 = false, Tr(\"AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\", \"NO_ABORT_CONTROLLER\", \"ENOTSUP\", e));\n  };\n}\nvar Fn = (r18) => !kr.has(r18);\nvar Iu = Symbol(\"type\");\nvar re = (r18) => r18 && r18 === Math.floor(r18) && r18 > 0 && isFinite(r18);\nvar Or = (r18) => re(r18) ? r18 <= Math.pow(2, 8) ? Uint8Array : r18 <= Math.pow(2, 16) ? Uint16Array : r18 <= Math.pow(2, 32) ? Uint32Array : r18 <= Number.MAX_SAFE_INTEGER ? Ae : null : null;\nvar Ae = class extends Array {\n  constructor(e) {\n    super(e), this.fill(0);\n  }\n};\nvar $t = class r {\n  heap;\n  length;\n  static #u = false;\n  static create(e) {\n    let t = Or(e);\n    if (!t) return [];\n    r.#u = true;\n    let n = new r(e, t);\n    return r.#u = false, n;\n  }\n  constructor(e, t) {\n    if (!r.#u) throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n    this.heap = new t(e), this.length = 0;\n  }\n  push(e) {\n    this.heap[this.length++] = e;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n};\nvar ht = class r2 {\n  #u;\n  #f;\n  #m;\n  #y;\n  #C;\n  ttl;\n  ttlResolution;\n  ttlAutopurge;\n  updateAgeOnGet;\n  updateAgeOnHas;\n  allowStale;\n  noDisposeOnSet;\n  noUpdateTTL;\n  maxEntrySize;\n  sizeCalculation;\n  noDeleteOnFetchRejection;\n  noDeleteOnStaleGet;\n  allowStaleOnFetchAbort;\n  allowStaleOnFetchRejection;\n  ignoreFetchAbort;\n  #s;\n  #g;\n  #n;\n  #r;\n  #e;\n  #l;\n  #d;\n  #o;\n  #a;\n  #_;\n  #i;\n  #v;\n  #x;\n  #h;\n  #w;\n  #T;\n  #c;\n  static unsafeExposeInternals(e) {\n    return { starts: e.#x, ttls: e.#h, sizes: e.#v, keyMap: e.#n, keyList: e.#r, valList: e.#e, next: e.#l, prev: e.#d, get head() {\n      return e.#o;\n    }, get tail() {\n      return e.#a;\n    }, free: e.#_, isBackgroundFetch: (t) => e.#t(t), backgroundFetch: (t, n, s, a) => e.#I(t, n, s, a), moveToTail: (t) => e.#A(t), indexes: (t) => e.#b(t), rindexes: (t) => e.#S(t), isStale: (t) => e.#p(t) };\n  }\n  get max() {\n    return this.#u;\n  }\n  get maxSize() {\n    return this.#f;\n  }\n  get calculatedSize() {\n    return this.#g;\n  }\n  get size() {\n    return this.#s;\n  }\n  get fetchMethod() {\n    return this.#C;\n  }\n  get dispose() {\n    return this.#m;\n  }\n  get disposeAfter() {\n    return this.#y;\n  }\n  constructor(e) {\n    let { max: t = 0, ttl: n, ttlResolution: s = 1, ttlAutopurge: a, updateAgeOnGet: i, updateAgeOnHas: o, allowStale: u, dispose: l, disposeAfter: h, noDisposeOnSet: v2, noUpdateTTL: T3, maxSize: S = 0, maxEntrySize: B2 = 0, sizeCalculation: A, fetchMethod: L, noDeleteOnFetchRejection: O, noDeleteOnStaleGet: I2, allowStaleOnFetchRejection: V, allowStaleOnFetchAbort: C2, ignoreFetchAbort: W } = e;\n    if (t !== 0 && !re(t)) throw new TypeError(\"max option must be a nonnegative integer\");\n    let oe = t ? Or(t) : Array;\n    if (!oe) throw new Error(\"invalid max value: \" + t);\n    if (this.#u = t, this.#f = S, this.maxEntrySize = B2 || this.#f, this.sizeCalculation = A, this.sizeCalculation) {\n      if (!this.#f && !this.maxEntrySize) throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n      if (typeof this.sizeCalculation != \"function\") throw new TypeError(\"sizeCalculation set to non-function\");\n    }\n    if (L !== void 0 && typeof L != \"function\") throw new TypeError(\"fetchMethod must be a function if specified\");\n    if (this.#C = L, this.#T = !!L, this.#n = /* @__PURE__ */ new Map(), this.#r = new Array(t).fill(void 0), this.#e = new Array(t).fill(void 0), this.#l = new oe(t), this.#d = new oe(t), this.#o = 0, this.#a = 0, this.#_ = $t.create(t), this.#s = 0, this.#g = 0, typeof l == \"function\" && (this.#m = l), typeof h == \"function\" ? (this.#y = h, this.#i = []) : (this.#y = void 0, this.#i = void 0), this.#w = !!this.#m, this.#c = !!this.#y, this.noDisposeOnSet = !!v2, this.noUpdateTTL = !!T3, this.noDeleteOnFetchRejection = !!O, this.allowStaleOnFetchRejection = !!V, this.allowStaleOnFetchAbort = !!C2, this.ignoreFetchAbort = !!W, this.maxEntrySize !== 0) {\n      if (this.#f !== 0 && !re(this.#f)) throw new TypeError(\"maxSize must be a positive integer if specified\");\n      if (!re(this.maxEntrySize)) throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n      this.#z();\n    }\n    if (this.allowStale = !!u, this.noDeleteOnStaleGet = !!I2, this.updateAgeOnGet = !!i, this.updateAgeOnHas = !!o, this.ttlResolution = re(s) || s === 0 ? s : 1, this.ttlAutopurge = !!a, this.ttl = n || 0, this.ttl) {\n      if (!re(this.ttl)) throw new TypeError(\"ttl must be a positive integer if specified\");\n      this.#N();\n    }\n    if (this.#u === 0 && this.ttl === 0 && this.#f === 0) throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n    if (!this.ttlAutopurge && !this.#u && !this.#f) {\n      let Q2 = \"LRU_CACHE_UNBOUNDED\";\n      Fn(Q2) && (kr.add(Q2), Tr(\"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.\", \"UnboundedCacheWarning\", Q2, r2));\n    }\n  }\n  getRemainingTTL(e) {\n    return this.#n.has(e) ? 1 / 0 : 0;\n  }\n  #N() {\n    let e = new Ae(this.#u), t = new Ae(this.#u);\n    this.#h = e, this.#x = t, this.#L = (a, i, o = Ee.now()) => {\n      if (t[a] = i !== 0 ? o : 0, e[a] = i, i !== 0 && this.ttlAutopurge) {\n        let u = setTimeout(() => {\n          this.#p(a) && this.delete(this.#r[a]);\n        }, i + 1);\n        u.unref && u.unref();\n      }\n    }, this.#O = (a) => {\n      t[a] = e[a] !== 0 ? Ee.now() : 0;\n    }, this.#k = (a, i) => {\n      if (e[i]) {\n        let o = e[i], u = t[i];\n        if (!o || !u) return;\n        a.ttl = o, a.start = u, a.now = n || s();\n        let l = a.now - u;\n        a.remainingTTL = o - l;\n      }\n    };\n    let n = 0, s = () => {\n      let a = Ee.now();\n      if (this.ttlResolution > 0) {\n        n = a;\n        let i = setTimeout(() => n = 0, this.ttlResolution);\n        i.unref && i.unref();\n      }\n      return a;\n    };\n    this.getRemainingTTL = (a) => {\n      let i = this.#n.get(a);\n      if (i === void 0) return 0;\n      let o = e[i], u = t[i];\n      if (!o || !u) return 1 / 0;\n      let l = (n || s()) - u;\n      return o - l;\n    }, this.#p = (a) => {\n      let i = t[a], o = e[a];\n      return !!o && !!i && (n || s()) - i > o;\n    };\n  }\n  #O = () => {\n  };\n  #k = () => {\n  };\n  #L = () => {\n  };\n  #p = () => false;\n  #z() {\n    let e = new Ae(this.#u);\n    this.#g = 0, this.#v = e, this.#E = (t) => {\n      this.#g -= e[t], e[t] = 0;\n    }, this.#P = (t, n, s, a) => {\n      if (this.#t(n)) return 0;\n      if (!re(s)) if (a) {\n        if (typeof a != \"function\") throw new TypeError(\"sizeCalculation must be a function\");\n        if (s = a(n, t), !re(s)) throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n      } else throw new TypeError(\"invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.\");\n      return s;\n    }, this.#R = (t, n, s) => {\n      if (e[t] = n, this.#f) {\n        let a = this.#f - e[t];\n        for (; this.#g > a; ) this.#j(true);\n      }\n      this.#g += e[t], s && (s.entrySize = n, s.totalCalculatedSize = this.#g);\n    };\n  }\n  #E = (e) => {\n  };\n  #R = (e, t, n) => {\n  };\n  #P = (e, t, n, s) => {\n    if (n || s) throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n    return 0;\n  };\n  *#b({ allowStale: e = this.allowStale } = {}) {\n    if (this.#s) for (let t = this.#a; !(!this.#Z(t) || ((e || !this.#p(t)) && (yield t), t === this.#o)); ) t = this.#d[t];\n  }\n  *#S({ allowStale: e = this.allowStale } = {}) {\n    if (this.#s) for (let t = this.#o; !(!this.#Z(t) || ((e || !this.#p(t)) && (yield t), t === this.#a)); ) t = this.#l[t];\n  }\n  #Z(e) {\n    return e !== void 0 && this.#n.get(this.#r[e]) === e;\n  }\n  *entries() {\n    for (let e of this.#b()) this.#e[e] !== void 0 && this.#r[e] !== void 0 && !this.#t(this.#e[e]) && (yield [this.#r[e], this.#e[e]]);\n  }\n  *rentries() {\n    for (let e of this.#S()) this.#e[e] !== void 0 && this.#r[e] !== void 0 && !this.#t(this.#e[e]) && (yield [this.#r[e], this.#e[e]]);\n  }\n  *keys() {\n    for (let e of this.#b()) {\n      let t = this.#r[e];\n      t !== void 0 && !this.#t(this.#e[e]) && (yield t);\n    }\n  }\n  *rkeys() {\n    for (let e of this.#S()) {\n      let t = this.#r[e];\n      t !== void 0 && !this.#t(this.#e[e]) && (yield t);\n    }\n  }\n  *values() {\n    for (let e of this.#b()) this.#e[e] !== void 0 && !this.#t(this.#e[e]) && (yield this.#e[e]);\n  }\n  *rvalues() {\n    for (let e of this.#S()) this.#e[e] !== void 0 && !this.#t(this.#e[e]) && (yield this.#e[e]);\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  [Symbol.toStringTag] = \"LRUCache\";\n  find(e, t = {}) {\n    for (let n of this.#b()) {\n      let s = this.#e[n], a = this.#t(s) ? s.__staleWhileFetching : s;\n      if (a !== void 0 && e(a, this.#r[n], this)) return this.get(this.#r[n], t);\n    }\n  }\n  forEach(e, t = this) {\n    for (let n of this.#b()) {\n      let s = this.#e[n], a = this.#t(s) ? s.__staleWhileFetching : s;\n      a !== void 0 && e.call(t, a, this.#r[n], this);\n    }\n  }\n  rforEach(e, t = this) {\n    for (let n of this.#S()) {\n      let s = this.#e[n], a = this.#t(s) ? s.__staleWhileFetching : s;\n      a !== void 0 && e.call(t, a, this.#r[n], this);\n    }\n  }\n  purgeStale() {\n    let e = false;\n    for (let t of this.#S({ allowStale: true })) this.#p(t) && (this.delete(this.#r[t]), e = true);\n    return e;\n  }\n  info(e) {\n    let t = this.#n.get(e);\n    if (t === void 0) return;\n    let n = this.#e[t], s = this.#t(n) ? n.__staleWhileFetching : n;\n    if (s === void 0) return;\n    let a = { value: s };\n    if (this.#h && this.#x) {\n      let i = this.#h[t], o = this.#x[t];\n      if (i && o) {\n        let u = i - (Ee.now() - o);\n        a.ttl = u, a.start = Date.now();\n      }\n    }\n    return this.#v && (a.size = this.#v[t]), a;\n  }\n  dump() {\n    let e = [];\n    for (let t of this.#b({ allowStale: true })) {\n      let n = this.#r[t], s = this.#e[t], a = this.#t(s) ? s.__staleWhileFetching : s;\n      if (a === void 0 || n === void 0) continue;\n      let i = { value: a };\n      if (this.#h && this.#x) {\n        i.ttl = this.#h[t];\n        let o = Ee.now() - this.#x[t];\n        i.start = Math.floor(Date.now() - o);\n      }\n      this.#v && (i.size = this.#v[t]), e.unshift([n, i]);\n    }\n    return e;\n  }\n  load(e) {\n    this.clear();\n    for (let [t, n] of e) {\n      if (n.start) {\n        let s = Date.now() - n.start;\n        n.start = Ee.now() - s;\n      }\n      this.set(t, n.value, n);\n    }\n  }\n  set(e, t, n = {}) {\n    if (t === void 0) return this.delete(e), this;\n    let { ttl: s = this.ttl, start: a, noDisposeOnSet: i = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: u } = n, { noUpdateTTL: l = this.noUpdateTTL } = n, h = this.#P(e, t, n.size || 0, o);\n    if (this.maxEntrySize && h > this.maxEntrySize) return u && (u.set = \"miss\", u.maxEntrySizeExceeded = true), this.delete(e), this;\n    let v2 = this.#s === 0 ? void 0 : this.#n.get(e);\n    if (v2 === void 0) v2 = this.#s === 0 ? this.#a : this.#_.length !== 0 ? this.#_.pop() : this.#s === this.#u ? this.#j(false) : this.#s, this.#r[v2] = e, this.#e[v2] = t, this.#n.set(e, v2), this.#l[this.#a] = v2, this.#d[v2] = this.#a, this.#a = v2, this.#s++, this.#R(v2, h, u), u && (u.set = \"add\"), l = false;\n    else {\n      this.#A(v2);\n      let T3 = this.#e[v2];\n      if (t !== T3) {\n        if (this.#T && this.#t(T3)) {\n          T3.__abortController.abort(new Error(\"replaced\"));\n          let { __staleWhileFetching: S } = T3;\n          S !== void 0 && !i && (this.#w && this.#m?.(S, e, \"set\"), this.#c && this.#i?.push([S, e, \"set\"]));\n        } else i || (this.#w && this.#m?.(T3, e, \"set\"), this.#c && this.#i?.push([T3, e, \"set\"]));\n        if (this.#E(v2), this.#R(v2, h, u), this.#e[v2] = t, u) {\n          u.set = \"replace\";\n          let S = T3 && this.#t(T3) ? T3.__staleWhileFetching : T3;\n          S !== void 0 && (u.oldValue = S);\n        }\n      } else u && (u.set = \"update\");\n    }\n    if (s !== 0 && !this.#h && this.#N(), this.#h && (l || this.#L(v2, s, a), u && this.#k(u, v2)), !i && this.#c && this.#i) {\n      let T3 = this.#i, S;\n      for (; S = T3?.shift(); ) this.#y?.(...S);\n    }\n    return this;\n  }\n  pop() {\n    try {\n      for (; this.#s; ) {\n        let e = this.#e[this.#o];\n        if (this.#j(true), this.#t(e)) {\n          if (e.__staleWhileFetching) return e.__staleWhileFetching;\n        } else if (e !== void 0) return e;\n      }\n    } finally {\n      if (this.#c && this.#i) {\n        let e = this.#i, t;\n        for (; t = e?.shift(); ) this.#y?.(...t);\n      }\n    }\n  }\n  #j(e) {\n    let t = this.#o, n = this.#r[t], s = this.#e[t];\n    return this.#T && this.#t(s) ? s.__abortController.abort(new Error(\"evicted\")) : (this.#w || this.#c) && (this.#w && this.#m?.(s, n, \"evict\"), this.#c && this.#i?.push([s, n, \"evict\"])), this.#E(t), e && (this.#r[t] = void 0, this.#e[t] = void 0, this.#_.push(t)), this.#s === 1 ? (this.#o = this.#a = 0, this.#_.length = 0) : this.#o = this.#l[t], this.#n.delete(n), this.#s--, t;\n  }\n  has(e, t = {}) {\n    let { updateAgeOnHas: n = this.updateAgeOnHas, status: s } = t, a = this.#n.get(e);\n    if (a !== void 0) {\n      let i = this.#e[a];\n      if (this.#t(i) && i.__staleWhileFetching === void 0) return false;\n      if (this.#p(a)) s && (s.has = \"stale\", this.#k(s, a));\n      else return n && this.#O(a), s && (s.has = \"hit\", this.#k(s, a)), true;\n    } else s && (s.has = \"miss\");\n    return false;\n  }\n  peek(e, t = {}) {\n    let { allowStale: n = this.allowStale } = t, s = this.#n.get(e);\n    if (s === void 0 || !n && this.#p(s)) return;\n    let a = this.#e[s];\n    return this.#t(a) ? a.__staleWhileFetching : a;\n  }\n  #I(e, t, n, s) {\n    let a = t === void 0 ? void 0 : this.#e[t];\n    if (this.#t(a)) return a;\n    let i = new dt(), { signal: o } = n;\n    o?.addEventListener(\"abort\", () => i.abort(o.reason), { signal: i.signal });\n    let u = { signal: i.signal, options: n, context: s }, l = (A, L = false) => {\n      let { aborted: O } = i.signal, I2 = n.ignoreFetchAbort && A !== void 0;\n      if (n.status && (O && !L ? (n.status.fetchAborted = true, n.status.fetchError = i.signal.reason, I2 && (n.status.fetchAbortIgnored = true)) : n.status.fetchResolved = true), O && !I2 && !L) return v2(i.signal.reason);\n      let V = S;\n      return this.#e[t] === S && (A === void 0 ? V.__staleWhileFetching ? this.#e[t] = V.__staleWhileFetching : this.delete(e) : (n.status && (n.status.fetchUpdated = true), this.set(e, A, u.options))), A;\n    }, h = (A) => (n.status && (n.status.fetchRejected = true, n.status.fetchError = A), v2(A)), v2 = (A) => {\n      let { aborted: L } = i.signal, O = L && n.allowStaleOnFetchAbort, I2 = O || n.allowStaleOnFetchRejection, V = I2 || n.noDeleteOnFetchRejection, C2 = S;\n      if (this.#e[t] === S && (!V || C2.__staleWhileFetching === void 0 ? this.delete(e) : O || (this.#e[t] = C2.__staleWhileFetching)), I2) return n.status && C2.__staleWhileFetching !== void 0 && (n.status.returnedStale = true), C2.__staleWhileFetching;\n      if (C2.__returned === C2) throw A;\n    }, T3 = (A, L) => {\n      let O = this.#C?.(e, a, u);\n      O && O instanceof Promise && O.then((I2) => A(I2 === void 0 ? void 0 : I2), L), i.signal.addEventListener(\"abort\", () => {\n        (!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) && (A(void 0), n.allowStaleOnFetchAbort && (A = (I2) => l(I2, true)));\n      });\n    };\n    n.status && (n.status.fetchDispatched = true);\n    let S = new Promise(T3).then(l, h), B2 = Object.assign(S, { __abortController: i, __staleWhileFetching: a, __returned: void 0 });\n    return t === void 0 ? (this.set(e, B2, { ...u.options, status: void 0 }), t = this.#n.get(e)) : this.#e[t] = B2, B2;\n  }\n  #t(e) {\n    if (!this.#T) return false;\n    let t = e;\n    return !!t && t instanceof Promise && t.hasOwnProperty(\"__staleWhileFetching\") && t.__abortController instanceof dt;\n  }\n  async fetch(e, t = {}) {\n    let { allowStale: n = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: a = this.noDeleteOnStaleGet, ttl: i = this.ttl, noDisposeOnSet: o = this.noDisposeOnSet, size: u = 0, sizeCalculation: l = this.sizeCalculation, noUpdateTTL: h = this.noUpdateTTL, noDeleteOnFetchRejection: v2 = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: T3 = this.allowStaleOnFetchRejection, ignoreFetchAbort: S = this.ignoreFetchAbort, allowStaleOnFetchAbort: B2 = this.allowStaleOnFetchAbort, context: A, forceRefresh: L = false, status: O, signal: I2 } = t;\n    if (!this.#T) return O && (O.fetch = \"get\"), this.get(e, { allowStale: n, updateAgeOnGet: s, noDeleteOnStaleGet: a, status: O });\n    let V = { allowStale: n, updateAgeOnGet: s, noDeleteOnStaleGet: a, ttl: i, noDisposeOnSet: o, size: u, sizeCalculation: l, noUpdateTTL: h, noDeleteOnFetchRejection: v2, allowStaleOnFetchRejection: T3, allowStaleOnFetchAbort: B2, ignoreFetchAbort: S, status: O, signal: I2 }, C2 = this.#n.get(e);\n    if (C2 === void 0) {\n      O && (O.fetch = \"miss\");\n      let W = this.#I(e, C2, V, A);\n      return W.__returned = W;\n    } else {\n      let W = this.#e[C2];\n      if (this.#t(W)) {\n        let Jt = n && W.__staleWhileFetching !== void 0;\n        return O && (O.fetch = \"inflight\", Jt && (O.returnedStale = true)), Jt ? W.__staleWhileFetching : W.__returned = W;\n      }\n      let oe = this.#p(C2);\n      if (!L && !oe) return O && (O.fetch = \"hit\"), this.#A(C2), s && this.#O(C2), O && this.#k(O, C2), W;\n      let Q2 = this.#I(e, C2, V, A), Yt2 = Q2.__staleWhileFetching !== void 0 && n;\n      return O && (O.fetch = oe ? \"stale\" : \"refresh\", Yt2 && oe && (O.returnedStale = true)), Yt2 ? Q2.__staleWhileFetching : Q2.__returned = Q2;\n    }\n  }\n  get(e, t = {}) {\n    let { allowStale: n = this.allowStale, updateAgeOnGet: s = this.updateAgeOnGet, noDeleteOnStaleGet: a = this.noDeleteOnStaleGet, status: i } = t, o = this.#n.get(e);\n    if (o !== void 0) {\n      let u = this.#e[o], l = this.#t(u);\n      return i && this.#k(i, o), this.#p(o) ? (i && (i.get = \"stale\"), l ? (i && n && u.__staleWhileFetching !== void 0 && (i.returnedStale = true), n ? u.__staleWhileFetching : void 0) : (a || this.delete(e), i && n && (i.returnedStale = true), n ? u : void 0)) : (i && (i.get = \"hit\"), l ? u.__staleWhileFetching : (this.#A(o), s && this.#O(o), u));\n    } else i && (i.get = \"miss\");\n  }\n  #W(e, t) {\n    this.#d[t] = e, this.#l[e] = t;\n  }\n  #A(e) {\n    e !== this.#a && (e === this.#o ? this.#o = this.#l[e] : this.#W(this.#d[e], this.#l[e]), this.#W(this.#a, e), this.#a = e);\n  }\n  delete(e) {\n    let t = false;\n    if (this.#s !== 0) {\n      let n = this.#n.get(e);\n      if (n !== void 0) if (t = true, this.#s === 1) this.clear();\n      else {\n        this.#E(n);\n        let s = this.#e[n];\n        if (this.#t(s) ? s.__abortController.abort(new Error(\"deleted\")) : (this.#w || this.#c) && (this.#w && this.#m?.(s, e, \"delete\"), this.#c && this.#i?.push([s, e, \"delete\"])), this.#n.delete(e), this.#r[n] = void 0, this.#e[n] = void 0, n === this.#a) this.#a = this.#d[n];\n        else if (n === this.#o) this.#o = this.#l[n];\n        else {\n          let a = this.#d[n];\n          this.#l[a] = this.#l[n];\n          let i = this.#l[n];\n          this.#d[i] = this.#d[n];\n        }\n        this.#s--, this.#_.push(n);\n      }\n    }\n    if (this.#c && this.#i?.length) {\n      let n = this.#i, s;\n      for (; s = n?.shift(); ) this.#y?.(...s);\n    }\n    return t;\n  }\n  clear() {\n    for (let e of this.#S({ allowStale: true })) {\n      let t = this.#e[e];\n      if (this.#t(t)) t.__abortController.abort(new Error(\"deleted\"));\n      else {\n        let n = this.#r[e];\n        this.#w && this.#m?.(t, n, \"delete\"), this.#c && this.#i?.push([t, n, \"delete\"]);\n      }\n    }\n    if (this.#n.clear(), this.#e.fill(void 0), this.#r.fill(void 0), this.#h && this.#x && (this.#h.fill(0), this.#x.fill(0)), this.#v && this.#v.fill(0), this.#o = 0, this.#a = 0, this.#_.length = 0, this.#g = 0, this.#s = 0, this.#c && this.#i) {\n      let e = this.#i, t;\n      for (; t = e?.shift(); ) this.#y?.(...t);\n    }\n  }\n};\nfunction Er({ size: r18 }) {\n  return new ht({ max: r18, maxSize: 5e6, sizeCalculation: (t) => JSON.stringify(t).length, allowStale: true });\n}\nfunction Ar({ cache: r18 }) {\n  return async (e) => {\n    if (r18.max) return r18.get(e);\n  };\n}\nfunction Cr({ cache: r18 }) {\n  return async (e, { url: t, address: n }, s) => {\n    if (r18.max) return r18.set(e, { url: t, address: n }, { ttl: s });\n  };\n}\nfunction Rr({ cache: r18 }) {\n  return async (e) => {\n    if (r18.max) return r18.get(e);\n  };\n}\nfunction jr({ cache: r18 }) {\n  return async (e, t, n) => {\n    if (r18.max) return r18.set(e, { url: t, address: e, ttl: n }, { ttl: n });\n  };\n}\nfunction Ir({ fetch: r18 }) {\n  return async (e, t) => {\n    let n = await r18(`${e}?process-id=${t}`, { method: \"GET\", redirect: \"manual\" });\n    return [301, 302, 307, 308].includes(n.status) ? new URL(n.headers.get(\"Location\")).origin : e;\n  };\n}\nvar w;\n(function(r18) {\n  r18.assertEqual = (s) => s;\n  function e(s) {\n  }\n  r18.assertIs = e;\n  function t(s) {\n    throw new Error();\n  }\n  r18.assertNever = t, r18.arrayToEnum = (s) => {\n    let a = {};\n    for (let i of s) a[i] = i;\n    return a;\n  }, r18.getValidEnumValues = (s) => {\n    let a = r18.objectKeys(s).filter((o) => typeof s[s[o]] != \"number\"), i = {};\n    for (let o of a) i[o] = s[o];\n    return r18.objectValues(i);\n  }, r18.objectValues = (s) => r18.objectKeys(s).map(function(a) {\n    return s[a];\n  }), r18.objectKeys = typeof Object.keys == \"function\" ? (s) => Object.keys(s) : (s) => {\n    let a = [];\n    for (let i in s) Object.prototype.hasOwnProperty.call(s, i) && a.push(i);\n    return a;\n  }, r18.find = (s, a) => {\n    for (let i of s) if (a(i)) return i;\n  }, r18.isInteger = typeof Number.isInteger == \"function\" ? (s) => Number.isInteger(s) : (s) => typeof s == \"number\" && isFinite(s) && Math.floor(s) === s;\n  function n(s, a = \" | \") {\n    return s.map((i) => typeof i == \"string\" ? `'${i}'` : i).join(a);\n  }\n  r18.joinValues = n, r18.jsonStringifyReplacer = (s, a) => typeof a == \"bigint\" ? a.toString() : a;\n})(w || (w = {}));\nvar qt;\n(function(r18) {\n  r18.mergeShapes = (e, t) => ({ ...e, ...t });\n})(qt || (qt = {}));\nvar d = w.arrayToEnum([\"string\", \"nan\", \"number\", \"integer\", \"float\", \"boolean\", \"date\", \"bigint\", \"symbol\", \"function\", \"undefined\", \"null\", \"array\", \"object\", \"unknown\", \"promise\", \"void\", \"never\", \"map\", \"set\"]);\nvar ne = (r18) => {\n  switch (typeof r18) {\n    case \"undefined\":\n      return d.undefined;\n    case \"string\":\n      return d.string;\n    case \"number\":\n      return isNaN(r18) ? d.nan : d.number;\n    case \"boolean\":\n      return d.boolean;\n    case \"function\":\n      return d.function;\n    case \"bigint\":\n      return d.bigint;\n    case \"symbol\":\n      return d.symbol;\n    case \"object\":\n      return Array.isArray(r18) ? d.array : r18 === null ? d.null : r18.then && typeof r18.then == \"function\" && r18.catch && typeof r18.catch == \"function\" ? d.promise : typeof Map < \"u\" && r18 instanceof Map ? d.map : typeof Set < \"u\" && r18 instanceof Set ? d.set : typeof Date < \"u\" && r18 instanceof Date ? d.date : d.object;\n    default:\n      return d.unknown;\n  }\n};\nvar c = w.arrayToEnum([\"invalid_type\", \"invalid_literal\", \"custom\", \"invalid_union\", \"invalid_union_discriminator\", \"invalid_enum_value\", \"unrecognized_keys\", \"invalid_arguments\", \"invalid_return_type\", \"invalid_date\", \"invalid_string\", \"too_small\", \"too_big\", \"invalid_intersection_types\", \"not_multiple_of\", \"not_finite\"]);\nvar Vn = (r18) => JSON.stringify(r18, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\");\nvar P = class r3 extends Error {\n  constructor(e) {\n    super(), this.issues = [], this.addIssue = (n) => {\n      this.issues = [...this.issues, n];\n    }, this.addIssues = (n = []) => {\n      this.issues = [...this.issues, ...n];\n    };\n    let t = new.target.prototype;\n    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = \"ZodError\", this.issues = e;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(e) {\n    let t = e || function(a) {\n      return a.message;\n    }, n = { _errors: [] }, s = (a) => {\n      for (let i of a.issues) if (i.code === \"invalid_union\") i.unionErrors.map(s);\n      else if (i.code === \"invalid_return_type\") s(i.returnTypeError);\n      else if (i.code === \"invalid_arguments\") s(i.argumentsError);\n      else if (i.path.length === 0) n._errors.push(t(i));\n      else {\n        let o = n, u = 0;\n        for (; u < i.path.length; ) {\n          let l = i.path[u];\n          u === i.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(t(i))) : o[l] = o[l] || { _errors: [] }, o = o[l], u++;\n        }\n      }\n    };\n    return s(this), n;\n  }\n  static assert(e) {\n    if (!(e instanceof r3)) throw new Error(`Not a ZodError: ${e}`);\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, w.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(e = (t) => t.message) {\n    let t = {}, n = [];\n    for (let s of this.issues) s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [], t[s.path[0]].push(e(s))) : n.push(e(s));\n    return { formErrors: n, fieldErrors: t };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nP.create = (r18) => new P(r18);\nvar je = (r18, e) => {\n  let t;\n  switch (r18.code) {\n    case c.invalid_type:\n      r18.received === d.undefined ? t = \"Required\" : t = `Expected ${r18.expected}, received ${r18.received}`;\n      break;\n    case c.invalid_literal:\n      t = `Invalid literal value, expected ${JSON.stringify(r18.expected, w.jsonStringifyReplacer)}`;\n      break;\n    case c.unrecognized_keys:\n      t = `Unrecognized key(s) in object: ${w.joinValues(r18.keys, \", \")}`;\n      break;\n    case c.invalid_union:\n      t = \"Invalid input\";\n      break;\n    case c.invalid_union_discriminator:\n      t = `Invalid discriminator value. Expected ${w.joinValues(r18.options)}`;\n      break;\n    case c.invalid_enum_value:\n      t = `Invalid enum value. Expected ${w.joinValues(r18.options)}, received '${r18.received}'`;\n      break;\n    case c.invalid_arguments:\n      t = \"Invalid function arguments\";\n      break;\n    case c.invalid_return_type:\n      t = \"Invalid function return type\";\n      break;\n    case c.invalid_date:\n      t = \"Invalid date\";\n      break;\n    case c.invalid_string:\n      typeof r18.validation == \"object\" ? \"includes\" in r18.validation ? (t = `Invalid input: must include \"${r18.validation.includes}\"`, typeof r18.validation.position == \"number\" && (t = `${t} at one or more positions greater than or equal to ${r18.validation.position}`)) : \"startsWith\" in r18.validation ? t = `Invalid input: must start with \"${r18.validation.startsWith}\"` : \"endsWith\" in r18.validation ? t = `Invalid input: must end with \"${r18.validation.endsWith}\"` : w.assertNever(r18.validation) : r18.validation !== \"regex\" ? t = `Invalid ${r18.validation}` : t = \"Invalid\";\n      break;\n    case c.too_small:\n      r18.type === \"array\" ? t = `Array must contain ${r18.exact ? \"exactly\" : r18.inclusive ? \"at least\" : \"more than\"} ${r18.minimum} element(s)` : r18.type === \"string\" ? t = `String must contain ${r18.exact ? \"exactly\" : r18.inclusive ? \"at least\" : \"over\"} ${r18.minimum} character(s)` : r18.type === \"number\" ? t = `Number must be ${r18.exact ? \"exactly equal to \" : r18.inclusive ? \"greater than or equal to \" : \"greater than \"}${r18.minimum}` : r18.type === \"date\" ? t = `Date must be ${r18.exact ? \"exactly equal to \" : r18.inclusive ? \"greater than or equal to \" : \"greater than \"}${new Date(Number(r18.minimum))}` : t = \"Invalid input\";\n      break;\n    case c.too_big:\n      r18.type === \"array\" ? t = `Array must contain ${r18.exact ? \"exactly\" : r18.inclusive ? \"at most\" : \"less than\"} ${r18.maximum} element(s)` : r18.type === \"string\" ? t = `String must contain ${r18.exact ? \"exactly\" : r18.inclusive ? \"at most\" : \"under\"} ${r18.maximum} character(s)` : r18.type === \"number\" ? t = `Number must be ${r18.exact ? \"exactly\" : r18.inclusive ? \"less than or equal to\" : \"less than\"} ${r18.maximum}` : r18.type === \"bigint\" ? t = `BigInt must be ${r18.exact ? \"exactly\" : r18.inclusive ? \"less than or equal to\" : \"less than\"} ${r18.maximum}` : r18.type === \"date\" ? t = `Date must be ${r18.exact ? \"exactly\" : r18.inclusive ? \"smaller than or equal to\" : \"smaller than\"} ${new Date(Number(r18.maximum))}` : t = \"Invalid input\";\n      break;\n    case c.custom:\n      t = \"Invalid input\";\n      break;\n    case c.invalid_intersection_types:\n      t = \"Intersection results could not be merged\";\n      break;\n    case c.not_multiple_of:\n      t = `Number must be a multiple of ${r18.multipleOf}`;\n      break;\n    case c.not_finite:\n      t = \"Number must be finite\";\n      break;\n    default:\n      t = e.defaultError, w.assertNever(r18);\n  }\n  return { message: t };\n};\nvar Pr = je;\nfunction qn(r18) {\n  Pr = r18;\n}\nfunction pt() {\n  return Pr;\n}\nvar mt = (r18) => {\n  let { data: e, path: t, errorMaps: n, issueData: s } = r18, a = [...t, ...s.path || []], i = { ...s, path: a };\n  if (s.message !== void 0) return { ...s, path: a, message: s.message };\n  let o = \"\", u = n.filter((l) => !!l).slice().reverse();\n  for (let l of u) o = l(i, { data: e, defaultError: o }).message;\n  return { ...s, path: a, message: o };\n};\nvar Gn = [];\nfunction f(r18, e) {\n  let t = pt(), n = mt({ issueData: e, data: r18.data, path: r18.path, errorMaps: [r18.common.contextualErrorMap, r18.schemaErrorMap, t, t === je ? void 0 : je].filter((s) => !!s) });\n  r18.common.issues.push(n);\n}\nvar R = class r4 {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    this.value === \"valid\" && (this.value = \"dirty\");\n  }\n  abort() {\n    this.value !== \"aborted\" && (this.value = \"aborted\");\n  }\n  static mergeArray(e, t) {\n    let n = [];\n    for (let s of t) {\n      if (s.status === \"aborted\") return y;\n      s.status === \"dirty\" && e.dirty(), n.push(s.value);\n    }\n    return { status: e.value, value: n };\n  }\n  static async mergeObjectAsync(e, t) {\n    let n = [];\n    for (let s of t) {\n      let a = await s.key, i = await s.value;\n      n.push({ key: a, value: i });\n    }\n    return r4.mergeObjectSync(e, n);\n  }\n  static mergeObjectSync(e, t) {\n    let n = {};\n    for (let s of t) {\n      let { key: a, value: i } = s;\n      if (a.status === \"aborted\" || i.status === \"aborted\") return y;\n      a.status === \"dirty\" && e.dirty(), i.status === \"dirty\" && e.dirty(), a.value !== \"__proto__\" && (typeof i.value < \"u\" || s.alwaysSet) && (n[a.value] = i.value);\n    }\n    return { status: e.value, value: n };\n  }\n};\nvar y = Object.freeze({ status: \"aborted\" });\nvar Re = (r18) => ({ status: \"dirty\", value: r18 });\nvar j = (r18) => ({ status: \"valid\", value: r18 });\nvar Gt = (r18) => r18.status === \"aborted\";\nvar Ht = (r18) => r18.status === \"dirty\";\nvar Je = (r18) => r18.status === \"valid\";\nvar yt = (r18) => typeof Promise < \"u\" && r18 instanceof Promise;\nfunction gt(r18, e, t, n) {\n  if (t === \"a\" && !n) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof e == \"function\" ? r18 !== e || !n : !e.has(r18)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return t === \"m\" ? n : t === \"a\" ? n.call(r18) : n ? n.value : e.get(r18);\n}\nfunction Zr(r18, e, t, n, s) {\n  if (n === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (n === \"a\" && !s) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof e == \"function\" ? r18 !== e || !s : !e.has(r18)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return n === \"a\" ? s.call(r18, t) : s ? s.value = t : e.set(r18, t), t;\n}\nvar p;\n(function(r18) {\n  r18.errToObj = (e) => typeof e == \"string\" ? { message: e } : e || {}, r18.toString = (e) => typeof e == \"string\" ? e : e?.message;\n})(p || (p = {}));\nvar Xe;\nvar Ye;\nvar M = class {\n  constructor(e, t, n, s) {\n    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = s;\n  }\n  get path() {\n    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n  }\n};\nvar Nr = (r18, e) => {\n  if (Je(e)) return { success: true, data: e.value };\n  if (!r18.common.issues.length) throw new Error(\"Validation failed but no issues detected.\");\n  return { success: false, get error() {\n    if (this._error) return this._error;\n    let t = new P(r18.common.issues);\n    return this._error = t, this._error;\n  } };\n};\nfunction g(r18) {\n  if (!r18) return {};\n  let { errorMap: e, invalid_type_error: t, required_error: n, description: s } = r18;\n  if (e && (t || n)) throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  return e ? { errorMap: e, description: s } : { errorMap: (i, o) => {\n    var u, l;\n    let { message: h } = r18;\n    return i.code === \"invalid_enum_value\" ? { message: h ?? o.defaultError } : typeof o.data > \"u\" ? { message: (u = h ?? n) !== null && u !== void 0 ? u : o.defaultError } : i.code !== \"invalid_type\" ? { message: o.defaultError } : { message: (l = h ?? t) !== null && l !== void 0 ? l : o.defaultError };\n  }, description: s };\n}\nvar _ = class {\n  constructor(e) {\n    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(e) {\n    return ne(e.data);\n  }\n  _getOrReturnCtx(e, t) {\n    return t || { common: e.parent.common, data: e.data, parsedType: ne(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent };\n  }\n  _processInputParams(e) {\n    return { status: new R(), ctx: { common: e.parent.common, data: e.data, parsedType: ne(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } };\n  }\n  _parseSync(e) {\n    let t = this._parse(e);\n    if (yt(t)) throw new Error(\"Synchronous parse encountered promise.\");\n    return t;\n  }\n  _parseAsync(e) {\n    let t = this._parse(e);\n    return Promise.resolve(t);\n  }\n  parse(e, t) {\n    let n = this.safeParse(e, t);\n    if (n.success) return n.data;\n    throw n.error;\n  }\n  safeParse(e, t) {\n    var n;\n    let s = { common: { issues: [], async: (n = t?.async) !== null && n !== void 0 ? n : false, contextualErrorMap: t?.errorMap }, path: t?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: ne(e) }, a = this._parseSync({ data: e, path: s.path, parent: s });\n    return Nr(s, a);\n  }\n  async parseAsync(e, t) {\n    let n = await this.safeParseAsync(e, t);\n    if (n.success) return n.data;\n    throw n.error;\n  }\n  async safeParseAsync(e, t) {\n    let n = { common: { issues: [], contextualErrorMap: t?.errorMap, async: true }, path: t?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: ne(e) }, s = this._parse({ data: e, path: n.path, parent: n }), a = await (yt(s) ? s : Promise.resolve(s));\n    return Nr(n, a);\n  }\n  refine(e, t) {\n    let n = (s) => typeof t == \"string\" || typeof t > \"u\" ? { message: t } : typeof t == \"function\" ? t(s) : t;\n    return this._refinement((s, a) => {\n      let i = e(s), o = () => a.addIssue({ code: c.custom, ...n(s) });\n      return typeof Promise < \"u\" && i instanceof Promise ? i.then((u) => u ? true : (o(), false)) : i ? true : (o(), false);\n    });\n  }\n  refinement(e, t) {\n    return this._refinement((n, s) => e(n) ? true : (s.addIssue(typeof t == \"function\" ? t(n, s) : t), false));\n  }\n  _refinement(e) {\n    return new Z({ schema: this, typeName: m.ZodEffects, effect: { type: \"refinement\", refinement: e } });\n  }\n  superRefine(e) {\n    return this._refinement(e);\n  }\n  optional() {\n    return z.create(this, this._def);\n  }\n  nullable() {\n    return $.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return J.create(this, this._def);\n  }\n  promise() {\n    return ie.create(this, this._def);\n  }\n  or(e) {\n    return ye.create([this, e], this._def);\n  }\n  and(e) {\n    return ge.create(this, e, this._def);\n  }\n  transform(e) {\n    return new Z({ ...g(this._def), schema: this, typeName: m.ZodEffects, effect: { type: \"transform\", transform: e } });\n  }\n  default(e) {\n    let t = typeof e == \"function\" ? e : () => e;\n    return new be({ ...g(this._def), innerType: this, defaultValue: t, typeName: m.ZodDefault });\n  }\n  brand() {\n    return new Qe({ typeName: m.ZodBranded, type: this, ...g(this._def) });\n  }\n  catch(e) {\n    let t = typeof e == \"function\" ? e : () => e;\n    return new Se({ ...g(this._def), innerType: this, catchValue: t, typeName: m.ZodCatch });\n  }\n  describe(e) {\n    let t = this.constructor;\n    return new t({ ...this._def, description: e });\n  }\n  pipe(e) {\n    return Ke.create(this, e);\n  }\n  readonly() {\n    return ke.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar Hn = /^c[^\\s-]{8,}$/i;\nvar Xn = /^[0-9a-z]+$/;\nvar Yn = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar Jn = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar Qn = /^[a-z0-9_-]{21}$/i;\nvar Kn = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar es = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar ts = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nvar Vt;\nvar rs = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ns = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar ss = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar Wr = \"((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))\";\nvar as = new RegExp(`^${Wr}$`);\nfunction zr(r18) {\n  let e = \"([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\";\n  return r18.precision ? e = `${e}\\\\.\\\\d{${r18.precision}}` : r18.precision == null && (e = `${e}(\\\\.\\\\d+)?`), e;\n}\nfunction is(r18) {\n  return new RegExp(`^${zr(r18)}$`);\n}\nfunction Mr(r18) {\n  let e = `${Wr}T${zr(r18)}`, t = [];\n  return t.push(r18.local ? \"Z?\" : \"Z\"), r18.offset && t.push(\"([+-]\\\\d{2}:?\\\\d{2})\"), e = `${e}(${t.join(\"|\")})`, new RegExp(`^${e}$`);\n}\nfunction os(r18, e) {\n  return !!((e === \"v4\" || !e) && rs.test(r18) || (e === \"v6\" || !e) && ns.test(r18));\n}\nvar se = class r5 extends _ {\n  _parse(e) {\n    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== d.string) {\n      let a = this._getOrReturnCtx(e);\n      return f(a, { code: c.invalid_type, expected: d.string, received: a.parsedType }), y;\n    }\n    let n = new R(), s;\n    for (let a of this._def.checks) if (a.kind === \"min\") e.data.length < a.value && (s = this._getOrReturnCtx(e, s), f(s, { code: c.too_small, minimum: a.value, type: \"string\", inclusive: true, exact: false, message: a.message }), n.dirty());\n    else if (a.kind === \"max\") e.data.length > a.value && (s = this._getOrReturnCtx(e, s), f(s, { code: c.too_big, maximum: a.value, type: \"string\", inclusive: true, exact: false, message: a.message }), n.dirty());\n    else if (a.kind === \"length\") {\n      let i = e.data.length > a.value, o = e.data.length < a.value;\n      (i || o) && (s = this._getOrReturnCtx(e, s), i ? f(s, { code: c.too_big, maximum: a.value, type: \"string\", inclusive: true, exact: true, message: a.message }) : o && f(s, { code: c.too_small, minimum: a.value, type: \"string\", inclusive: true, exact: true, message: a.message }), n.dirty());\n    } else if (a.kind === \"email\") es.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"email\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"emoji\") Vt || (Vt = new RegExp(ts, \"u\")), Vt.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"emoji\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"uuid\") Jn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"uuid\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"nanoid\") Qn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"nanoid\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"cuid\") Hn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"cuid\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"cuid2\") Xn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"cuid2\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"ulid\") Yn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"ulid\", code: c.invalid_string, message: a.message }), n.dirty());\n    else if (a.kind === \"url\") try {\n      new URL(e.data);\n    } catch {\n      s = this._getOrReturnCtx(e, s), f(s, { validation: \"url\", code: c.invalid_string, message: a.message }), n.dirty();\n    }\n    else a.kind === \"regex\" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"regex\", code: c.invalid_string, message: a.message }), n.dirty())) : a.kind === \"trim\" ? e.data = e.data.trim() : a.kind === \"includes\" ? e.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: { includes: a.value, position: a.position }, message: a.message }), n.dirty()) : a.kind === \"toLowerCase\" ? e.data = e.data.toLowerCase() : a.kind === \"toUpperCase\" ? e.data = e.data.toUpperCase() : a.kind === \"startsWith\" ? e.data.startsWith(a.value) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: { startsWith: a.value }, message: a.message }), n.dirty()) : a.kind === \"endsWith\" ? e.data.endsWith(a.value) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: { endsWith: a.value }, message: a.message }), n.dirty()) : a.kind === \"datetime\" ? Mr(a).test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: \"datetime\", message: a.message }), n.dirty()) : a.kind === \"date\" ? as.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: \"date\", message: a.message }), n.dirty()) : a.kind === \"time\" ? is(a).test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { code: c.invalid_string, validation: \"time\", message: a.message }), n.dirty()) : a.kind === \"duration\" ? Kn.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"duration\", code: c.invalid_string, message: a.message }), n.dirty()) : a.kind === \"ip\" ? os(e.data, a.version) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"ip\", code: c.invalid_string, message: a.message }), n.dirty()) : a.kind === \"base64\" ? ss.test(e.data) || (s = this._getOrReturnCtx(e, s), f(s, { validation: \"base64\", code: c.invalid_string, message: a.message }), n.dirty()) : w.assertNever(a);\n    return { status: n.value, value: e.data };\n  }\n  _regex(e, t, n) {\n    return this.refinement((s) => e.test(s), { validation: t, code: c.invalid_string, ...p.errToObj(n) });\n  }\n  _addCheck(e) {\n    return new r5({ ...this._def, checks: [...this._def.checks, e] });\n  }\n  email(e) {\n    return this._addCheck({ kind: \"email\", ...p.errToObj(e) });\n  }\n  url(e) {\n    return this._addCheck({ kind: \"url\", ...p.errToObj(e) });\n  }\n  emoji(e) {\n    return this._addCheck({ kind: \"emoji\", ...p.errToObj(e) });\n  }\n  uuid(e) {\n    return this._addCheck({ kind: \"uuid\", ...p.errToObj(e) });\n  }\n  nanoid(e) {\n    return this._addCheck({ kind: \"nanoid\", ...p.errToObj(e) });\n  }\n  cuid(e) {\n    return this._addCheck({ kind: \"cuid\", ...p.errToObj(e) });\n  }\n  cuid2(e) {\n    return this._addCheck({ kind: \"cuid2\", ...p.errToObj(e) });\n  }\n  ulid(e) {\n    return this._addCheck({ kind: \"ulid\", ...p.errToObj(e) });\n  }\n  base64(e) {\n    return this._addCheck({ kind: \"base64\", ...p.errToObj(e) });\n  }\n  ip(e) {\n    return this._addCheck({ kind: \"ip\", ...p.errToObj(e) });\n  }\n  datetime(e) {\n    var t, n;\n    return typeof e == \"string\" ? this._addCheck({ kind: \"datetime\", precision: null, offset: false, local: false, message: e }) : this._addCheck({ kind: \"datetime\", precision: typeof e?.precision > \"u\" ? null : e?.precision, offset: (t = e?.offset) !== null && t !== void 0 ? t : false, local: (n = e?.local) !== null && n !== void 0 ? n : false, ...p.errToObj(e?.message) });\n  }\n  date(e) {\n    return this._addCheck({ kind: \"date\", message: e });\n  }\n  time(e) {\n    return typeof e == \"string\" ? this._addCheck({ kind: \"time\", precision: null, message: e }) : this._addCheck({ kind: \"time\", precision: typeof e?.precision > \"u\" ? null : e?.precision, ...p.errToObj(e?.message) });\n  }\n  duration(e) {\n    return this._addCheck({ kind: \"duration\", ...p.errToObj(e) });\n  }\n  regex(e, t) {\n    return this._addCheck({ kind: \"regex\", regex: e, ...p.errToObj(t) });\n  }\n  includes(e, t) {\n    return this._addCheck({ kind: \"includes\", value: e, position: t?.position, ...p.errToObj(t?.message) });\n  }\n  startsWith(e, t) {\n    return this._addCheck({ kind: \"startsWith\", value: e, ...p.errToObj(t) });\n  }\n  endsWith(e, t) {\n    return this._addCheck({ kind: \"endsWith\", value: e, ...p.errToObj(t) });\n  }\n  min(e, t) {\n    return this._addCheck({ kind: \"min\", value: e, ...p.errToObj(t) });\n  }\n  max(e, t) {\n    return this._addCheck({ kind: \"max\", value: e, ...p.errToObj(t) });\n  }\n  length(e, t) {\n    return this._addCheck({ kind: \"length\", value: e, ...p.errToObj(t) });\n  }\n  nonempty(e) {\n    return this.min(1, p.errToObj(e));\n  }\n  trim() {\n    return new r5({ ...this._def, checks: [...this._def.checks, { kind: \"trim\" }] });\n  }\n  toLowerCase() {\n    return new r5({ ...this._def, checks: [...this._def.checks, { kind: \"toLowerCase\" }] });\n  }\n  toUpperCase() {\n    return new r5({ ...this._def, checks: [...this._def.checks, { kind: \"toUpperCase\" }] });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((e) => e.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((e) => e.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((e) => e.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((e) => e.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((e) => e.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((e) => e.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((e) => e.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((e) => e.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((e) => e.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((e) => e.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((e) => e.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((e) => e.kind === \"ip\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((e) => e.kind === \"base64\");\n  }\n  get minLength() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"min\" && (e === null || t.value > e) && (e = t.value);\n    return e;\n  }\n  get maxLength() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"max\" && (e === null || t.value < e) && (e = t.value);\n    return e;\n  }\n};\nse.create = (r18) => {\n  var e;\n  return new se({ checks: [], typeName: m.ZodString, coerce: (e = r18?.coerce) !== null && e !== void 0 ? e : false, ...g(r18) });\n};\nfunction us(r18, e) {\n  let t = (r18.toString().split(\".\")[1] || \"\").length, n = (e.toString().split(\".\")[1] || \"\").length, s = t > n ? t : n, a = parseInt(r18.toFixed(s).replace(\".\", \"\")), i = parseInt(e.toFixed(s).replace(\".\", \"\"));\n  return a % i / Math.pow(10, s);\n}\nvar ce = class r6 extends _ {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n  }\n  _parse(e) {\n    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== d.number) {\n      let a = this._getOrReturnCtx(e);\n      return f(a, { code: c.invalid_type, expected: d.number, received: a.parsedType }), y;\n    }\n    let n, s = new R();\n    for (let a of this._def.checks) a.kind === \"int\" ? w.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), f(n, { code: c.invalid_type, expected: \"integer\", received: \"float\", message: a.message }), s.dirty()) : a.kind === \"min\" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), f(n, { code: c.too_small, minimum: a.value, type: \"number\", inclusive: a.inclusive, exact: false, message: a.message }), s.dirty()) : a.kind === \"max\" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), f(n, { code: c.too_big, maximum: a.value, type: \"number\", inclusive: a.inclusive, exact: false, message: a.message }), s.dirty()) : a.kind === \"multipleOf\" ? us(e.data, a.value) !== 0 && (n = this._getOrReturnCtx(e, n), f(n, { code: c.not_multiple_of, multipleOf: a.value, message: a.message }), s.dirty()) : a.kind === \"finite\" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), f(n, { code: c.not_finite, message: a.message }), s.dirty()) : w.assertNever(a);\n    return { status: s.value, value: e.data };\n  }\n  gte(e, t) {\n    return this.setLimit(\"min\", e, true, p.toString(t));\n  }\n  gt(e, t) {\n    return this.setLimit(\"min\", e, false, p.toString(t));\n  }\n  lte(e, t) {\n    return this.setLimit(\"max\", e, true, p.toString(t));\n  }\n  lt(e, t) {\n    return this.setLimit(\"max\", e, false, p.toString(t));\n  }\n  setLimit(e, t, n, s) {\n    return new r6({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: p.toString(s) }] });\n  }\n  _addCheck(e) {\n    return new r6({ ...this._def, checks: [...this._def.checks, e] });\n  }\n  int(e) {\n    return this._addCheck({ kind: \"int\", message: p.toString(e) });\n  }\n  positive(e) {\n    return this._addCheck({ kind: \"min\", value: 0, inclusive: false, message: p.toString(e) });\n  }\n  negative(e) {\n    return this._addCheck({ kind: \"max\", value: 0, inclusive: false, message: p.toString(e) });\n  }\n  nonpositive(e) {\n    return this._addCheck({ kind: \"max\", value: 0, inclusive: true, message: p.toString(e) });\n  }\n  nonnegative(e) {\n    return this._addCheck({ kind: \"min\", value: 0, inclusive: true, message: p.toString(e) });\n  }\n  multipleOf(e, t) {\n    return this._addCheck({ kind: \"multipleOf\", value: e, message: p.toString(t) });\n  }\n  finite(e) {\n    return this._addCheck({ kind: \"finite\", message: p.toString(e) });\n  }\n  safe(e) {\n    return this._addCheck({ kind: \"min\", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: p.toString(e) })._addCheck({ kind: \"max\", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: p.toString(e) });\n  }\n  get minValue() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"min\" && (e === null || t.value > e) && (e = t.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"max\" && (e === null || t.value < e) && (e = t.value);\n    return e;\n  }\n  get isInt() {\n    return !!this._def.checks.find((e) => e.kind === \"int\" || e.kind === \"multipleOf\" && w.isInteger(e.value));\n  }\n  get isFinite() {\n    let e = null, t = null;\n    for (let n of this._def.checks) {\n      if (n.kind === \"finite\" || n.kind === \"int\" || n.kind === \"multipleOf\") return true;\n      n.kind === \"min\" ? (t === null || n.value > t) && (t = n.value) : n.kind === \"max\" && (e === null || n.value < e) && (e = n.value);\n    }\n    return Number.isFinite(t) && Number.isFinite(e);\n  }\n};\nce.create = (r18) => new ce({ checks: [], typeName: m.ZodNumber, coerce: r18?.coerce || false, ...g(r18) });\nvar fe = class r7 extends _ {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte;\n  }\n  _parse(e) {\n    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== d.bigint) {\n      let a = this._getOrReturnCtx(e);\n      return f(a, { code: c.invalid_type, expected: d.bigint, received: a.parsedType }), y;\n    }\n    let n, s = new R();\n    for (let a of this._def.checks) a.kind === \"min\" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (n = this._getOrReturnCtx(e, n), f(n, { code: c.too_small, type: \"bigint\", minimum: a.value, inclusive: a.inclusive, message: a.message }), s.dirty()) : a.kind === \"max\" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (n = this._getOrReturnCtx(e, n), f(n, { code: c.too_big, type: \"bigint\", maximum: a.value, inclusive: a.inclusive, message: a.message }), s.dirty()) : a.kind === \"multipleOf\" ? e.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), f(n, { code: c.not_multiple_of, multipleOf: a.value, message: a.message }), s.dirty()) : w.assertNever(a);\n    return { status: s.value, value: e.data };\n  }\n  gte(e, t) {\n    return this.setLimit(\"min\", e, true, p.toString(t));\n  }\n  gt(e, t) {\n    return this.setLimit(\"min\", e, false, p.toString(t));\n  }\n  lte(e, t) {\n    return this.setLimit(\"max\", e, true, p.toString(t));\n  }\n  lt(e, t) {\n    return this.setLimit(\"max\", e, false, p.toString(t));\n  }\n  setLimit(e, t, n, s) {\n    return new r7({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: n, message: p.toString(s) }] });\n  }\n  _addCheck(e) {\n    return new r7({ ...this._def, checks: [...this._def.checks, e] });\n  }\n  positive(e) {\n    return this._addCheck({ kind: \"min\", value: BigInt(0), inclusive: false, message: p.toString(e) });\n  }\n  negative(e) {\n    return this._addCheck({ kind: \"max\", value: BigInt(0), inclusive: false, message: p.toString(e) });\n  }\n  nonpositive(e) {\n    return this._addCheck({ kind: \"max\", value: BigInt(0), inclusive: true, message: p.toString(e) });\n  }\n  nonnegative(e) {\n    return this._addCheck({ kind: \"min\", value: BigInt(0), inclusive: true, message: p.toString(e) });\n  }\n  multipleOf(e, t) {\n    return this._addCheck({ kind: \"multipleOf\", value: e, message: p.toString(t) });\n  }\n  get minValue() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"min\" && (e === null || t.value > e) && (e = t.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"max\" && (e === null || t.value < e) && (e = t.value);\n    return e;\n  }\n};\nfe.create = (r18) => {\n  var e;\n  return new fe({ checks: [], typeName: m.ZodBigInt, coerce: (e = r18?.coerce) !== null && e !== void 0 ? e : false, ...g(r18) });\n};\nvar de = class extends _ {\n  _parse(e) {\n    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== d.boolean) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.boolean, received: n.parsedType }), y;\n    }\n    return j(e.data);\n  }\n};\nde.create = (r18) => new de({ typeName: m.ZodBoolean, coerce: r18?.coerce || false, ...g(r18) });\nvar he = class r8 extends _ {\n  _parse(e) {\n    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== d.date) {\n      let a = this._getOrReturnCtx(e);\n      return f(a, { code: c.invalid_type, expected: d.date, received: a.parsedType }), y;\n    }\n    if (isNaN(e.data.getTime())) {\n      let a = this._getOrReturnCtx(e);\n      return f(a, { code: c.invalid_date }), y;\n    }\n    let n = new R(), s;\n    for (let a of this._def.checks) a.kind === \"min\" ? e.data.getTime() < a.value && (s = this._getOrReturnCtx(e, s), f(s, { code: c.too_small, message: a.message, inclusive: true, exact: false, minimum: a.value, type: \"date\" }), n.dirty()) : a.kind === \"max\" ? e.data.getTime() > a.value && (s = this._getOrReturnCtx(e, s), f(s, { code: c.too_big, message: a.message, inclusive: true, exact: false, maximum: a.value, type: \"date\" }), n.dirty()) : w.assertNever(a);\n    return { status: n.value, value: new Date(e.data.getTime()) };\n  }\n  _addCheck(e) {\n    return new r8({ ...this._def, checks: [...this._def.checks, e] });\n  }\n  min(e, t) {\n    return this._addCheck({ kind: \"min\", value: e.getTime(), message: p.toString(t) });\n  }\n  max(e, t) {\n    return this._addCheck({ kind: \"max\", value: e.getTime(), message: p.toString(t) });\n  }\n  get minDate() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"min\" && (e === null || t.value > e) && (e = t.value);\n    return e != null ? new Date(e) : null;\n  }\n  get maxDate() {\n    let e = null;\n    for (let t of this._def.checks) t.kind === \"max\" && (e === null || t.value < e) && (e = t.value);\n    return e != null ? new Date(e) : null;\n  }\n};\nhe.create = (r18) => new he({ checks: [], coerce: r18?.coerce || false, typeName: m.ZodDate, ...g(r18) });\nvar Ie = class extends _ {\n  _parse(e) {\n    if (this._getType(e) !== d.symbol) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.symbol, received: n.parsedType }), y;\n    }\n    return j(e.data);\n  }\n};\nIe.create = (r18) => new Ie({ typeName: m.ZodSymbol, ...g(r18) });\nvar pe = class extends _ {\n  _parse(e) {\n    if (this._getType(e) !== d.undefined) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.undefined, received: n.parsedType }), y;\n    }\n    return j(e.data);\n  }\n};\npe.create = (r18) => new pe({ typeName: m.ZodUndefined, ...g(r18) });\nvar me = class extends _ {\n  _parse(e) {\n    if (this._getType(e) !== d.null) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.null, received: n.parsedType }), y;\n    }\n    return j(e.data);\n  }\n};\nme.create = (r18) => new me({ typeName: m.ZodNull, ...g(r18) });\nvar ae = class extends _ {\n  constructor() {\n    super(...arguments), this._any = true;\n  }\n  _parse(e) {\n    return j(e.data);\n  }\n};\nae.create = (r18) => new ae({ typeName: m.ZodAny, ...g(r18) });\nvar Y = class extends _ {\n  constructor() {\n    super(...arguments), this._unknown = true;\n  }\n  _parse(e) {\n    return j(e.data);\n  }\n};\nY.create = (r18) => new Y({ typeName: m.ZodUnknown, ...g(r18) });\nvar D = class extends _ {\n  _parse(e) {\n    let t = this._getOrReturnCtx(e);\n    return f(t, { code: c.invalid_type, expected: d.never, received: t.parsedType }), y;\n  }\n};\nD.create = (r18) => new D({ typeName: m.ZodNever, ...g(r18) });\nvar Ne = class extends _ {\n  _parse(e) {\n    if (this._getType(e) !== d.undefined) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.void, received: n.parsedType }), y;\n    }\n    return j(e.data);\n  }\n};\nNe.create = (r18) => new Ne({ typeName: m.ZodVoid, ...g(r18) });\nvar J = class r9 extends _ {\n  _parse(e) {\n    let { ctx: t, status: n } = this._processInputParams(e), s = this._def;\n    if (t.parsedType !== d.array) return f(t, { code: c.invalid_type, expected: d.array, received: t.parsedType }), y;\n    if (s.exactLength !== null) {\n      let i = t.data.length > s.exactLength.value, o = t.data.length < s.exactLength.value;\n      (i || o) && (f(t, { code: i ? c.too_big : c.too_small, minimum: o ? s.exactLength.value : void 0, maximum: i ? s.exactLength.value : void 0, type: \"array\", inclusive: true, exact: true, message: s.exactLength.message }), n.dirty());\n    }\n    if (s.minLength !== null && t.data.length < s.minLength.value && (f(t, { code: c.too_small, minimum: s.minLength.value, type: \"array\", inclusive: true, exact: false, message: s.minLength.message }), n.dirty()), s.maxLength !== null && t.data.length > s.maxLength.value && (f(t, { code: c.too_big, maximum: s.maxLength.value, type: \"array\", inclusive: true, exact: false, message: s.maxLength.message }), n.dirty()), t.common.async) return Promise.all([...t.data].map((i, o) => s.type._parseAsync(new M(t, i, t.path, o)))).then((i) => R.mergeArray(n, i));\n    let a = [...t.data].map((i, o) => s.type._parseSync(new M(t, i, t.path, o)));\n    return R.mergeArray(n, a);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(e, t) {\n    return new r9({ ...this._def, minLength: { value: e, message: p.toString(t) } });\n  }\n  max(e, t) {\n    return new r9({ ...this._def, maxLength: { value: e, message: p.toString(t) } });\n  }\n  length(e, t) {\n    return new r9({ ...this._def, exactLength: { value: e, message: p.toString(t) } });\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n};\nJ.create = (r18, e) => new J({ type: r18, minLength: null, maxLength: null, exactLength: null, typeName: m.ZodArray, ...g(e) });\nfunction Ce(r18) {\n  if (r18 instanceof N) {\n    let e = {};\n    for (let t in r18.shape) {\n      let n = r18.shape[t];\n      e[t] = z.create(Ce(n));\n    }\n    return new N({ ...r18._def, shape: () => e });\n  } else return r18 instanceof J ? new J({ ...r18._def, type: Ce(r18.element) }) : r18 instanceof z ? z.create(Ce(r18.unwrap())) : r18 instanceof $ ? $.create(Ce(r18.unwrap())) : r18 instanceof U ? U.create(r18.items.map((e) => Ce(e))) : r18;\n}\nvar N = class r10 extends _ {\n  constructor() {\n    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null) return this._cached;\n    let e = this._def.shape(), t = w.objectKeys(e);\n    return this._cached = { shape: e, keys: t };\n  }\n  _parse(e) {\n    if (this._getType(e) !== d.object) {\n      let l = this._getOrReturnCtx(e);\n      return f(l, { code: c.invalid_type, expected: d.object, received: l.parsedType }), y;\n    }\n    let { status: n, ctx: s } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];\n    if (!(this._def.catchall instanceof D && this._def.unknownKeys === \"strip\")) for (let l in s.data) i.includes(l) || o.push(l);\n    let u = [];\n    for (let l of i) {\n      let h = a[l], v2 = s.data[l];\n      u.push({ key: { status: \"valid\", value: l }, value: h._parse(new M(s, v2, s.path, l)), alwaysSet: l in s.data });\n    }\n    if (this._def.catchall instanceof D) {\n      let l = this._def.unknownKeys;\n      if (l === \"passthrough\") for (let h of o) u.push({ key: { status: \"valid\", value: h }, value: { status: \"valid\", value: s.data[h] } });\n      else if (l === \"strict\") o.length > 0 && (f(s, { code: c.unrecognized_keys, keys: o }), n.dirty());\n      else if (l !== \"strip\") throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n    } else {\n      let l = this._def.catchall;\n      for (let h of o) {\n        let v2 = s.data[h];\n        u.push({ key: { status: \"valid\", value: h }, value: l._parse(new M(s, v2, s.path, h)), alwaysSet: h in s.data });\n      }\n    }\n    return s.common.async ? Promise.resolve().then(async () => {\n      let l = [];\n      for (let h of u) {\n        let v2 = await h.key, T3 = await h.value;\n        l.push({ key: v2, value: T3, alwaysSet: h.alwaysSet });\n      }\n      return l;\n    }).then((l) => R.mergeObjectSync(n, l)) : R.mergeObjectSync(n, u);\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(e) {\n    return p.errToObj, new r10({ ...this._def, unknownKeys: \"strict\", ...e !== void 0 ? { errorMap: (t, n) => {\n      var s, a, i, o;\n      let u = (i = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, t, n).message) !== null && i !== void 0 ? i : n.defaultError;\n      return t.code === \"unrecognized_keys\" ? { message: (o = p.errToObj(e).message) !== null && o !== void 0 ? o : u } : { message: u };\n    } } : {} });\n  }\n  strip() {\n    return new r10({ ...this._def, unknownKeys: \"strip\" });\n  }\n  passthrough() {\n    return new r10({ ...this._def, unknownKeys: \"passthrough\" });\n  }\n  extend(e) {\n    return new r10({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) });\n  }\n  merge(e) {\n    return new r10({ unknownKeys: e._def.unknownKeys, catchall: e._def.catchall, shape: () => ({ ...this._def.shape(), ...e._def.shape() }), typeName: m.ZodObject });\n  }\n  setKey(e, t) {\n    return this.augment({ [e]: t });\n  }\n  catchall(e) {\n    return new r10({ ...this._def, catchall: e });\n  }\n  pick(e) {\n    let t = {};\n    return w.objectKeys(e).forEach((n) => {\n      e[n] && this.shape[n] && (t[n] = this.shape[n]);\n    }), new r10({ ...this._def, shape: () => t });\n  }\n  omit(e) {\n    let t = {};\n    return w.objectKeys(this.shape).forEach((n) => {\n      e[n] || (t[n] = this.shape[n]);\n    }), new r10({ ...this._def, shape: () => t });\n  }\n  deepPartial() {\n    return Ce(this);\n  }\n  partial(e) {\n    let t = {};\n    return w.objectKeys(this.shape).forEach((n) => {\n      let s = this.shape[n];\n      e && !e[n] ? t[n] = s : t[n] = s.optional();\n    }), new r10({ ...this._def, shape: () => t });\n  }\n  required(e) {\n    let t = {};\n    return w.objectKeys(this.shape).forEach((n) => {\n      if (e && !e[n]) t[n] = this.shape[n];\n      else {\n        let a = this.shape[n];\n        for (; a instanceof z; ) a = a._def.innerType;\n        t[n] = a;\n      }\n    }), new r10({ ...this._def, shape: () => t });\n  }\n  keyof() {\n    return Dr(w.objectKeys(this.shape));\n  }\n};\nN.create = (r18, e) => new N({ shape: () => r18, unknownKeys: \"strip\", catchall: D.create(), typeName: m.ZodObject, ...g(e) });\nN.strictCreate = (r18, e) => new N({ shape: () => r18, unknownKeys: \"strict\", catchall: D.create(), typeName: m.ZodObject, ...g(e) });\nN.lazycreate = (r18, e) => new N({ shape: r18, unknownKeys: \"strip\", catchall: D.create(), typeName: m.ZodObject, ...g(e) });\nvar ye = class extends _ {\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e), n = this._def.options;\n    function s(a) {\n      for (let o of a) if (o.result.status === \"valid\") return o.result;\n      for (let o of a) if (o.result.status === \"dirty\") return t.common.issues.push(...o.ctx.common.issues), o.result;\n      let i = a.map((o) => new P(o.ctx.common.issues));\n      return f(t, { code: c.invalid_union, unionErrors: i }), y;\n    }\n    if (t.common.async) return Promise.all(n.map(async (a) => {\n      let i = { ...t, common: { ...t.common, issues: [] }, parent: null };\n      return { result: await a._parseAsync({ data: t.data, path: t.path, parent: i }), ctx: i };\n    })).then(s);\n    {\n      let a, i = [];\n      for (let u of n) {\n        let l = { ...t, common: { ...t.common, issues: [] }, parent: null }, h = u._parseSync({ data: t.data, path: t.path, parent: l });\n        if (h.status === \"valid\") return h;\n        h.status === \"dirty\" && !a && (a = { result: h, ctx: l }), l.common.issues.length && i.push(l.common.issues);\n      }\n      if (a) return t.common.issues.push(...a.ctx.common.issues), a.result;\n      let o = i.map((u) => new P(u));\n      return f(t, { code: c.invalid_union, unionErrors: o }), y;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nye.create = (r18, e) => new ye({ options: r18, typeName: m.ZodUnion, ...g(e) });\nvar X = (r18) => r18 instanceof _e ? X(r18.schema) : r18 instanceof Z ? X(r18.innerType()) : r18 instanceof ve ? [r18.value] : r18 instanceof xe ? r18.options : r18 instanceof we ? w.objectValues(r18.enum) : r18 instanceof be ? X(r18._def.innerType) : r18 instanceof pe ? [void 0] : r18 instanceof me ? [null] : r18 instanceof z ? [void 0, ...X(r18.unwrap())] : r18 instanceof $ ? [null, ...X(r18.unwrap())] : r18 instanceof Qe || r18 instanceof ke ? X(r18.unwrap()) : r18 instanceof Se ? X(r18._def.innerType) : [];\nvar _t = class r11 extends _ {\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e);\n    if (t.parsedType !== d.object) return f(t, { code: c.invalid_type, expected: d.object, received: t.parsedType }), y;\n    let n = this.discriminator, s = t.data[n], a = this.optionsMap.get(s);\n    return a ? t.common.async ? a._parseAsync({ data: t.data, path: t.path, parent: t }) : a._parseSync({ data: t.data, path: t.path, parent: t }) : (f(t, { code: c.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [n] }), y);\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  static create(e, t, n) {\n    let s = /* @__PURE__ */ new Map();\n    for (let a of t) {\n      let i = X(a.shape[e]);\n      if (!i.length) throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);\n      for (let o of i) {\n        if (s.has(o)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);\n        s.set(o, a);\n      }\n    }\n    return new r11({ typeName: m.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: s, ...g(n) });\n  }\n};\nfunction Xt(r18, e) {\n  let t = ne(r18), n = ne(e);\n  if (r18 === e) return { valid: true, data: r18 };\n  if (t === d.object && n === d.object) {\n    let s = w.objectKeys(e), a = w.objectKeys(r18).filter((o) => s.indexOf(o) !== -1), i = { ...r18, ...e };\n    for (let o of a) {\n      let u = Xt(r18[o], e[o]);\n      if (!u.valid) return { valid: false };\n      i[o] = u.data;\n    }\n    return { valid: true, data: i };\n  } else if (t === d.array && n === d.array) {\n    if (r18.length !== e.length) return { valid: false };\n    let s = [];\n    for (let a = 0; a < r18.length; a++) {\n      let i = r18[a], o = e[a], u = Xt(i, o);\n      if (!u.valid) return { valid: false };\n      s.push(u.data);\n    }\n    return { valid: true, data: s };\n  } else return t === d.date && n === d.date && +r18 == +e ? { valid: true, data: r18 } : { valid: false };\n}\nvar ge = class extends _ {\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e), s = (a, i) => {\n      if (Gt(a) || Gt(i)) return y;\n      let o = Xt(a.value, i.value);\n      return o.valid ? ((Ht(a) || Ht(i)) && t.dirty(), { status: t.value, value: o.data }) : (f(n, { code: c.invalid_intersection_types }), y);\n    };\n    return n.common.async ? Promise.all([this._def.left._parseAsync({ data: n.data, path: n.path, parent: n }), this._def.right._parseAsync({ data: n.data, path: n.path, parent: n })]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({ data: n.data, path: n.path, parent: n }), this._def.right._parseSync({ data: n.data, path: n.path, parent: n }));\n  }\n};\nge.create = (r18, e, t) => new ge({ left: r18, right: e, typeName: m.ZodIntersection, ...g(t) });\nvar U = class r12 extends _ {\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== d.array) return f(n, { code: c.invalid_type, expected: d.array, received: n.parsedType }), y;\n    if (n.data.length < this._def.items.length) return f(n, { code: c.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: \"array\" }), y;\n    !this._def.rest && n.data.length > this._def.items.length && (f(n, { code: c.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: \"array\" }), t.dirty());\n    let a = [...n.data].map((i, o) => {\n      let u = this._def.items[o] || this._def.rest;\n      return u ? u._parse(new M(n, i, n.path, o)) : null;\n    }).filter((i) => !!i);\n    return n.common.async ? Promise.all(a).then((i) => R.mergeArray(t, i)) : R.mergeArray(t, a);\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(e) {\n    return new r12({ ...this._def, rest: e });\n  }\n};\nU.create = (r18, e) => {\n  if (!Array.isArray(r18)) throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  return new U({ items: r18, typeName: m.ZodTuple, rest: null, ...g(e) });\n};\nvar vt = class r13 extends _ {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== d.object) return f(n, { code: c.invalid_type, expected: d.object, received: n.parsedType }), y;\n    let s = [], a = this._def.keyType, i = this._def.valueType;\n    for (let o in n.data) s.push({ key: a._parse(new M(n, o, n.path, o)), value: i._parse(new M(n, n.data[o], n.path, o)), alwaysSet: o in n.data });\n    return n.common.async ? R.mergeObjectAsync(t, s) : R.mergeObjectSync(t, s);\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(e, t, n) {\n    return t instanceof _ ? new r13({ keyType: e, valueType: t, typeName: m.ZodRecord, ...g(n) }) : new r13({ keyType: se.create(), valueType: e, typeName: m.ZodRecord, ...g(t) });\n  }\n};\nvar Le = class extends _ {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== d.map) return f(n, { code: c.invalid_type, expected: d.map, received: n.parsedType }), y;\n    let s = this._def.keyType, a = this._def.valueType, i = [...n.data.entries()].map(([o, u], l) => ({ key: s._parse(new M(n, o, n.path, [l, \"key\"])), value: a._parse(new M(n, u, n.path, [l, \"value\"])) }));\n    if (n.common.async) {\n      let o = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (let u of i) {\n          let l = await u.key, h = await u.value;\n          if (l.status === \"aborted\" || h.status === \"aborted\") return y;\n          (l.status === \"dirty\" || h.status === \"dirty\") && t.dirty(), o.set(l.value, h.value);\n        }\n        return { status: t.value, value: o };\n      });\n    } else {\n      let o = /* @__PURE__ */ new Map();\n      for (let u of i) {\n        let l = u.key, h = u.value;\n        if (l.status === \"aborted\" || h.status === \"aborted\") return y;\n        (l.status === \"dirty\" || h.status === \"dirty\") && t.dirty(), o.set(l.value, h.value);\n      }\n      return { status: t.value, value: o };\n    }\n  }\n};\nLe.create = (r18, e, t) => new Le({ valueType: e, keyType: r18, typeName: m.ZodMap, ...g(t) });\nvar Pe = class r14 extends _ {\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e);\n    if (n.parsedType !== d.set) return f(n, { code: c.invalid_type, expected: d.set, received: n.parsedType }), y;\n    let s = this._def;\n    s.minSize !== null && n.data.size < s.minSize.value && (f(n, { code: c.too_small, minimum: s.minSize.value, type: \"set\", inclusive: true, exact: false, message: s.minSize.message }), t.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (f(n, { code: c.too_big, maximum: s.maxSize.value, type: \"set\", inclusive: true, exact: false, message: s.maxSize.message }), t.dirty());\n    let a = this._def.valueType;\n    function i(u) {\n      let l = /* @__PURE__ */ new Set();\n      for (let h of u) {\n        if (h.status === \"aborted\") return y;\n        h.status === \"dirty\" && t.dirty(), l.add(h.value);\n      }\n      return { status: t.value, value: l };\n    }\n    let o = [...n.data.values()].map((u, l) => a._parse(new M(n, u, n.path, l)));\n    return n.common.async ? Promise.all(o).then((u) => i(u)) : i(o);\n  }\n  min(e, t) {\n    return new r14({ ...this._def, minSize: { value: e, message: p.toString(t) } });\n  }\n  max(e, t) {\n    return new r14({ ...this._def, maxSize: { value: e, message: p.toString(t) } });\n  }\n  size(e, t) {\n    return this.min(e, t).max(e, t);\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n};\nPe.create = (r18, e) => new Pe({ valueType: r18, minSize: null, maxSize: null, typeName: m.ZodSet, ...g(e) });\nvar xt = class r15 extends _ {\n  constructor() {\n    super(...arguments), this.validate = this.implement;\n  }\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e);\n    if (t.parsedType !== d.function) return f(t, { code: c.invalid_type, expected: d.function, received: t.parsedType }), y;\n    function n(o, u) {\n      return mt({ data: o, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, pt(), je].filter((l) => !!l), issueData: { code: c.invalid_arguments, argumentsError: u } });\n    }\n    function s(o, u) {\n      return mt({ data: o, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, pt(), je].filter((l) => !!l), issueData: { code: c.invalid_return_type, returnTypeError: u } });\n    }\n    let a = { errorMap: t.common.contextualErrorMap }, i = t.data;\n    if (this._def.returns instanceof ie) {\n      let o = this;\n      return j(async function(...u) {\n        let l = new P([]), h = await o._def.args.parseAsync(u, a).catch((S) => {\n          throw l.addIssue(n(u, S)), l;\n        }), v2 = await Reflect.apply(i, this, h);\n        return await o._def.returns._def.type.parseAsync(v2, a).catch((S) => {\n          throw l.addIssue(s(v2, S)), l;\n        });\n      });\n    } else {\n      let o = this;\n      return j(function(...u) {\n        let l = o._def.args.safeParse(u, a);\n        if (!l.success) throw new P([n(u, l.error)]);\n        let h = Reflect.apply(i, this, l.data), v2 = o._def.returns.safeParse(h, a);\n        if (!v2.success) throw new P([s(h, v2.error)]);\n        return v2.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...e) {\n    return new r15({ ...this._def, args: U.create(e).rest(Y.create()) });\n  }\n  returns(e) {\n    return new r15({ ...this._def, returns: e });\n  }\n  implement(e) {\n    return this.parse(e);\n  }\n  strictImplement(e) {\n    return this.parse(e);\n  }\n  static create(e, t, n) {\n    return new r15({ args: e || U.create([]).rest(Y.create()), returns: t || Y.create(), typeName: m.ZodFunction, ...g(n) });\n  }\n};\nvar _e = class extends _ {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e);\n    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });\n  }\n};\n_e.create = (r18, e) => new _e({ getter: r18, typeName: m.ZodLazy, ...g(e) });\nvar ve = class extends _ {\n  _parse(e) {\n    if (e.data !== this._def.value) {\n      let t = this._getOrReturnCtx(e);\n      return f(t, { received: t.data, code: c.invalid_literal, expected: this._def.value }), y;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nve.create = (r18, e) => new ve({ value: r18, typeName: m.ZodLiteral, ...g(e) });\nfunction Dr(r18, e) {\n  return new xe({ values: r18, typeName: m.ZodEnum, ...g(e) });\n}\nvar xe = class r16 extends _ {\n  constructor() {\n    super(...arguments), Xe.set(this, void 0);\n  }\n  _parse(e) {\n    if (typeof e.data != \"string\") {\n      let t = this._getOrReturnCtx(e), n = this._def.values;\n      return f(t, { expected: w.joinValues(n), received: t.parsedType, code: c.invalid_type }), y;\n    }\n    if (gt(this, Xe, \"f\") || Zr(this, Xe, new Set(this._def.values), \"f\"), !gt(this, Xe, \"f\").has(e.data)) {\n      let t = this._getOrReturnCtx(e), n = this._def.values;\n      return f(t, { received: t.data, code: c.invalid_enum_value, options: n }), y;\n    }\n    return j(e.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    let e = {};\n    for (let t of this._def.values) e[t] = t;\n    return e;\n  }\n  get Values() {\n    let e = {};\n    for (let t of this._def.values) e[t] = t;\n    return e;\n  }\n  get Enum() {\n    let e = {};\n    for (let t of this._def.values) e[t] = t;\n    return e;\n  }\n  extract(e, t = this._def) {\n    return r16.create(e, { ...this._def, ...t });\n  }\n  exclude(e, t = this._def) {\n    return r16.create(this.options.filter((n) => !e.includes(n)), { ...this._def, ...t });\n  }\n};\nXe = /* @__PURE__ */ new WeakMap();\nxe.create = Dr;\nvar we = class extends _ {\n  constructor() {\n    super(...arguments), Ye.set(this, void 0);\n  }\n  _parse(e) {\n    let t = w.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);\n    if (n.parsedType !== d.string && n.parsedType !== d.number) {\n      let s = w.objectValues(t);\n      return f(n, { expected: w.joinValues(s), received: n.parsedType, code: c.invalid_type }), y;\n    }\n    if (gt(this, Ye, \"f\") || Zr(this, Ye, new Set(w.getValidEnumValues(this._def.values)), \"f\"), !gt(this, Ye, \"f\").has(e.data)) {\n      let s = w.objectValues(t);\n      return f(n, { received: n.data, code: c.invalid_enum_value, options: s }), y;\n    }\n    return j(e.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nYe = /* @__PURE__ */ new WeakMap();\nwe.create = (r18, e) => new we({ values: r18, typeName: m.ZodNativeEnum, ...g(e) });\nvar ie = class extends _ {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e);\n    if (t.parsedType !== d.promise && t.common.async === false) return f(t, { code: c.invalid_type, expected: d.promise, received: t.parsedType }), y;\n    let n = t.parsedType === d.promise ? t.data : Promise.resolve(t.data);\n    return j(n.then((s) => this._def.type.parseAsync(s, { path: t.path, errorMap: t.common.contextualErrorMap })));\n  }\n};\nie.create = (r18, e) => new ie({ type: r18, typeName: m.ZodPromise, ...g(e) });\nvar Z = class extends _ {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === m.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e), s = this._def.effect || null, a = { addIssue: (i) => {\n      f(n, i), i.fatal ? t.abort() : t.dirty();\n    }, get path() {\n      return n.path;\n    } };\n    if (a.addIssue = a.addIssue.bind(a), s.type === \"preprocess\") {\n      let i = s.transform(n.data, a);\n      if (n.common.async) return Promise.resolve(i).then(async (o) => {\n        if (t.value === \"aborted\") return y;\n        let u = await this._def.schema._parseAsync({ data: o, path: n.path, parent: n });\n        return u.status === \"aborted\" ? y : u.status === \"dirty\" || t.value === \"dirty\" ? Re(u.value) : u;\n      });\n      {\n        if (t.value === \"aborted\") return y;\n        let o = this._def.schema._parseSync({ data: i, path: n.path, parent: n });\n        return o.status === \"aborted\" ? y : o.status === \"dirty\" || t.value === \"dirty\" ? Re(o.value) : o;\n      }\n    }\n    if (s.type === \"refinement\") {\n      let i = (o) => {\n        let u = s.refinement(o, a);\n        if (n.common.async) return Promise.resolve(u);\n        if (u instanceof Promise) throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return o;\n      };\n      if (n.common.async === false) {\n        let o = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n });\n        return o.status === \"aborted\" ? y : (o.status === \"dirty\" && t.dirty(), i(o.value), { status: t.value, value: o.value });\n      } else return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === \"aborted\" ? y : (o.status === \"dirty\" && t.dirty(), i(o.value).then(() => ({ status: t.value, value: o.value }))));\n    }\n    if (s.type === \"transform\") if (n.common.async === false) {\n      let i = this._def.schema._parseSync({ data: n.data, path: n.path, parent: n });\n      if (!Je(i)) return i;\n      let o = s.transform(i.value, a);\n      if (o instanceof Promise) throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n      return { status: t.value, value: o };\n    } else return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((i) => Je(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({ status: t.value, value: o })) : i);\n    w.assertNever(s);\n  }\n};\nZ.create = (r18, e, t) => new Z({ schema: r18, typeName: m.ZodEffects, effect: e, ...g(t) });\nZ.createWithPreprocess = (r18, e, t) => new Z({ schema: e, effect: { type: \"preprocess\", transform: r18 }, typeName: m.ZodEffects, ...g(t) });\nvar z = class extends _ {\n  _parse(e) {\n    return this._getType(e) === d.undefined ? j(void 0) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nz.create = (r18, e) => new z({ innerType: r18, typeName: m.ZodOptional, ...g(e) });\nvar $ = class extends _ {\n  _parse(e) {\n    return this._getType(e) === d.null ? j(null) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\n$.create = (r18, e) => new $({ innerType: r18, typeName: m.ZodNullable, ...g(e) });\nvar be = class extends _ {\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e), n = t.data;\n    return t.parsedType === d.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({ data: n, path: t.path, parent: t });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nbe.create = (r18, e) => new be({ innerType: r18, typeName: m.ZodDefault, defaultValue: typeof e.default == \"function\" ? e.default : () => e.default, ...g(e) });\nvar Se = class extends _ {\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e), n = { ...t, common: { ...t.common, issues: [] } }, s = this._def.innerType._parse({ data: n.data, path: n.path, parent: { ...n } });\n    return yt(s) ? s.then((a) => ({ status: \"valid\", value: a.status === \"valid\" ? a.value : this._def.catchValue({ get error() {\n      return new P(n.common.issues);\n    }, input: n.data }) })) : { status: \"valid\", value: s.status === \"valid\" ? s.value : this._def.catchValue({ get error() {\n      return new P(n.common.issues);\n    }, input: n.data }) };\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nSe.create = (r18, e) => new Se({ innerType: r18, typeName: m.ZodCatch, catchValue: typeof e.catch == \"function\" ? e.catch : () => e.catch, ...g(e) });\nvar Ze = class extends _ {\n  _parse(e) {\n    if (this._getType(e) !== d.nan) {\n      let n = this._getOrReturnCtx(e);\n      return f(n, { code: c.invalid_type, expected: d.nan, received: n.parsedType }), y;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n};\nZe.create = (r18) => new Ze({ typeName: m.ZodNaN, ...g(r18) });\nvar ls = Symbol(\"zod_brand\");\nvar Qe = class extends _ {\n  _parse(e) {\n    let { ctx: t } = this._processInputParams(e), n = t.data;\n    return this._def.type._parse({ data: n, path: t.path, parent: t });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar Ke = class r17 extends _ {\n  _parse(e) {\n    let { status: t, ctx: n } = this._processInputParams(e);\n    if (n.common.async) return (async () => {\n      let a = await this._def.in._parseAsync({ data: n.data, path: n.path, parent: n });\n      return a.status === \"aborted\" ? y : a.status === \"dirty\" ? (t.dirty(), Re(a.value)) : this._def.out._parseAsync({ data: a.value, path: n.path, parent: n });\n    })();\n    {\n      let s = this._def.in._parseSync({ data: n.data, path: n.path, parent: n });\n      return s.status === \"aborted\" ? y : s.status === \"dirty\" ? (t.dirty(), { status: \"dirty\", value: s.value }) : this._def.out._parseSync({ data: s.value, path: n.path, parent: n });\n    }\n  }\n  static create(e, t) {\n    return new r17({ in: e, out: t, typeName: m.ZodPipeline });\n  }\n};\nvar ke = class extends _ {\n  _parse(e) {\n    let t = this._def.innerType._parse(e);\n    return Je(t) && (t.value = Object.freeze(t.value)), t;\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nke.create = (r18, e) => new ke({ innerType: r18, typeName: m.ZodReadonly, ...g(e) });\nfunction Br(r18, e = {}, t) {\n  return r18 ? ae.create().superRefine((n, s) => {\n    var a, i;\n    if (!r18(n)) {\n      let o = typeof e == \"function\" ? e(n) : typeof e == \"string\" ? { message: e } : e, u = (i = (a = o.fatal) !== null && a !== void 0 ? a : t) !== null && i !== void 0 ? i : true, l = typeof o == \"string\" ? { message: o } : o;\n      s.addIssue({ code: \"custom\", ...l, fatal: u });\n    }\n  }) : ae.create();\n}\nvar cs = { object: N.lazycreate };\nvar m;\n(function(r18) {\n  r18.ZodString = \"ZodString\", r18.ZodNumber = \"ZodNumber\", r18.ZodNaN = \"ZodNaN\", r18.ZodBigInt = \"ZodBigInt\", r18.ZodBoolean = \"ZodBoolean\", r18.ZodDate = \"ZodDate\", r18.ZodSymbol = \"ZodSymbol\", r18.ZodUndefined = \"ZodUndefined\", r18.ZodNull = \"ZodNull\", r18.ZodAny = \"ZodAny\", r18.ZodUnknown = \"ZodUnknown\", r18.ZodNever = \"ZodNever\", r18.ZodVoid = \"ZodVoid\", r18.ZodArray = \"ZodArray\", r18.ZodObject = \"ZodObject\", r18.ZodUnion = \"ZodUnion\", r18.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", r18.ZodIntersection = \"ZodIntersection\", r18.ZodTuple = \"ZodTuple\", r18.ZodRecord = \"ZodRecord\", r18.ZodMap = \"ZodMap\", r18.ZodSet = \"ZodSet\", r18.ZodFunction = \"ZodFunction\", r18.ZodLazy = \"ZodLazy\", r18.ZodLiteral = \"ZodLiteral\", r18.ZodEnum = \"ZodEnum\", r18.ZodEffects = \"ZodEffects\", r18.ZodNativeEnum = \"ZodNativeEnum\", r18.ZodOptional = \"ZodOptional\", r18.ZodNullable = \"ZodNullable\", r18.ZodDefault = \"ZodDefault\", r18.ZodCatch = \"ZodCatch\", r18.ZodPromise = \"ZodPromise\", r18.ZodBranded = \"ZodBranded\", r18.ZodPipeline = \"ZodPipeline\", r18.ZodReadonly = \"ZodReadonly\";\n})(m || (m = {}));\nvar fs = (r18, e = { message: `Input not instance of ${r18.name}` }) => Br((t) => t instanceof r18, e);\nvar Fr = se.create;\nvar Ur = ce.create;\nvar ds = Ze.create;\nvar hs = fe.create;\nvar $r = de.create;\nvar ps = he.create;\nvar ms = Ie.create;\nvar ys = pe.create;\nvar gs = me.create;\nvar _s = ae.create;\nvar vs = Y.create;\nvar xs = D.create;\nvar ws = Ne.create;\nvar bs = J.create;\nvar Ss = N.create;\nvar ks = N.strictCreate;\nvar Ts = ye.create;\nvar Os = _t.create;\nvar Es = ge.create;\nvar As = U.create;\nvar Cs = vt.create;\nvar Rs = Le.create;\nvar js = Pe.create;\nvar Is = xt.create;\nvar Ns = _e.create;\nvar Ls = ve.create;\nvar Ps = xe.create;\nvar Zs = we.create;\nvar Ws = ie.create;\nvar Lr = Z.create;\nvar zs = z.create;\nvar Ms = $.create;\nvar Ds = Z.createWithPreprocess;\nvar Bs = Ke.create;\nvar Fs = () => Fr().optional();\nvar Us = () => Ur().optional();\nvar $s = () => $r().optional();\nvar Vs = { string: (r18) => se.create({ ...r18, coerce: true }), number: (r18) => ce.create({ ...r18, coerce: true }), boolean: (r18) => de.create({ ...r18, coerce: true }), bigint: (r18) => fe.create({ ...r18, coerce: true }), date: (r18) => he.create({ ...r18, coerce: true }) };\nvar qs = y;\nvar b = Object.freeze({ __proto__: null, defaultErrorMap: je, setErrorMap: qn, getErrorMap: pt, makeIssue: mt, EMPTY_PATH: Gn, addIssueToContext: f, ParseStatus: R, INVALID: y, DIRTY: Re, OK: j, isAborted: Gt, isDirty: Ht, isValid: Je, isAsync: yt, get util() {\n  return w;\n}, get objectUtil() {\n  return qt;\n}, ZodParsedType: d, getParsedType: ne, ZodType: _, datetimeRegex: Mr, ZodString: se, ZodNumber: ce, ZodBigInt: fe, ZodBoolean: de, ZodDate: he, ZodSymbol: Ie, ZodUndefined: pe, ZodNull: me, ZodAny: ae, ZodUnknown: Y, ZodNever: D, ZodVoid: Ne, ZodArray: J, ZodObject: N, ZodUnion: ye, ZodDiscriminatedUnion: _t, ZodIntersection: ge, ZodTuple: U, ZodRecord: vt, ZodMap: Le, ZodSet: Pe, ZodFunction: xt, ZodLazy: _e, ZodLiteral: ve, ZodEnum: xe, ZodNativeEnum: we, ZodPromise: ie, ZodEffects: Z, ZodTransformer: Z, ZodOptional: z, ZodNullable: $, ZodDefault: be, ZodCatch: Se, ZodNaN: Ze, BRAND: ls, ZodBranded: Qe, ZodPipeline: Ke, ZodReadonly: ke, custom: Br, Schema: _, ZodSchema: _, late: cs, get ZodFirstPartyTypeKind() {\n  return m;\n}, coerce: Vs, any: _s, array: bs, bigint: hs, boolean: $r, date: ps, discriminatedUnion: Os, effect: Lr, enum: Ps, function: Is, instanceof: fs, intersection: Es, lazy: Ns, literal: Ls, map: Rs, nan: ds, nativeEnum: Zs, never: xs, null: gs, nullable: Ms, number: Ur, object: Ss, oboolean: $s, onumber: Us, optional: zs, ostring: Fs, pipeline: Bs, preprocess: Ds, promise: Ws, record: Cs, set: js, strictObject: ks, string: Fr, symbol: ms, transformer: Lr, tuple: As, undefined: ys, union: Ts, unknown: vs, void: ws, NEVER: qs, ZodIssueCode: c, quotelessJson: Vn, ZodError: P });\nvar Vr = b.object({ url: b.string(), address: b.string() });\nvar qr = b.object({ url: b.string(), address: b.string(), ttl: b.coerce.number() });\nvar Gr = b.function().args(b.string(), b.string()).returns(b.promise(b.string()));\nvar Hr = b.function().args(b.string()).returns(b.promise(Vr.nullish()));\nvar Xr = b.function().args(b.string(), Vr, b.number()).returns(b.promise(b.any()));\nvar We = b.function().args(b.string()).returns(b.promise(qr.nullish()));\nvar ze = b.function().args(b.string(), b.string(), b.number()).returns(b.promise(b.any()));\nvar Te = b.function().args(b.string()).returns(b.promise(qr));\nvar Yr = Te;\nfunction Jr({ loadProcessScheduler: r18, loadScheduler: e, cache: t, followRedirects: n, checkForRedirect: s }) {\n  r18 = Yr.implement(r18), e = Te.implement(e), s = Gr.implement(s);\n  let a = Hr.implement(t.getByProcess), i = We.implement(t.getByOwner), o = Xr.implement(t.setByProcess), u = ze.implement(t.setByOwner);\n  return (l, h) => a(l).then(async (v2) => v2 || Promise.resolve().then(async () => {\n    if (h) {\n      let T3 = await i(h);\n      return T3 || e(h).then((S) => (u(S.address, S.url, S.ttl), S));\n    }\n    return r18(l);\n  }).then(async (T3) => {\n    let S = T3.url;\n    n && (S = await s(T3.url, l));\n    let B2 = { url: He(S), address: T3.address };\n    return await o(l, B2, T3.ttl), B2;\n  }));\n}\nfunction Qr({ loadScheduler: r18, cache: e }) {\n  r18 = Te.implement(r18);\n  let t = We.implement(e.getByOwner), n = ze.implement(e.setByOwner);\n  return (s) => t(s).then((a) => a ? { url: a.url } : r18(s).then((i) => n(s, i.url, i.ttl).then(() => ({ url: He(i.url) }))).catch((i) => {\n    if (!(i instanceof H)) throw i;\n  }));\n}\nfunction Kr({ loadScheduler: r18, cache: e }) {\n  r18 = Te.implement(r18);\n  let t = We.implement(e.getByOwner), n = ze.implement(e.setByOwner);\n  return (s) => t(s).then((a) => a ? true : r18(s).then((i) => n(s, i.url, i.ttl)).then(() => true).catch((i) => {\n    if (i instanceof H) return false;\n    throw i;\n  }));\n}\nvar Gs = 100;\nvar Hs = \"https://arweave.net/graphql\";\nvar Xs = 0;\nvar Ys = 300;\nvar Js = false;\nfunction en({ cacheSize: r18 = Gs, followRedirects: e = Js, GRAPHQL_URL: t = Hs, GRAPHQL_MAX_RETRIES: n = Xs, GRAPHQL_RETRY_BACKOFF: s = Ys } = {}) {\n  let a = Er({ size: r18 }), i = Ft({ fetch, GRAPHQL_URL: t, GRAPHQL_MAX_RETRIES: n, GRAPHQL_RETRY_BACKOFF: s }), o = { getByProcess: Ar({ cache: a }), getByOwner: Rr({ cache: a }), setByProcess: Cr({ cache: a }), setByOwner: jr({ cache: a }) }, u = Jr({ loadProcessScheduler: br({ fetch, GRAPHQL_URL: t, GRAPHQL_MAX_RETRIES: n, GRAPHQL_RETRY_BACKOFF: s }), loadScheduler: i, cache: o, followRedirects: e, checkForRedirect: Ir({ fetch }) }), l = Kr({ loadScheduler: i, cache: o }), h = Qr({ loadScheduler: i, cache: o });\n  return { locate: u, validate: l, raw: h };\n}\nvar Qs = globalThis.GRAPHQL_URL || void 0;\nvar Ks = globalThis.SCHEDULER_UTILS_CACHE_SIZE || void 0;\nvar ea = globalThis.SCHEDULER_UTILS_FOLLOW_REDIRECTS === \"true\" || void 0;\nvar ta = globalThis.GRAPHQL_MAX_RETRIES || void 0;\nvar ra = globalThis.GRAPHQL_RETRY_BACKOFF || void 0;\nvar { locate: el, validate: tl, raw: rl } = en({ GRAPHQL_URL: Qs, cacheSize: Ks, followRedirects: ea, GRAPHQL_MAX_RETRIES: ta, GRAPHQL_RETRY_BACKOFF: ra });\n\n// node_modules/hyper-async/dist/index.js\nvar Async = (fork) => ({\n  fork,\n  toPromise: () => new Promise((resolve, reject3) => fork(reject3, resolve)),\n  map: (fn2) => Async((rej, res) => fork(rej, (x3) => res(fn2(x3)))),\n  bimap: (f2, g2) => Async(\n    (rej, res) => fork(\n      (x3) => rej(f2(x3)),\n      (x3) => res(g2(x3))\n    )\n  ),\n  chain: (fn2) => Async((rej, res) => fork(rej, (x3) => fn2(x3).fork(rej, res))),\n  bichain: (f2, g2) => Async(\n    (rej, res) => fork(\n      (x3) => f2(x3).fork(rej, res),\n      (x3) => g2(x3).fork(rej, res)\n    )\n  ),\n  fold: (f2, g2) => Async(\n    (rej, res) => fork(\n      (x3) => f2(x3).fork(rej, res),\n      (x3) => g2(x3).fork(rej, res)\n    )\n  )\n});\nvar of = (x3) => Async((rej, res) => res(x3));\nvar Resolved = (x3) => Async((rej, res) => res(x3));\nvar Rejected = (x3) => Async((rej, res) => rej(x3));\nvar fromPromise = (f2) => (...args) => Async(\n  (rej, res) => f2(...args).then(res).catch(rej)\n);\n\n// src/client/ao-mu.js\nfunction deployMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployMessage\");\n  return (args) => {\n    return of(args).chain(\n      fromPromise(({ processId, data, tags, anchor, signer }) => (\n        /**\n         * The processId is the target set on the data item\n         * See https://specs.g8way.io/?tx=xwOgX-MmqN5_-Ny_zNu2A8o-PnTGsoRb_3FrtiMAkuw\n         */\n        signer({ data, tags, target: processId, anchor })\n      ))\n    ).chain(\n      (signedDataItem) => of(signedDataItem).chain(fromPromise(\n        async (signedDataItem2) => fetch2(\n          MU_URL2,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/octet-stream\",\n              Accept: \"application/json\"\n            },\n            redirect: \"follow\",\n            body: signedDataItem2.raw\n          }\n        )\n      )).bichain(\n        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n        fromPromise(\n          async (res) => {\n            if (res.ok) return res.json();\n            throw new Error(`${res.status}: ${await res.text()}`);\n          }\n        )\n      ).bimap(\n        logger.tap(\"Error encountered when writing message via MU\"),\n        logger.tap(\"Successfully wrote message via MU\")\n      ).map((res) => ({ res, messageId: signedDataItem.id }))\n    ).toPromise();\n  };\n}\nfunction deployProcessWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployProcess\");\n  return (args) => {\n    return of(args).chain(fromPromise(({ data, tags, signer }) => signer({ data, tags }))).chain(\n      (signedDataItem) => of(signedDataItem).chain(fromPromise(\n        async (signedDataItem2) => fetch2(\n          MU_URL2,\n          {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/octet-stream\",\n              Accept: \"application/json\"\n            },\n            redirect: \"follow\",\n            body: signedDataItem2.raw\n          }\n        )\n      )).bichain(\n        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n        fromPromise(\n          async (res) => {\n            if (res.ok) return res.json();\n            throw new Error(`${res.status}: ${await res.text()}`);\n          }\n        )\n      ).bimap(\n        logger.tap(\"Error encountered when deploying process via MU\"),\n        logger.tap(\"Successfully deployed process via MU\")\n      ).map((res) => ({ res, processId: signedDataItem.id }))\n    ).toPromise();\n  };\n}\nfunction deployMonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployMonitor\");\n  return (args) => of(args).chain(\n    fromPromise(({ processId, data, tags, anchor, signer }) => (\n      /**\n       * The processId is the target set on the data item\n       */\n      signer({ data, tags, target: processId, anchor })\n    ))\n  ).chain(\n    (signedDataItem) => of(signedDataItem).chain(fromPromise(\n      async (signedDataItem2) => fetch2(\n        MU_URL2 + \"/monitor/\" + args.processId,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          },\n          redirect: \"follow\",\n          body: signedDataItem2.raw\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok) return { ok: true };\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when subscribing to process via MU\"),\n      logger.tap(\"Successfully subscribed to process via MU\")\n    ).map((res) => ({ res, messageId: signedDataItem.id }))\n  ).toPromise();\n}\nfunction deployUnmonitorWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployUnmonitor\");\n  return (args) => of(args).chain(\n    fromPromise(({ processId, data, tags, anchor, signer }) => (\n      /**\n       * The processId is the target set on the data item\n       */\n      signer({ data, tags, target: processId, anchor })\n    ))\n  ).chain(\n    (signedDataItem) => of(signedDataItem).chain(fromPromise(\n      async (signedDataItem2) => fetch2(\n        MU_URL2 + \"/monitor/\" + args.processId,\n        {\n          method: \"DELETE\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          },\n          redirect: \"follow\",\n          body: signedDataItem2.raw\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok) return { ok: true };\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when unsubscribing to process via MU\"),\n      logger.tap(\"Successfully unsubscribed to process via MU\")\n    ).map((res) => ({ res, messageId: signedDataItem.id }))\n  ).toPromise();\n}\nfunction deployAssignWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {\n  const logger = _logger.child(\"deployAssign\");\n  return (args) => {\n    return of(args).chain(fromPromise(\n      async ({ process: process2, message: message2, baseLayer, exclude }) => fetch2(\n        `${MU_URL2}?process-id=${process2}&assign=${message2}${baseLayer ? \"&base-layer\" : \"\"}${exclude ? \"&exclude=\" + exclude.join(\",\") : \"\"}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Accept: \"application/json\"\n          }\n        }\n      )\n    )).bichain(\n      (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),\n      fromPromise(\n        async (res) => {\n          if (res.ok) return res.json();\n          throw new Error(`${res.status}: ${await res.text()}`);\n        }\n      )\n    ).bimap(\n      logger.tap(\"Error encountered when writing assignment via MU\"),\n      logger.tap(\"Successfully wrote assignment via MU\")\n    ).map((res) => ({ res, assignmentId: res.id })).toPromise();\n  };\n}\n\n// src/client/ao-cu.js\nfunction dryrunFetchWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return (msg) => of(msg).map(logger.tap(\"posting dryrun request to CU\")).chain(fromPromise((msg2) => fetch2(`${CU_URL2}/dry-run?process-id=${msg2.Target}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    redirect: \"follow\",\n    body: JSON.stringify(msg2)\n  }).then((res) => res.json()))).toPromise();\n}\nfunction loadResultWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return ({ id, processId }) => {\n    return of(`${CU_URL2}/result/${id}?process-id=${processId}`).map(logger.tap(\"fetching message result from CU\")).chain(fromPromise(\n      async (url) => fetch2(url, {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\"\n        },\n        redirect: \"follow\"\n      }).then((res) => res.json())\n    )).toPromise();\n  };\n}\nfunction queryResultsWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {\n  return ({ process: process2, from, to, sort, limit }) => {\n    const target = new URL(`${CU_URL2}/results/${process2}`);\n    const params = new URLSearchParams(target.search);\n    if (from) {\n      params.append(\"from\", from);\n    }\n    if (to) {\n      params.append(\"to\", to);\n    }\n    if (sort) {\n      params.append(\"sort\", sort);\n    }\n    if (limit) {\n      params.append(\"limit\", limit);\n    }\n    target.search = params;\n    return of(target.toString()).map(logger.tap(\"fetching message result from CU\")).chain(fromPromise(\n      async (url) => fetch2(url, {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\"\n        },\n        redirect: \"follow\"\n      }).then((res) => res.json())\n    )).toPromise();\n  };\n}\n\n// src/client/ao-su.js\nvar import_lru_map = __toESM(require_lru_map(), 1);\nvar processMetaCache;\nvar createProcessMetaCache = ({ MAX_SIZE }) => {\n  if (processMetaCache) return processMetaCache;\n  processMetaCache = new import_lru_map.default(MAX_SIZE);\n  return processMetaCache;\n};\nvar loadProcessMetaWith = ({ logger, fetch: fetch2, cache = processMetaCache }) => {\n  return async ({ suUrl, processId }) => {\n    if (cache.has(processId)) return cache.get(processId);\n    return fetch2(`${suUrl}/processes/${processId}`, { method: \"GET\", redirect: \"follow\" }).then(async (res) => {\n      if (res.ok) return res.json();\n      logger(\"Error Encountered when fetching process meta from SU '%s' for process '%s'\", suUrl, processId);\n      throw new Error(`Encountered Error fetching scheduled messages from Scheduler Unit: ${res.status}: ${await res.text()}`);\n    }).then((meta) => {\n      logger(\"Caching process meta for process '%s'\", processId);\n      cache.set(processId, { tags: meta.tags });\n      return meta;\n    });\n  };\n};\n\n// node_modules/ramda/es/F.js\nvar F2 = function() {\n  return false;\n};\nvar F_default = F2;\n\n// node_modules/ramda/es/T.js\nvar T = function() {\n  return true;\n};\nvar T_default = T;\n\n// node_modules/ramda/es/__.js\nvar __default = {\n  \"@@functional/placeholder\": true\n};\n\n// node_modules/ramda/es/internal/_isPlaceholder.js\nfunction _isPlaceholder(a) {\n  return a != null && typeof a === \"object\" && a[\"@@functional/placeholder\"] === true;\n}\n\n// node_modules/ramda/es/internal/_curry1.js\nfunction _curry1(fn2) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn2.apply(this, arguments);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_curry2.js\nfunction _curry2(fn2) {\n  return function f2(a, b2) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {\n          return fn2(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b2) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {\n          return fn2(_a, b2);\n        }) : _isPlaceholder(b2) ? _curry1(function(_b) {\n          return fn2(a, _b);\n        }) : fn2(a, b2);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_concat.js\nfunction _concat(set1, set2) {\n  set1 = set1 || [];\n  set2 = set2 || [];\n  var idx;\n  var len1 = set1.length;\n  var len2 = set2.length;\n  var result2 = [];\n  idx = 0;\n  while (idx < len1) {\n    result2[result2.length] = set1[idx];\n    idx += 1;\n  }\n  idx = 0;\n  while (idx < len2) {\n    result2[result2.length] = set2[idx];\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_arity.js\nfunction _arity(n, fn2) {\n  switch (n) {\n    case 0:\n      return function() {\n        return fn2.apply(this, arguments);\n      };\n    case 1:\n      return function(a0) {\n        return fn2.apply(this, arguments);\n      };\n    case 2:\n      return function(a0, a1) {\n        return fn2.apply(this, arguments);\n      };\n    case 3:\n      return function(a0, a1, a2) {\n        return fn2.apply(this, arguments);\n      };\n    case 4:\n      return function(a0, a1, a2, a3) {\n        return fn2.apply(this, arguments);\n      };\n    case 5:\n      return function(a0, a1, a2, a3, a4) {\n        return fn2.apply(this, arguments);\n      };\n    case 6:\n      return function(a0, a1, a2, a3, a4, a5) {\n        return fn2.apply(this, arguments);\n      };\n    case 7:\n      return function(a0, a1, a2, a3, a4, a5, a6) {\n        return fn2.apply(this, arguments);\n      };\n    case 8:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn2.apply(this, arguments);\n      };\n    case 9:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn2.apply(this, arguments);\n      };\n    case 10:\n      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn2.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\n\n// node_modules/ramda/es/internal/_curryN.js\nfunction _curryN(length, received, fn2) {\n  return function() {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    var hasPlaceholder = false;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result2;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result2 = received[combinedIdx];\n      } else {\n        result2 = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result2;\n      if (!_isPlaceholder(result2)) {\n        left -= 1;\n      } else {\n        hasPlaceholder = true;\n      }\n      combinedIdx += 1;\n    }\n    return !hasPlaceholder && left <= 0 ? fn2.apply(this, combined) : _arity(Math.max(0, left), _curryN(length, combined, fn2));\n  };\n}\n\n// node_modules/ramda/es/curryN.js\nvar curryN = /* @__PURE__ */ _curry2(function curryN2(length, fn2) {\n  if (length === 1) {\n    return _curry1(fn2);\n  }\n  return _arity(length, _curryN(length, [], fn2));\n});\nvar curryN_default = curryN;\n\n// node_modules/ramda/es/internal/_curry3.js\nfunction _curry3(fn2) {\n  return function f3(a, b2, c2) {\n    switch (arguments.length) {\n      case 0:\n        return f3;\n      case 1:\n        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {\n          return fn2(a, _b, _c);\n        });\n      case 2:\n        return _isPlaceholder(a) && _isPlaceholder(b2) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {\n          return fn2(_a, b2, _c);\n        }) : _isPlaceholder(b2) ? _curry2(function(_b, _c) {\n          return fn2(a, _b, _c);\n        }) : _curry1(function(_c) {\n          return fn2(a, b2, _c);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b2) && _isPlaceholder(c2) ? f3 : _isPlaceholder(a) && _isPlaceholder(b2) ? _curry2(function(_a, _b) {\n          return fn2(_a, _b, c2);\n        }) : _isPlaceholder(a) && _isPlaceholder(c2) ? _curry2(function(_a, _c) {\n          return fn2(_a, b2, _c);\n        }) : _isPlaceholder(b2) && _isPlaceholder(c2) ? _curry2(function(_b, _c) {\n          return fn2(a, _b, _c);\n        }) : _isPlaceholder(a) ? _curry1(function(_a) {\n          return fn2(_a, b2, c2);\n        }) : _isPlaceholder(b2) ? _curry1(function(_b) {\n          return fn2(a, _b, c2);\n        }) : _isPlaceholder(c2) ? _curry1(function(_c) {\n          return fn2(a, b2, _c);\n        }) : fn2(a, b2, c2);\n    }\n  };\n}\n\n// node_modules/ramda/es/internal/_isArray.js\nvar isArray_default = Array.isArray || function _isArray(val) {\n  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === \"[object Array]\";\n};\n\n// node_modules/ramda/es/internal/_isTransformer.js\nfunction _isTransformer(obj) {\n  return obj != null && typeof obj[\"@@transducer/step\"] === \"function\";\n}\n\n// node_modules/ramda/es/internal/_dispatchable.js\nfunction _dispatchable(methodNames, transducerCreator, fn2) {\n  return function() {\n    if (arguments.length === 0) {\n      return fn2();\n    }\n    var obj = arguments[arguments.length - 1];\n    if (!isArray_default(obj)) {\n      var idx = 0;\n      while (idx < methodNames.length) {\n        if (typeof obj[methodNames[idx]] === \"function\") {\n          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));\n        }\n        idx += 1;\n      }\n      if (_isTransformer(obj)) {\n        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return transducer(obj);\n      }\n    }\n    return fn2.apply(this, arguments);\n  };\n}\n\n// node_modules/ramda/es/internal/_xfBase.js\nvar xfBase_default = {\n  init: function() {\n    return this.xf[\"@@transducer/init\"]();\n  },\n  result: function(result2) {\n    return this.xf[\"@@transducer/result\"](result2);\n  }\n};\n\n// node_modules/ramda/es/internal/_arrayFromIterator.js\nfunction _arrayFromIterator(iter) {\n  var list = [];\n  var next;\n  while (!(next = iter.next()).done) {\n    list.push(next.value);\n  }\n  return list;\n}\n\n// node_modules/ramda/es/internal/_includesWith.js\nfunction _includesWith(pred, x3, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    if (pred(x3, list[idx])) {\n      return true;\n    }\n    idx += 1;\n  }\n  return false;\n}\n\n// node_modules/ramda/es/internal/_functionName.js\nfunction _functionName(f2) {\n  var match = String(f2).match(/^function (\\w*)/);\n  return match == null ? \"\" : match[1];\n}\n\n// node_modules/ramda/es/internal/_has.js\nfunction _has(prop3, obj) {\n  return Object.prototype.hasOwnProperty.call(obj, prop3);\n}\n\n// node_modules/ramda/es/internal/_objectIs.js\nfunction _objectIs(a, b2) {\n  if (a === b2) {\n    return a !== 0 || 1 / a === 1 / b2;\n  } else {\n    return a !== a && b2 !== b2;\n  }\n}\nvar objectIs_default = typeof Object.is === \"function\" ? Object.is : _objectIs;\n\n// node_modules/ramda/es/internal/_isArguments.js\nvar toString = Object.prototype.toString;\nvar _isArguments = /* @__PURE__ */ function() {\n  return toString.call(arguments) === \"[object Arguments]\" ? function _isArguments2(x3) {\n    return toString.call(x3) === \"[object Arguments]\";\n  } : function _isArguments2(x3) {\n    return _has(\"callee\", x3);\n  };\n}();\nvar isArguments_default = _isArguments;\n\n// node_modules/ramda/es/keys.js\nvar hasEnumBug = !/* @__PURE__ */ {\n  toString: null\n}.propertyIsEnumerable(\"toString\");\nvar nonEnumerableProps = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"];\nvar hasArgsEnumBug = /* @__PURE__ */ function() {\n  \"use strict\";\n  return arguments.propertyIsEnumerable(\"length\");\n}();\nvar contains = function contains2(list, item) {\n  var idx = 0;\n  while (idx < list.length) {\n    if (list[idx] === item) {\n      return true;\n    }\n    idx += 1;\n  }\n  return false;\n};\nvar keys = typeof Object.keys === \"function\" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {\n  return Object(obj) !== obj ? [] : Object.keys(obj);\n}) : /* @__PURE__ */ _curry1(function keys3(obj) {\n  if (Object(obj) !== obj) {\n    return [];\n  }\n  var prop3, nIdx;\n  var ks2 = [];\n  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);\n  for (prop3 in obj) {\n    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== \"length\")) {\n      ks2[ks2.length] = prop3;\n    }\n  }\n  if (hasEnumBug) {\n    nIdx = nonEnumerableProps.length - 1;\n    while (nIdx >= 0) {\n      prop3 = nonEnumerableProps[nIdx];\n      if (_has(prop3, obj) && !contains(ks2, prop3)) {\n        ks2[ks2.length] = prop3;\n      }\n      nIdx -= 1;\n    }\n  }\n  return ks2;\n});\nvar keys_default = keys;\n\n// node_modules/ramda/es/type.js\nvar type = /* @__PURE__ */ _curry1(function type2(val) {\n  return val === null ? \"Null\" : val === void 0 ? \"Undefined\" : Object.prototype.toString.call(val).slice(8, -1);\n});\nvar type_default = type;\n\n// node_modules/ramda/es/internal/_equals.js\nfunction _uniqContentEquals(aIterator, bIterator, stackA, stackB) {\n  var a = _arrayFromIterator(aIterator);\n  var b2 = _arrayFromIterator(bIterator);\n  function eq(_a, _b) {\n    return _equals(_a, _b, stackA.slice(), stackB.slice());\n  }\n  return !_includesWith(function(b3, aItem) {\n    return !_includesWith(eq, aItem, b3);\n  }, b2, a);\n}\nfunction _equals(a, b2, stackA, stackB) {\n  if (objectIs_default(a, b2)) {\n    return true;\n  }\n  var typeA = type_default(a);\n  if (typeA !== type_default(b2)) {\n    return false;\n  }\n  if (typeof a[\"fantasy-land/equals\"] === \"function\" || typeof b2[\"fantasy-land/equals\"] === \"function\") {\n    return typeof a[\"fantasy-land/equals\"] === \"function\" && a[\"fantasy-land/equals\"](b2) && typeof b2[\"fantasy-land/equals\"] === \"function\" && b2[\"fantasy-land/equals\"](a);\n  }\n  if (typeof a.equals === \"function\" || typeof b2.equals === \"function\") {\n    return typeof a.equals === \"function\" && a.equals(b2) && typeof b2.equals === \"function\" && b2.equals(a);\n  }\n  switch (typeA) {\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n      if (typeof a.constructor === \"function\" && _functionName(a.constructor) === \"Promise\") {\n        return a === b2;\n      }\n      break;\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n      if (!(typeof a === typeof b2 && objectIs_default(a.valueOf(), b2.valueOf()))) {\n        return false;\n      }\n      break;\n    case \"Date\":\n      if (!objectIs_default(a.valueOf(), b2.valueOf())) {\n        return false;\n      }\n      break;\n    case \"Error\":\n      return a.name === b2.name && a.message === b2.message;\n    case \"RegExp\":\n      if (!(a.source === b2.source && a.global === b2.global && a.ignoreCase === b2.ignoreCase && a.multiline === b2.multiline && a.sticky === b2.sticky && a.unicode === b2.unicode)) {\n        return false;\n      }\n      break;\n  }\n  var idx = stackA.length - 1;\n  while (idx >= 0) {\n    if (stackA[idx] === a) {\n      return stackB[idx] === b2;\n    }\n    idx -= 1;\n  }\n  switch (typeA) {\n    case \"Map\":\n      if (a.size !== b2.size) {\n        return false;\n      }\n      return _uniqContentEquals(a.entries(), b2.entries(), stackA.concat([a]), stackB.concat([b2]));\n    case \"Set\":\n      if (a.size !== b2.size) {\n        return false;\n      }\n      return _uniqContentEquals(a.values(), b2.values(), stackA.concat([a]), stackB.concat([b2]));\n    case \"Arguments\":\n    case \"Array\":\n    case \"Object\":\n    case \"Boolean\":\n    case \"Number\":\n    case \"String\":\n    case \"Date\":\n    case \"Error\":\n    case \"RegExp\":\n    case \"Int8Array\":\n    case \"Uint8Array\":\n    case \"Uint8ClampedArray\":\n    case \"Int16Array\":\n    case \"Uint16Array\":\n    case \"Int32Array\":\n    case \"Uint32Array\":\n    case \"Float32Array\":\n    case \"Float64Array\":\n    case \"ArrayBuffer\":\n      break;\n    default:\n      return false;\n  }\n  var keysA = keys_default(a);\n  if (keysA.length !== keys_default(b2).length) {\n    return false;\n  }\n  var extendedStackA = stackA.concat([a]);\n  var extendedStackB = stackB.concat([b2]);\n  idx = keysA.length - 1;\n  while (idx >= 0) {\n    var key = keysA[idx];\n    if (!(_has(key, b2) && _equals(b2[key], a[key], extendedStackA, extendedStackB))) {\n      return false;\n    }\n    idx -= 1;\n  }\n  return true;\n}\n\n// node_modules/ramda/es/equals.js\nvar equals = /* @__PURE__ */ _curry2(function equals2(a, b2) {\n  return _equals(a, b2, [], []);\n});\nvar equals_default = equals;\n\n// node_modules/ramda/es/internal/_indexOf.js\nfunction _indexOf(list, a, idx) {\n  var inf, item;\n  if (typeof list.indexOf === \"function\") {\n    switch (typeof a) {\n      case \"number\":\n        if (a === 0) {\n          inf = 1 / a;\n          while (idx < list.length) {\n            item = list[idx];\n            if (item === 0 && 1 / item === inf) {\n              return idx;\n            }\n            idx += 1;\n          }\n          return -1;\n        } else if (a !== a) {\n          while (idx < list.length) {\n            item = list[idx];\n            if (typeof item === \"number\" && item !== item) {\n              return idx;\n            }\n            idx += 1;\n          }\n          return -1;\n        }\n        return list.indexOf(a, idx);\n      case \"string\":\n      case \"boolean\":\n      case \"function\":\n      case \"undefined\":\n        return list.indexOf(a, idx);\n      case \"object\":\n        if (a === null) {\n          return list.indexOf(a, idx);\n        }\n    }\n  }\n  while (idx < list.length) {\n    if (equals_default(list[idx], a)) {\n      return idx;\n    }\n    idx += 1;\n  }\n  return -1;\n}\n\n// node_modules/ramda/es/internal/_includes.js\nfunction _includes(a, list) {\n  return _indexOf(list, a, 0) >= 0;\n}\n\n// node_modules/ramda/es/internal/_map.js\nfunction _map(fn2, functor) {\n  var idx = 0;\n  var len = functor.length;\n  var result2 = Array(len);\n  while (idx < len) {\n    result2[idx] = fn2(functor[idx]);\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_quote.js\nfunction _quote(s) {\n  var escaped = s.replace(/\\\\/g, \"\\\\\\\\\").replace(/[\\b]/g, \"\\\\b\").replace(/\\f/g, \"\\\\f\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\v/g, \"\\\\v\").replace(/\\0/g, \"\\\\0\");\n  return '\"' + escaped.replace(/\"/g, '\\\\\"') + '\"';\n}\n\n// node_modules/ramda/es/internal/_toISOString.js\nvar pad = function pad2(n) {\n  return (n < 10 ? \"0\" : \"\") + n;\n};\nvar _toISOString = typeof Date.prototype.toISOString === \"function\" ? function _toISOString2(d2) {\n  return d2.toISOString();\n} : function _toISOString3(d2) {\n  return d2.getUTCFullYear() + \"-\" + pad(d2.getUTCMonth() + 1) + \"-\" + pad(d2.getUTCDate()) + \"T\" + pad(d2.getUTCHours()) + \":\" + pad(d2.getUTCMinutes()) + \":\" + pad(d2.getUTCSeconds()) + \".\" + (d2.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + \"Z\";\n};\nvar toISOString_default = _toISOString;\n\n// node_modules/ramda/es/internal/_complement.js\nfunction _complement(f2) {\n  return function() {\n    return !f2.apply(this, arguments);\n  };\n}\n\n// node_modules/ramda/es/internal/_arrayReduce.js\nfunction _arrayReduce(reducer, acc, list) {\n  var index = 0;\n  var length = list.length;\n  while (index < length) {\n    acc = reducer(acc, list[index]);\n    index += 1;\n  }\n  return acc;\n}\n\n// node_modules/ramda/es/internal/_filter.js\nfunction _filter(fn2, list) {\n  var idx = 0;\n  var len = list.length;\n  var result2 = [];\n  while (idx < len) {\n    if (fn2(list[idx])) {\n      result2[result2.length] = list[idx];\n    }\n    idx += 1;\n  }\n  return result2;\n}\n\n// node_modules/ramda/es/internal/_isObject.js\nfunction _isObject(x3) {\n  return Object.prototype.toString.call(x3) === \"[object Object]\";\n}\n\n// node_modules/ramda/es/internal/_xfilter.js\nvar XFilter = /* @__PURE__ */ function() {\n  function XFilter2(f2, xf) {\n    this.xf = xf;\n    this.f = f2;\n  }\n  XFilter2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XFilter2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XFilter2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    return this.f(input) ? this.xf[\"@@transducer/step\"](result2, input) : result2;\n  };\n  return XFilter2;\n}();\nfunction _xfilter(f2) {\n  return function(xf) {\n    return new XFilter(f2, xf);\n  };\n}\n\n// node_modules/ramda/es/filter.js\nvar filter = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([\"fantasy-land/filter\", \"filter\"], _xfilter, function(pred, filterable) {\n  return _isObject(filterable) ? _arrayReduce(function(acc, key) {\n    if (pred(filterable[key])) {\n      acc[key] = filterable[key];\n    }\n    return acc;\n  }, {}, keys_default(filterable)) : (\n    // else\n    _filter(pred, filterable)\n  );\n}));\nvar filter_default = filter;\n\n// node_modules/ramda/es/reject.js\nvar reject = /* @__PURE__ */ _curry2(function reject2(pred, filterable) {\n  return filter_default(_complement(pred), filterable);\n});\nvar reject_default = reject;\n\n// node_modules/ramda/es/internal/_toString.js\nfunction _toString(x3, seen) {\n  var recur = function recur2(y2) {\n    var xs2 = seen.concat([x3]);\n    return _includes(y2, xs2) ? \"<Circular>\" : _toString(y2, xs2);\n  };\n  var mapPairs = function(obj, keys4) {\n    return _map(function(k2) {\n      return _quote(k2) + \": \" + recur(obj[k2]);\n    }, keys4.slice().sort());\n  };\n  switch (Object.prototype.toString.call(x3)) {\n    case \"[object Arguments]\":\n      return \"(function() { return arguments; }(\" + _map(recur, x3).join(\", \") + \"))\";\n    case \"[object Array]\":\n      return \"[\" + _map(recur, x3).concat(mapPairs(x3, reject_default(function(k2) {\n        return /^\\d+$/.test(k2);\n      }, keys_default(x3)))).join(\", \") + \"]\";\n    case \"[object Boolean]\":\n      return typeof x3 === \"object\" ? \"new Boolean(\" + recur(x3.valueOf()) + \")\" : x3.toString();\n    case \"[object Date]\":\n      return \"new Date(\" + (isNaN(x3.valueOf()) ? recur(NaN) : _quote(toISOString_default(x3))) + \")\";\n    case \"[object Map]\":\n      return \"new Map(\" + recur(Array.from(x3)) + \")\";\n    case \"[object Null]\":\n      return \"null\";\n    case \"[object Number]\":\n      return typeof x3 === \"object\" ? \"new Number(\" + recur(x3.valueOf()) + \")\" : 1 / x3 === -Infinity ? \"-0\" : x3.toString(10);\n    case \"[object Set]\":\n      return \"new Set(\" + recur(Array.from(x3).sort()) + \")\";\n    case \"[object String]\":\n      return typeof x3 === \"object\" ? \"new String(\" + recur(x3.valueOf()) + \")\" : _quote(x3);\n    case \"[object Undefined]\":\n      return \"undefined\";\n    default:\n      if (typeof x3.toString === \"function\") {\n        var repr = x3.toString();\n        if (repr !== \"[object Object]\") {\n          return repr;\n        }\n      }\n      return \"{\" + mapPairs(x3, keys_default(x3)).join(\", \") + \"}\";\n  }\n}\n\n// node_modules/ramda/es/toString.js\nvar toString2 = /* @__PURE__ */ _curry1(function toString3(val) {\n  return _toString(val, []);\n});\nvar toString_default = toString2;\n\n// node_modules/ramda/es/max.js\nvar max = /* @__PURE__ */ _curry2(function max2(a, b2) {\n  if (a === b2) {\n    return b2;\n  }\n  function safeMax(x3, y2) {\n    if (x3 > y2 !== y2 > x3) {\n      return y2 > x3 ? y2 : x3;\n    }\n    return void 0;\n  }\n  var maxByValue = safeMax(a, b2);\n  if (maxByValue !== void 0) {\n    return maxByValue;\n  }\n  var maxByType = safeMax(typeof a, typeof b2);\n  if (maxByType !== void 0) {\n    return maxByType === typeof a ? a : b2;\n  }\n  var stringA = toString_default(a);\n  var maxByStringValue = safeMax(stringA, toString_default(b2));\n  if (maxByStringValue !== void 0) {\n    return maxByStringValue === stringA ? a : b2;\n  }\n  return b2;\n});\nvar max_default = max;\n\n// node_modules/ramda/es/internal/_xmap.js\nvar XMap = /* @__PURE__ */ function() {\n  function XMap2(f2, xf) {\n    this.xf = xf;\n    this.f = f2;\n  }\n  XMap2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XMap2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XMap2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    return this.xf[\"@@transducer/step\"](result2, this.f(input));\n  };\n  return XMap2;\n}();\nvar _xmap = function _xmap2(f2) {\n  return function(xf) {\n    return new XMap(f2, xf);\n  };\n};\nvar xmap_default = _xmap;\n\n// node_modules/ramda/es/map.js\nvar map = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([\"fantasy-land/map\", \"map\"], xmap_default, function map2(fn2, functor) {\n  switch (Object.prototype.toString.call(functor)) {\n    case \"[object Function]\":\n      return curryN_default(functor.length, function() {\n        return fn2.call(this, functor.apply(this, arguments));\n      });\n    case \"[object Object]\":\n      return _arrayReduce(function(acc, key) {\n        acc[key] = fn2(functor[key]);\n        return acc;\n      }, {}, keys_default(functor));\n    default:\n      return _map(fn2, functor);\n  }\n}));\nvar map_default = map;\n\n// node_modules/ramda/es/internal/_isInteger.js\nvar isInteger_default = Number.isInteger || function _isInteger(n) {\n  return n << 0 === n;\n};\n\n// node_modules/ramda/es/internal/_isString.js\nfunction _isString(x3) {\n  return Object.prototype.toString.call(x3) === \"[object String]\";\n}\n\n// node_modules/ramda/es/internal/_nth.js\nfunction _nth(offset, list) {\n  var idx = offset < 0 ? list.length + offset : offset;\n  return _isString(list) ? list.charAt(idx) : list[idx];\n}\n\n// node_modules/ramda/es/prop.js\nvar prop = /* @__PURE__ */ _curry2(function prop2(p2, obj) {\n  if (obj == null) {\n    return;\n  }\n  return isInteger_default(p2) ? _nth(p2, obj) : obj[p2];\n});\nvar prop_default = prop;\n\n// node_modules/ramda/es/internal/_isArrayLike.js\nvar _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x3) {\n  if (isArray_default(x3)) {\n    return true;\n  }\n  if (!x3) {\n    return false;\n  }\n  if (typeof x3 !== \"object\") {\n    return false;\n  }\n  if (_isString(x3)) {\n    return false;\n  }\n  if (x3.length === 0) {\n    return true;\n  }\n  if (x3.length > 0) {\n    return x3.hasOwnProperty(0) && x3.hasOwnProperty(x3.length - 1);\n  }\n  return false;\n});\nvar isArrayLike_default = _isArrayLike;\n\n// node_modules/ramda/es/internal/_createReduce.js\nvar symIterator = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nfunction _createReduce(arrayReduce, methodReduce, iterableReduce) {\n  return function _reduce(xf, acc, list) {\n    if (isArrayLike_default(list)) {\n      return arrayReduce(xf, acc, list);\n    }\n    if (list == null) {\n      return acc;\n    }\n    if (typeof list[\"fantasy-land/reduce\"] === \"function\") {\n      return methodReduce(xf, acc, list, \"fantasy-land/reduce\");\n    }\n    if (list[symIterator] != null) {\n      return iterableReduce(xf, acc, list[symIterator]());\n    }\n    if (typeof list.next === \"function\") {\n      return iterableReduce(xf, acc, list);\n    }\n    if (typeof list.reduce === \"function\") {\n      return methodReduce(xf, acc, list, \"reduce\");\n    }\n    throw new TypeError(\"reduce: list must be array or iterable\");\n  };\n}\n\n// node_modules/ramda/es/internal/_xArrayReduce.js\nfunction _xArrayReduce(xf, acc, list) {\n  var idx = 0;\n  var len = list.length;\n  while (idx < len) {\n    acc = xf[\"@@transducer/step\"](acc, list[idx]);\n    if (acc && acc[\"@@transducer/reduced\"]) {\n      acc = acc[\"@@transducer/value\"];\n      break;\n    }\n    idx += 1;\n  }\n  return xf[\"@@transducer/result\"](acc);\n}\n\n// node_modules/ramda/es/bind.js\nvar bind = /* @__PURE__ */ _curry2(function bind2(fn2, thisObj) {\n  return _arity(fn2.length, function() {\n    return fn2.apply(thisObj, arguments);\n  });\n});\nvar bind_default = bind;\n\n// node_modules/ramda/es/internal/_xReduce.js\nfunction _xIterableReduce(xf, acc, iter) {\n  var step = iter.next();\n  while (!step.done) {\n    acc = xf[\"@@transducer/step\"](acc, step.value);\n    if (acc && acc[\"@@transducer/reduced\"]) {\n      acc = acc[\"@@transducer/value\"];\n      break;\n    }\n    step = iter.next();\n  }\n  return xf[\"@@transducer/result\"](acc);\n}\nfunction _xMethodReduce(xf, acc, obj, methodName) {\n  return xf[\"@@transducer/result\"](obj[methodName](bind_default(xf[\"@@transducer/step\"], xf), acc));\n}\nvar _xReduce = /* @__PURE__ */ _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);\nvar xReduce_default = _xReduce;\n\n// node_modules/ramda/es/internal/_xwrap.js\nvar XWrap = /* @__PURE__ */ function() {\n  function XWrap2(fn2) {\n    this.f = fn2;\n  }\n  XWrap2.prototype[\"@@transducer/init\"] = function() {\n    throw new Error(\"init not implemented on XWrap\");\n  };\n  XWrap2.prototype[\"@@transducer/result\"] = function(acc) {\n    return acc;\n  };\n  XWrap2.prototype[\"@@transducer/step\"] = function(acc, x3) {\n    return this.f(acc, x3);\n  };\n  return XWrap2;\n}();\nfunction _xwrap(fn2) {\n  return new XWrap(fn2);\n}\n\n// node_modules/ramda/es/reduce.js\nvar reduce = /* @__PURE__ */ _curry3(function(xf, acc, list) {\n  return xReduce_default(typeof xf === \"function\" ? _xwrap(xf) : xf, acc, list);\n});\nvar reduce_default = reduce;\n\n// node_modules/ramda/es/always.js\nvar always = /* @__PURE__ */ _curry1(function always2(val) {\n  return function() {\n    return val;\n  };\n});\nvar always_default = always;\n\n// node_modules/ramda/es/append.js\nvar append = /* @__PURE__ */ _curry2(function append2(el2, list) {\n  return _concat(list, [el2]);\n});\nvar append_default = append;\n\n// node_modules/ramda/es/curry.js\nvar curry = /* @__PURE__ */ _curry1(function curry2(fn2) {\n  return curryN_default(fn2.length, fn2);\n});\nvar curry_default = curry;\n\n// node_modules/ramda/es/internal/_assoc.js\nfunction _assoc(prop3, val, obj) {\n  if (isInteger_default(prop3) && isArray_default(obj)) {\n    var arr = [].concat(obj);\n    arr[prop3] = val;\n    return arr;\n  }\n  var result2 = {};\n  for (var p2 in obj) {\n    result2[p2] = obj[p2];\n  }\n  result2[prop3] = val;\n  return result2;\n}\n\n// node_modules/ramda/es/isNil.js\nvar isNil = /* @__PURE__ */ _curry1(function isNil2(x3) {\n  return x3 == null;\n});\nvar isNil_default = isNil;\n\n// node_modules/ramda/es/assocPath.js\nvar assocPath = /* @__PURE__ */ _curry3(function assocPath2(path2, val, obj) {\n  if (path2.length === 0) {\n    return val;\n  }\n  var idx = path2[0];\n  if (path2.length > 1) {\n    var nextObj = !isNil_default(obj) && _has(idx, obj) && typeof obj[idx] === \"object\" ? obj[idx] : isInteger_default(path2[1]) ? [] : {};\n    val = assocPath2(Array.prototype.slice.call(path2, 1), val, nextObj);\n  }\n  return _assoc(idx, val, obj);\n});\nvar assocPath_default = assocPath;\n\n// node_modules/ramda/es/assoc.js\nvar assoc = /* @__PURE__ */ _curry3(function assoc2(prop3, val, obj) {\n  return assocPath_default([prop3], val, obj);\n});\nvar assoc_default = assoc;\n\n// node_modules/ramda/es/internal/_isFunction.js\nfunction _isFunction(x3) {\n  var type3 = Object.prototype.toString.call(x3);\n  return type3 === \"[object Function]\" || type3 === \"[object AsyncFunction]\" || type3 === \"[object GeneratorFunction]\" || type3 === \"[object AsyncGeneratorFunction]\";\n}\n\n// node_modules/ramda/es/internal/_makeFlat.js\nfunction _makeFlat(recursive) {\n  return function flatt(list) {\n    var value, jlen, j2;\n    var result2 = [];\n    var idx = 0;\n    var ilen = list.length;\n    while (idx < ilen) {\n      if (isArrayLike_default(list[idx])) {\n        value = recursive ? flatt(list[idx]) : list[idx];\n        j2 = 0;\n        jlen = value.length;\n        while (j2 < jlen) {\n          result2[result2.length] = value[j2];\n          j2 += 1;\n        }\n      } else {\n        result2[result2.length] = list[idx];\n      }\n      idx += 1;\n    }\n    return result2;\n  };\n}\n\n// node_modules/ramda/es/internal/_forceReduced.js\nfunction _forceReduced(x3) {\n  return {\n    \"@@transducer/value\": x3,\n    \"@@transducer/reduced\": true\n  };\n}\n\n// node_modules/ramda/es/internal/_flatCat.js\nvar tInit = \"@@transducer/init\";\nvar tStep = \"@@transducer/step\";\nvar tResult = \"@@transducer/result\";\nvar XPreservingReduced = /* @__PURE__ */ function() {\n  function XPreservingReduced2(xf) {\n    this.xf = xf;\n  }\n  XPreservingReduced2.prototype[tInit] = xfBase_default.init;\n  XPreservingReduced2.prototype[tResult] = xfBase_default.result;\n  XPreservingReduced2.prototype[tStep] = function(result2, input) {\n    var ret = this.xf[tStep](result2, input);\n    return ret[\"@@transducer/reduced\"] ? _forceReduced(ret) : ret;\n  };\n  return XPreservingReduced2;\n}();\nvar XFlatCat = /* @__PURE__ */ function() {\n  function XFlatCat2(xf) {\n    this.xf = new XPreservingReduced(xf);\n  }\n  XFlatCat2.prototype[tInit] = xfBase_default.init;\n  XFlatCat2.prototype[tResult] = xfBase_default.result;\n  XFlatCat2.prototype[tStep] = function(result2, input) {\n    return !isArrayLike_default(input) ? _xArrayReduce(this.xf, result2, [input]) : xReduce_default(this.xf, result2, input);\n  };\n  return XFlatCat2;\n}();\nvar _flatCat = function _xcat(xf) {\n  return new XFlatCat(xf);\n};\nvar flatCat_default = _flatCat;\n\n// node_modules/ramda/es/internal/_xchain.js\nfunction _xchain(f2) {\n  return function(xf) {\n    return xmap_default(f2)(flatCat_default(xf));\n  };\n}\n\n// node_modules/ramda/es/chain.js\nvar chain = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([\"fantasy-land/chain\", \"chain\"], _xchain, function chain2(fn2, monad) {\n  if (typeof monad === \"function\") {\n    return function(x3) {\n      return fn2(monad(x3))(x3);\n    };\n  }\n  return _makeFlat(false)(map_default(fn2, monad));\n}));\nvar chain_default = chain;\n\n// node_modules/ramda/es/internal/_pipe.js\nfunction _pipe(f2, g2) {\n  return function() {\n    return g2.call(this, f2.apply(this, arguments));\n  };\n}\n\n// node_modules/ramda/es/internal/_checkForMethod.js\nfunction _checkForMethod(methodname, fn2) {\n  return function() {\n    var length = arguments.length;\n    if (length === 0) {\n      return fn2();\n    }\n    var obj = arguments[length - 1];\n    return isArray_default(obj) || typeof obj[methodname] !== \"function\" ? fn2.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));\n  };\n}\n\n// node_modules/ramda/es/slice.js\nvar slice = /* @__PURE__ */ _curry3(/* @__PURE__ */ _checkForMethod(\"slice\", function slice2(fromIndex, toIndex, list) {\n  return Array.prototype.slice.call(list, fromIndex, toIndex);\n}));\nvar slice_default = slice;\n\n// node_modules/ramda/es/tail.js\nvar tail = /* @__PURE__ */ _curry1(/* @__PURE__ */ _checkForMethod(\"tail\", /* @__PURE__ */ slice_default(1, Infinity)));\nvar tail_default = tail;\n\n// node_modules/ramda/es/pipe.js\nfunction pipe() {\n  if (arguments.length === 0) {\n    throw new Error(\"pipe requires at least one argument\");\n  }\n  return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));\n}\n\n// node_modules/ramda/es/internal/_identity.js\nfunction _identity(x3) {\n  return x3;\n}\n\n// node_modules/ramda/es/identity.js\nvar identity = /* @__PURE__ */ _curry1(_identity);\nvar identity_default = identity;\n\n// node_modules/ramda/es/concat.js\nvar concat = /* @__PURE__ */ _curry2(function concat2(a, b2) {\n  if (isArray_default(a)) {\n    if (isArray_default(b2)) {\n      return a.concat(b2);\n    }\n    throw new TypeError(toString_default(b2) + \" is not an array\");\n  }\n  if (_isString(a)) {\n    if (_isString(b2)) {\n      return a + b2;\n    }\n    throw new TypeError(toString_default(b2) + \" is not a string\");\n  }\n  if (a != null && _isFunction(a[\"fantasy-land/concat\"])) {\n    return a[\"fantasy-land/concat\"](b2);\n  }\n  if (a != null && _isFunction(a.concat)) {\n    return a.concat(b2);\n  }\n  throw new TypeError(toString_default(a) + ' does not have a method named \"concat\" or \"fantasy-land/concat\"');\n});\nvar concat_default = concat;\n\n// node_modules/ramda/es/cond.js\nvar cond = /* @__PURE__ */ _curry1(function cond2(pairs) {\n  var arity = reduce_default(max_default, 0, map_default(function(pair) {\n    return pair[0].length;\n  }, pairs));\n  return _arity(arity, function() {\n    var idx = 0;\n    while (idx < pairs.length) {\n      if (pairs[idx][0].apply(this, arguments)) {\n        return pairs[idx][1].apply(this, arguments);\n      }\n      idx += 1;\n    }\n  });\n});\nvar cond_default = cond;\n\n// node_modules/ramda/es/defaultTo.js\nvar defaultTo = /* @__PURE__ */ _curry2(function defaultTo2(d2, v2) {\n  return v2 == null || v2 !== v2 ? d2 : v2;\n});\nvar defaultTo_default = defaultTo;\n\n// node_modules/ramda/es/hasPath.js\nvar hasPath = /* @__PURE__ */ _curry2(function hasPath2(_path2, obj) {\n  if (_path2.length === 0 || isNil_default(obj)) {\n    return false;\n  }\n  var val = obj;\n  var idx = 0;\n  while (idx < _path2.length) {\n    if (!isNil_default(val) && _has(_path2[idx], val)) {\n      val = val[_path2[idx]];\n      idx += 1;\n    } else {\n      return false;\n    }\n  }\n  return true;\n});\nvar hasPath_default = hasPath;\n\n// node_modules/ramda/es/has.js\nvar has = /* @__PURE__ */ _curry2(function has2(prop3, obj) {\n  return hasPath_default([prop3], obj);\n});\nvar has_default = has;\n\n// node_modules/ramda/es/ifElse.js\nvar ifElse = /* @__PURE__ */ _curry3(function ifElse2(condition, onTrue, onFalse) {\n  return curryN_default(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {\n    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);\n  });\n});\nvar ifElse_default = ifElse;\n\n// node_modules/ramda/es/includes.js\nvar includes = /* @__PURE__ */ _curry2(_includes);\nvar includes_default = includes;\n\n// node_modules/ramda/es/invoker.js\nvar invoker = /* @__PURE__ */ _curry2(function invoker2(arity, method) {\n  return curryN_default(arity + 1, function() {\n    var target = arguments[arity];\n    if (target != null && _isFunction(target[method])) {\n      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));\n    }\n    throw new TypeError(toString_default(target) + ' does not have a method named \"' + method + '\"');\n  });\n});\nvar invoker_default = invoker;\n\n// node_modules/ramda/es/is.js\nvar is2 = /* @__PURE__ */ _curry2(function is3(Ctor, val) {\n  return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === \"Object\" && typeof val === \"object\");\n});\nvar is_default = is2;\n\n// node_modules/ramda/es/isNotNil.js\nvar isNotNil = /* @__PURE__ */ _curry1(function isNotNil2(x3) {\n  return !isNil_default(x3);\n});\nvar isNotNil_default = isNotNil;\n\n// node_modules/ramda/es/join.js\nvar join = /* @__PURE__ */ invoker_default(1, \"join\");\nvar join_default = join;\n\n// node_modules/ramda/es/internal/_path.js\nfunction _path(pathAr, obj) {\n  var val = obj;\n  for (var i = 0; i < pathAr.length; i += 1) {\n    if (val == null) {\n      return void 0;\n    }\n    var p2 = pathAr[i];\n    if (isInteger_default(p2)) {\n      val = _nth(p2, val);\n    } else {\n      val = val[p2];\n    }\n  }\n  return val;\n}\n\n// node_modules/ramda/es/path.js\nvar path = /* @__PURE__ */ _curry2(_path);\nvar path_default = path;\n\n// node_modules/ramda/es/propOr.js\nvar propOr = /* @__PURE__ */ _curry3(function propOr2(val, p2, obj) {\n  return defaultTo_default(val, prop_default(p2, obj));\n});\nvar propOr_default = propOr;\n\n// node_modules/ramda/es/internal/_xtap.js\nvar XTap = /* @__PURE__ */ function() {\n  function XTap2(f2, xf) {\n    this.xf = xf;\n    this.f = f2;\n  }\n  XTap2.prototype[\"@@transducer/init\"] = xfBase_default.init;\n  XTap2.prototype[\"@@transducer/result\"] = xfBase_default.result;\n  XTap2.prototype[\"@@transducer/step\"] = function(result2, input) {\n    this.f(input);\n    return this.xf[\"@@transducer/step\"](result2, input);\n  };\n  return XTap2;\n}();\nfunction _xtap(f2) {\n  return function(xf) {\n    return new XTap(f2, xf);\n  };\n}\n\n// node_modules/ramda/es/tap.js\nvar tap = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xtap, function tap2(fn2, x3) {\n  fn2(x3);\n  return x3;\n}));\nvar tap_default = tap;\n\n// node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n  util2.assertEqual = (val) => val;\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== \"number\");\n    const filtered = {};\n    for (const k2 of validKeys) {\n      filtered[k2] = obj[k2];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\n    const keys4 = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys4.push(key);\n      }\n    }\n    return keys4;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_3, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n      // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class _ZodError extends Error {\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  get errors() {\n    return this.issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el2 = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el2] = curr[el2] || { _errors: [] };\n            } else {\n              curr[el2] = curr[el2] || { _errors: [] };\n              curr[el2]._errors.push(mapper(issue));\n            }\n            curr = curr[el2];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof _ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\nvar errorMap = (issue, _ctx) => {\n  let message2;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message2 = \"Required\";\n      } else {\n        message2 = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message2 = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message2 = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message2 = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message2 = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message2 = `Invalid input: must include \"${issue.validation.includes}\"`;\n          if (typeof issue.validation.position === \"number\") {\n            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message2 = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message2 = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message2 = `Invalid ${issue.validation}`;\n      } else {\n        message2 = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message2 = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message2 = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n      else\n        message2 = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n      else\n        message2 = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message2 = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message2 = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message2 = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message2 = \"Number must be finite\";\n      break;\n    default:\n      message2 = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message: message2 };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map3) {\n  overrideErrorMap = map3;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params) => {\n  const { data, path: path2, errorMaps, issueData } = params;\n  const fullPath = [...path2, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== void 0) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();\n  for (const map3 of maps) {\n    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      overrideMap,\n      overrideMap === errorMap ? void 0 : errorMap\n      // then global default map\n    ].filter((x3) => !!x3)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results2) {\n    const arrayValue = [];\n    for (const s of results2) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x3) => x3.status === \"aborted\";\nvar isDirty = (x3) => x3.status === \"dirty\";\nvar isValid = (x3) => x3.status === \"valid\";\nvar isAsync = (x3) => typeof Promise !== \"undefined\" && x3 instanceof Promise;\nfunction __classPrivateFieldGet(receiver, state, kind, f2) {\n  if (kind === \"a\" && !f2) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f2 : kind === \"a\" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f2) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f2) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;\n}\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message2) => typeof message2 === \"string\" ? { message: message2 } : message2 || {};\n  errorUtil2.toString = (message2) => typeof message2 === \"string\" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache;\nvar _ZodNativeEnum_cache;\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path2, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path2;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (this._key instanceof Array) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n};\nvar handleResult = (ctx, result2) => {\n  if (isValid(result2)) {\n    return { success: true, data: result2.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error = new ZodError(ctx.common.issues);\n        this._error = error;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    var _a, _b;\n    const { message: message2 } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n  }\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result2 = this._parse(input);\n    if (isAsync(result2)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result2;\n  }\n  _parseAsync(input) {\n    const result2 = this._parse(input);\n    return Promise.resolve(result2);\n  }\n  parse(data, params) {\n    const result2 = this.safeParse(data, params);\n    if (result2.success)\n      return result2.data;\n    throw result2.error;\n  }\n  safeParse(data, params) {\n    var _a;\n    const ctx = {\n      common: {\n        issues: [],\n        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result2);\n  }\n  async parseAsync(data, params) {\n    const result2 = await this.safeParseAsync(data, params);\n    if (result2.success)\n      return result2.data;\n    throw result2.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n        async: true\n      },\n      path: (params === null || params === void 0 ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result2);\n  }\n  refine(check, message2) {\n    const getIssueProperties = (val) => {\n      if (typeof message2 === \"string\" || typeof message2 === \"undefined\") {\n        return { message: message2 };\n      } else if (typeof message2 === \"function\") {\n        return message2(val);\n      } else {\n        return message2;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result2 = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result2 instanceof Promise) {\n        return result2.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result2) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this, this._def);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n  if (args.precision) {\n    regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    regex = `${regex}(\\\\.\\\\d+)?`;\n  }\n  return regex;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch (_a) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!input.data.includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message2) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  _addCheck(check) {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message2) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message2) });\n  }\n  url(message2) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message2) });\n  }\n  emoji(message2) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message2) });\n  }\n  uuid(message2) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message2) });\n  }\n  nanoid(message2) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message2) });\n  }\n  cuid(message2) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message2) });\n  }\n  cuid2(message2) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message2) });\n  }\n  ulid(message2) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message2) });\n  }\n  base64(message2) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message2) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    var _a, _b;\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  date(message2) {\n    return this._addCheck({ kind: \"date\", message: message2 });\n  }\n  time(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  duration(message2) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message2) });\n  }\n  regex(regex, message2) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options === null || options === void 0 ? void 0 : options.position,\n      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n    });\n  }\n  startsWith(value, message2) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  endsWith(value, message2) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  min(minLength, message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  max(maxLength, message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  length(len, message2) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message2)\n    });\n  }\n  /**\n   * @deprecated Use z.string().min(1) instead.\n   * @see {@link ZodString.min}\n   */\n  nonempty(message2) {\n    return this.min(1, errorUtil.errToObj(message2));\n  }\n  trim() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n};\nZodString.create = (params) => {\n  var _a;\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message2) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message2));\n  }\n  gt(value, message2) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message2));\n  }\n  lte(value, message2) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message2));\n  }\n  lt(value, message2) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message2));\n  }\n  setLimit(kind, value, inclusive, message2) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message2)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message2) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message2)\n    });\n  }\n  positive(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  negative(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonpositive(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonnegative(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  multipleOf(value, message2) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message2)\n    });\n  }\n  finite(message2) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message2)\n    });\n  }\n  safe(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message2)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max3 = null, min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max3);\n  }\n};\nZodNumber.create = (params) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = BigInt(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.bigint,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message2) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message2));\n  }\n  gt(value, message2) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message2));\n  }\n  lte(value, message2) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message2));\n  }\n  lt(value, message2) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message2));\n  }\n  setLimit(kind, value, inclusive, message2) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message2)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  negative(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonpositive(message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  nonnegative(message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message2)\n    });\n  }\n  multipleOf(value, message2) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3;\n  }\n};\nZodBigInt.create = (params) => {\n  var _a;\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message2) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message2)\n    });\n  }\n  max(maxDate, message2) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message2)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max3 = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max3 === null || ch.value < max3)\n          max3 = ch.value;\n      }\n    }\n    return max3 != null ? new Date(max3) : null;\n  }\n};\nZodDate.create = (params) => {\n  return new ZodDate({\n    checks: [],\n    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = (params) => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : void 0,\n          maximum: tooBig ? def.exactLength.value : void 0,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result3) => {\n        return ParseStatus.mergeArray(status, result3);\n      });\n    }\n    const result2 = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result2);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message2) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message2) }\n    });\n  }\n  max(maxLength, message2) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message2) }\n    });\n  }\n  length(len, message2) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message2) }\n    });\n  }\n  nonempty(message2) {\n    return this.min(1, message2);\n  }\n};\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys4 = util.objectKeys(shape);\n    return this._cached = { shape, keys: keys4 };\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") ;\n      else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message2) {\n    errorUtil.errToObj;\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message2 !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b, _c, _d;\n          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    const merged = new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    util.objectKeys(mask).forEach((key) => {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    util.objectKeys(this.shape).forEach((key) => {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    });\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results2) {\n      for (const result2 of results2) {\n        if (result2.result.status === \"valid\") {\n          return result2.result;\n        }\n      }\n      for (const result2 of results2) {\n        if (result2.result.status === \"dirty\") {\n          ctx.common.issues.push(...result2.ctx.common.issues);\n          return result2.result;\n        }\n      }\n      const unionErrors = results2.map((result2) => new ZodError(result2.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result2 = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result2.status === \"valid\") {\n          return result2;\n        } else if (result2.status === \"dirty\" && !dirty) {\n          dirty = { result: result2, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type3) => {\n  if (type3 instanceof ZodLazy) {\n    return getDiscriminator(type3.schema);\n  } else if (type3 instanceof ZodEffects) {\n    return getDiscriminator(type3.innerType());\n  } else if (type3 instanceof ZodLiteral) {\n    return [type3.value];\n  } else if (type3 instanceof ZodEnum) {\n    return type3.options;\n  } else if (type3 instanceof ZodNativeEnum) {\n    return util.objectValues(type3.enum);\n  } else if (type3 instanceof ZodDefault) {\n    return getDiscriminator(type3._def.innerType);\n  } else if (type3 instanceof ZodUndefined) {\n    return [void 0];\n  } else if (type3 instanceof ZodNull) {\n    return [null];\n  } else if (type3 instanceof ZodOptional) {\n    return [void 0, ...getDiscriminator(type3.unwrap())];\n  } else if (type3 instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type3.unwrap())];\n  } else if (type3 instanceof ZodBranded) {\n    return getDiscriminator(type3.unwrap());\n  } else if (type3 instanceof ZodReadonly) {\n    return getDiscriminator(type3.unwrap());\n  } else if (type3 instanceof ZodCatch) {\n    return getDiscriminator(type3._def.innerType);\n  } else {\n    return [];\n  }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */ new Map();\n    for (const type3 of options) {\n      const discriminatorValues = getDiscriminator(type3.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type3);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b2) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b2);\n  if (a === b2) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b2);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b2 };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b2[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b2.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b2[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x3) => !!x3);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results2) => {\n        return ParseStatus.mergeArray(status, results2);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new _ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message2) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message2) }\n    });\n  }\n  max(maxSize, message2) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message2) }\n    });\n  }\n  size(size, message2) {\n    return this.min(size, message2).max(size, message2);\n  }\n  nonempty(message2) {\n    return this.min(1, message2);\n  }\n};\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x3) => !!x3),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [\n          ctx.common.contextualErrorMap,\n          ctx.schemaErrorMap,\n          getErrorMap(),\n          errorMap\n        ].filter((x3) => !!x3),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn2 = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me2 = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]);\n        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result2 = await Reflect.apply(fn2, this, parsedArgs);\n        const parsedReturns = await me2._def.returns._def.type.parseAsync(result2, params).catch((e) => {\n          error.addIssue(makeReturnsIssue(result2, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me2 = this;\n      return OK(function(...args) {\n        const parsedArgs = me2._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result2 = Reflect.apply(fn2, this, parsedArgs.data);\n        const parsedReturns = me2._def.returns.safeParse(result2, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  constructor() {\n    super(...arguments);\n    _ZodEnum_cache.set(this, void 0);\n  }\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n    }\n    if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return _ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n};\n_ZodEnum_cache = /* @__PURE__ */ new WeakMap();\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    _ZodNativeEnum_cache.set(this, void 0);\n  }\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n    }\n    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\n_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === \"aborted\")\n            return INVALID;\n          const result2 = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result2.status === \"aborted\")\n            return INVALID;\n          if (result2.status === \"dirty\")\n            return DIRTY(result2.value);\n          if (status.value === \"dirty\")\n            return DIRTY(result2.value);\n          return result2;\n        });\n      } else {\n        if (status.value === \"aborted\")\n          return INVALID;\n        const result2 = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result2.status === \"aborted\")\n          return INVALID;\n        if (result2.status === \"dirty\")\n          return DIRTY(result2.value);\n        if (status.value === \"dirty\")\n          return DIRTY(result2.value);\n        return result2;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result2 = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result2);\n        }\n        if (result2 instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return base;\n        const result2 = effect.transform(base.value, checkCtx);\n        if (result2 instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result2 };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return base;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type3, params) => {\n  return new ZodOptional({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type3, params) => {\n  return new ZodNullable({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type3, params) => {\n  return new ZodDefault({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result2 = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result2)) {\n      return result2.then((result3) => {\n        return {\n          status: \"valid\",\n          value: result3.status === \"valid\" ? result3.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type3, params) => {\n  return new ZodCatch({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === \"aborted\")\n          return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === \"aborted\")\n        return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b2) {\n    return new _ZodPipeline({\n      in: a,\n      out: b2,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n};\nvar ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result2 = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result2) ? result2.then((data) => freeze(data)) : freeze(result2);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodReadonly.create = (type3, params) => {\n  return new ZodReadonly({\n    innerType: type3,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nfunction custom(check, params = {}, fatal) {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      var _a, _b;\n      if (!check(data)) {\n        const p2 = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n        const p22 = typeof p2 === \"string\" ? { message: p2 } : p2;\n        ctx.addIssue({ code: \"custom\", ...p22, fatal: _fatal });\n      }\n    });\n  return ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n  ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n  ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: true }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: true })\n};\nvar NEVER = INVALID;\nvar z2 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  defaultErrorMap: errorMap,\n  setErrorMap,\n  getErrorMap,\n  makeIssue,\n  EMPTY_PATH,\n  addIssueToContext,\n  ParseStatus,\n  INVALID,\n  DIRTY,\n  OK,\n  isAborted,\n  isDirty,\n  isValid,\n  isAsync,\n  get util() {\n    return util;\n  },\n  get objectUtil() {\n    return objectUtil;\n  },\n  ZodParsedType,\n  getParsedType,\n  ZodType,\n  datetimeRegex,\n  ZodString,\n  ZodNumber,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodSymbol,\n  ZodUndefined,\n  ZodNull,\n  ZodAny,\n  ZodUnknown,\n  ZodNever,\n  ZodVoid,\n  ZodArray,\n  ZodObject,\n  ZodUnion,\n  ZodDiscriminatedUnion,\n  ZodIntersection,\n  ZodTuple,\n  ZodRecord,\n  ZodMap,\n  ZodSet,\n  ZodFunction,\n  ZodLazy,\n  ZodLiteral,\n  ZodEnum,\n  ZodNativeEnum,\n  ZodPromise,\n  ZodEffects,\n  ZodTransformer: ZodEffects,\n  ZodOptional,\n  ZodNullable,\n  ZodDefault,\n  ZodCatch,\n  ZodNaN,\n  BRAND,\n  ZodBranded,\n  ZodPipeline,\n  ZodReadonly,\n  custom,\n  Schema: ZodType,\n  ZodSchema: ZodType,\n  late,\n  get ZodFirstPartyTypeKind() {\n    return ZodFirstPartyTypeKind;\n  },\n  coerce,\n  any: anyType,\n  array: arrayType,\n  bigint: bigIntType,\n  boolean: booleanType,\n  date: dateType,\n  discriminatedUnion: discriminatedUnionType,\n  effect: effectsType,\n  \"enum\": enumType,\n  \"function\": functionType,\n  \"instanceof\": instanceOfType,\n  intersection: intersectionType,\n  lazy: lazyType,\n  literal: literalType,\n  map: mapType,\n  nan: nanType,\n  nativeEnum: nativeEnumType,\n  never: neverType,\n  \"null\": nullType,\n  nullable: nullableType,\n  number: numberType,\n  object: objectType,\n  oboolean,\n  onumber,\n  optional: optionalType,\n  ostring,\n  pipeline: pipelineType,\n  preprocess: preprocessType,\n  promise: promiseType,\n  record: recordType,\n  set: setType,\n  strictObject: strictObjectType,\n  string: stringType,\n  symbol: symbolType,\n  transformer: effectsType,\n  tuple: tupleType,\n  \"undefined\": undefinedType,\n  union: unionType,\n  unknown: unknownType,\n  \"void\": voidType,\n  NEVER,\n  ZodIssueCode,\n  quotelessJson,\n  ZodError\n});\n\n// src/client/gateway.js\nfunction loadTransactionMetaWith({ fetch: fetch2, GRAPHQL_URL: GRAPHQL_URL2, logger }) {\n  const GET_TRANSACTIONS_QUERY = `\n    query GetTransactions ($transactionIds: [ID!]!) {\n      transactions(ids: $transactionIds) {\n        edges {\n          node {\n            owner {\n              address\n            }\n            tags {\n              name\n              value\n            }\n            block {\n              id\n              height\n              timestamp\n            }\n          }\n        }\n      }\n    }`;\n  const transactionConnectionSchema = z2.object({\n    data: z2.object({\n      transactions: z2.object({\n        edges: z2.array(z2.object({\n          node: z2.record(z2.any())\n        }))\n      })\n    })\n  });\n  return (id) => of(id).chain(fromPromise(\n    (id2) => fetch2(GRAPHQL_URL2, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        query: GET_TRANSACTIONS_QUERY,\n        variables: { transactionIds: [id2] }\n      })\n    }).then(async (res) => {\n      if (res.ok) return res.json();\n      logger('Error Encountered when querying gateway for transaction \"%s\"', id2);\n      throw new Error(`${res.status}: ${await res.text()}`);\n    }).then(transactionConnectionSchema.parse).then(path_default([\"data\", \"transactions\", \"edges\", \"0\", \"node\"]))\n  )).toPromise();\n}\n\n// src/logger.js\nvar import_debug = __toESM(require_browser(), 1);\nvar createLogger = (name = \"@permaweb/aoconnect\") => {\n  const logger = (0, import_debug.default)(name);\n  logger.child = (name2) => createLogger(`${logger.namespace}:${name2}`);\n  logger.tap = (note, ...rest) => tap_default((...args) => logger(note, ...rest, ...args));\n  return logger;\n};\n\n// src/lib/utils.js\nvar joinUrl = ({ url, path: path2 }) => {\n  if (!path2) return url;\n  if (path2.startsWith(\"/\")) return joinUrl({ url, path: path2.slice(1) });\n  url = new URL(url);\n  url.pathname += path2;\n  return url.toString();\n};\nfunction parseTags(rawTags) {\n  return pipe(\n    defaultTo_default([]),\n    reduce_default(\n      (map3, tag) => pipe(\n        // [value, value, ...] || []\n        propOr_default([], tag.name),\n        // [value]\n        append_default(tag.value),\n        // { [name]: [value, value, ...] }\n        assoc_default(tag.name, __default, map3)\n      )(map3),\n      {}\n    ),\n    /**\n    * If the field is only a singly list, then extract the one value.\n    *\n    * Otherwise, keep the value as a list.\n    */\n    map_default((values) => values.length > 1 ? values : values[0])\n  )(rawTags);\n}\nfunction eqOrIncludes(val) {\n  return cond_default([\n    [is_default(String), equals_default(val)],\n    [is_default(Array), includes_default(val)],\n    [T_default, F_default]\n  ]);\n}\nfunction errFrom(err) {\n  let e;\n  if (is_default(ZodError, err)) {\n    e = new Error(mapZodErr(err));\n    e.stack += err.stack;\n  } else if (is_default(Error, err)) {\n    e = err;\n  } else if (has_default(\"message\", err)) {\n    e = new Error(err.message);\n  } else if (is_default(String, err)) {\n    e = new Error(err);\n  } else {\n    e = new Error(\"An error occurred\");\n  }\n  return e;\n}\nfunction mapZodErr(zodErr) {\n  return pipe(\n    (zodErr2) => (\n      /**\n       * Take a ZodError and flatten it's issues into a single depth array\n       */\n      function gatherZodIssues(zodErr3, status, contextCode) {\n        return reduce_default(\n          (issues, issue) => pipe(\n            cond_default([\n              /**\n               * These issue codes indicate nested ZodErrors, so we resursively gather those\n               * See https://github.com/colinhacks/zod/blob/HEAD/ERROR_HANDLING.md#zodissuecode\n               */\n              [\n                equals_default(ZodIssueCode.invalid_arguments),\n                () => gatherZodIssues(issue.argumentsError, 422, \"Invalid Arguments\")\n              ],\n              [\n                equals_default(ZodIssueCode.invalid_return_type),\n                () => gatherZodIssues(issue.returnTypeError, 500, \"Invalid Return\")\n              ],\n              [\n                equals_default(ZodIssueCode.invalid_union),\n                // An array of ZodErrors, so map over and flatten them all\n                () => chain_default((i) => gatherZodIssues(i, 400, \"Invalid Union\"), issue.unionErrors)\n              ],\n              [T_default, () => [{ ...issue, status, contextCode }]]\n            ]),\n            concat_default(issues)\n          )(issue.code),\n          [],\n          zodErr3.issues\n        );\n      }(zodErr2, 400, \"\")\n    ),\n    /**\n     * combine all zod issues into a list of { message, status }\n     * summaries of each issue\n     */\n    (zodIssues) => reduce_default(\n      (acc, zodIssue) => {\n        const { message: message2, path: _path2, contextCode: _contextCode } = zodIssue;\n        const path2 = _path2[1] || _path2[0];\n        const contextCode = _contextCode ? `${_contextCode} ` : \"\";\n        acc.push(`${contextCode}'${path2}': ${message2}.`);\n        return acc;\n      },\n      [],\n      zodIssues\n    ),\n    join_default(\" | \")\n  )(zodErr);\n}\n\n// src/lib/result/verify-input.js\nvar inputSchema = z2.object({\n  id: z2.string().min(1, { message: \"message is required to be a message id\" }),\n  processId: z2.string().min(1, { message: \"process is required to be a process id\" })\n});\nfunction verifyInputWith() {\n  return (ctx) => {\n    return of(ctx).map(inputSchema.parse).map(() => ctx);\n  };\n}\n\n// src/dal.js\nvar tagSchema = z2.object({\n  name: z2.string(),\n  value: z2.string()\n});\nvar dryrunResultSchema = z2.function().args(z2.object({\n  Id: z2.string(),\n  Target: z2.string(),\n  Owner: z2.string(),\n  Anchor: z2.string().optional(),\n  Data: z2.any().default(\"1234\"),\n  Tags: z2.array(z2.object({ name: z2.string(), value: z2.string() }))\n})).returns(z2.promise(z2.any()));\nvar loadResultSchema = z2.function().args(z2.object({\n  id: z2.string().min(1, { message: \"message id is required\" }),\n  processId: z2.string().min(1, { message: \"process id is required\" })\n})).returns(z2.promise(z2.any()));\nvar queryResultsSchema = z2.function().args(z2.object({\n  process: z2.string().min(1, { message: \"process id is required\" }),\n  from: z2.string().optional(),\n  to: z2.string().optional(),\n  sort: z2.enum([\"ASC\", \"DESC\"]).default(\"ASC\"),\n  limit: z2.number().optional()\n})).returns(z2.promise(z2.object({\n  edges: z2.array(z2.object({\n    cursor: z2.string(),\n    node: z2.object({\n      Output: z2.any().optional(),\n      Messages: z2.array(z2.any()).optional(),\n      Spawns: z2.array(z2.any()).optional(),\n      Error: z2.any().optional()\n    })\n  }))\n})));\nvar deployMessageSchema = z2.function().args(z2.object({\n  processId: z2.string(),\n  data: z2.any(),\n  tags: z2.array(tagSchema),\n  anchor: z2.string().optional(),\n  signer: z2.any()\n})).returns(z2.promise(\n  z2.object({\n    messageId: z2.string()\n  }).passthrough()\n));\nvar deployProcessSchema = z2.function().args(z2.object({\n  data: z2.any(),\n  tags: z2.array(tagSchema),\n  signer: z2.any()\n})).returns(z2.promise(\n  z2.object({\n    processId: z2.string()\n  }).passthrough()\n));\nvar deployAssignSchema = z2.function().args(z2.object({\n  process: z2.string(),\n  message: z2.string(),\n  baseLayer: z2.boolean().optional(),\n  exclude: z2.array(z2.string()).optional()\n})).returns(z2.promise(\n  z2.object({\n    assignmentId: z2.string()\n  }).passthrough()\n));\nvar deployMonitorSchema = deployMessageSchema;\nvar loadProcessMetaSchema = z2.function().args(z2.object({\n  suUrl: z2.string().url(),\n  processId: z2.string()\n})).returns(z2.promise(\n  z2.object({\n    tags: z2.array(tagSchema)\n  }).passthrough()\n));\nvar locateSchedulerSchema = z2.function().args(z2.string()).returns(z2.promise(\n  z2.object({\n    url: z2.string()\n  })\n));\nvar validateSchedulerSchema = z2.function().args(z2.string()).returns(z2.promise(z2.boolean()));\nvar loadTransactionMetaSchema = z2.function().args(z2.string()).returns(z2.promise(\n  z2.object({\n    tags: z2.array(tagSchema)\n  }).passthrough()\n));\nvar signerSchema = z2.function().args(z2.object({\n  data: z2.any(),\n  tags: z2.array(tagSchema),\n  /**\n   * target must be set with writeMessage,\n   * but not for createProcess\n   */\n  target: z2.string().optional(),\n  anchor: z2.string().optional()\n})).returns(z2.promise(\n  z2.object({\n    id: z2.string(),\n    raw: z2.any()\n  })\n));\n\n// src/lib/result/read.js\nfunction readWith({ loadResult }) {\n  loadResult = fromPromise(loadResultSchema.implement(loadResult));\n  return (ctx) => {\n    return of({ id: ctx.id, processId: ctx.processId }).chain(loadResult);\n  };\n}\n\n// src/lib/result/index.js\nfunction resultWith(env) {\n  const verifyInput = verifyInputWith(env);\n  const read = readWith(env);\n  return ({ message: message2, process: process2 }) => {\n    return of({ id: message2, processId: process2 }).chain(verifyInput).chain(read).map(\n      env.logger.tap(\n        'readResult result for message \"%s\": %O',\n        message2\n      )\n    ).map((result2) => result2).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// node_modules/@permaweb/protocol-tag-utils/dist/index.js\nvar pipe2 = (...fns) => (i) => fns.reduce((acc, fn2) => fn2(acc), i);\nvar defaultTo3 = (dVal) => (val) => val == null ? dVal : val;\nvar propOr3 = (defaultV) => (prop3) => pipe2(\n  (obj) => obj ? obj[prop3] : obj,\n  defaultTo3(defaultV)\n);\nvar mapObject = (fn2) => (obj) => {\n  const res = {};\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) res[key] = fn2(obj[key], key, obj);\n  }\n  return res;\n};\nvar complement = (fn2) => (...args) => !fn2(...args);\nvar findProtocolBoundaries = (protocol) => (tags) => {\n  const startIdx = tags.findIndex((t) => t.name === \"Data-Protocol\" && t.value === protocol);\n  if (startIdx === -1) return [0, 0];\n  let endIdx = tags.findIndex((t, idx) => idx > startIdx && t.name === \"Data-Protocol\" && t.value !== protocol);\n  if (endIdx === -1) endIdx = tags.length;\n  return [startIdx, endIdx];\n};\nvar findFirstProtocolBoundary = (tags) => {\n  let idx = tags.findIndex((t) => t.name === \"Data-Protocol\");\n  if (idx === -1) idx = tags.length;\n  return idx;\n};\nvar byName = (name) => (t) => t.name === name;\nvar findAll = (protocol, tags) => pipe2(\n  findProtocolBoundaries(protocol),\n  ([start, end]) => tags.slice(start, end)\n)(tags);\nvar findAllByName = (protocol, name, tags) => pipe2(\n  (tags2) => findAll(protocol, tags2),\n  (pTags) => pTags.filter(byName(name))\n)(tags);\nvar findByName = (protocol, name, tags) => pipe2(\n  (tags2) => findAllByName(protocol, name, tags2),\n  (arr) => arr[0]\n)(tags);\nvar create = (protocol, pTags) => {\n  pTags = pTags.filter((t) => t.name !== \"Data-Protocol\" || t.value !== protocol);\n  if (!pTags.length) return [];\n  return [\n    { name: \"Data-Protocol\", value: protocol },\n    ...pTags\n  ];\n};\nvar concat3 = (protocol, pTags, tags) => {\n  const [start, end] = findProtocolBoundaries(protocol)(tags);\n  let [before, cur, after] = [\n    tags.slice(0, start),\n    tags.slice(start, end),\n    tags.slice(end)\n  ];\n  if (!cur.length) {\n    pTags = create(protocol, pTags);\n    before = after;\n    after = [];\n  }\n  return [before, cur, pTags, after].flat(1);\n};\nvar concatUnassoc = (others, tags) => {\n  const idx = findFirstProtocolBoundary(tags);\n  const [before, after] = [tags.slice(0, idx), tags.slice(idx)];\n  return [before, others, after].flat(1);\n};\nvar update = (protocol, pTags, tags) => {\n  const [start, end] = findProtocolBoundaries(protocol)(tags);\n  let [before, after] = [tags.slice(0, start), tags.slice(end)];\n  if (after.length === tags.length) {\n    before = after;\n    after = [];\n  }\n  return [before, create(protocol, pTags), after].flat(1);\n};\nvar removeAll = (protocol, tags) => update(protocol, [], tags);\nvar removeAllByName = (protocol, name, tags) => {\n  const [start, end] = findProtocolBoundaries(protocol)(tags);\n  const [before, cur, after] = [tags.slice(0, start), tags.slice(start, end), tags.slice(end)];\n  return [before, create(protocol, cur.filter(complement(byName(name)))), after].flat(1);\n};\nvar parseTags2 = (tags, multi = false) => pipe2(\n  defaultTo3([]),\n  /**\n   * Mutation is okay here, since it's\n   * an internal data structure\n   */\n  (tags2) => tags2.reduce(\n    (parsed, tag) => pipe2(\n      // [value, value, ...] || []\n      propOr3([])(tag.name),\n      // [value]\n      (arr) => {\n        arr.push(tag.value);\n        return arr;\n      },\n      // { [name]: [value, value, ...] }\n      (arr) => {\n        parsed[tag.name] = arr;\n        return parsed;\n      }\n    )(parsed),\n    {}\n  ),\n  mapObject((values) => multi ? values : values[0])\n)(tags);\nvar parseProtocol = (protocol, tags, multi) => pipe2(\n  defaultTo3([]),\n  (tags2) => findAll(protocol, tags2),\n  (tags2) => parseTags2(tags2, multi)\n)(tags);\nvar parseAll = (protocol, tags) => parseProtocol(protocol, tags, true);\nvar parse = (protocol, tags) => parseProtocol(protocol, tags, false);\nvar parseUnassoc = (tags) => {\n  const idx = findFirstProtocolBoundary(tags);\n  return parseTags2(tags.slice(0, idx), false);\n};\nvar parseAllUnassoc = (tags) => {\n  const idx = findFirstProtocolBoundary(tags);\n  return parseTags2(tags.slice(0, idx), true);\n};\nvar proto = (p2) => ({\n  /**\n   * @type {import('./types').RemoveFirstArg<findAll>}\n   */\n  findAll: (tags) => findAll(p2, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<findAllByName>}\n   */\n  findAllByName: (name, tags) => findAllByName(p2, name, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<findByName>}\n   */\n  findByName: (name, tags) => findByName(p2, name, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<create>}\n   */\n  create: (tags) => create(p2, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<update>}\n   */\n  update: (pTags, tags) => update(p2, pTags, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<concat>}\n   */\n  concat: (pTags, tags) => concat3(p2, pTags, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<removeAll>}\n   */\n  removeAll: (tags) => removeAll(p2, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<removeAllByName>}\n   */\n  removeAllByName: (name, tags) => removeAllByName(p2, name, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<parse>}\n   */\n  parse: (tags) => parse(p2, tags),\n  /**\n   * @type {import('./types').RemoveFirstArg<parseAll>}\n   */\n  parseAll: (tags) => parseAll(p2, tags),\n  concatUnassoc,\n  parseUnassoc,\n  parseAllUnassoc\n});\n\n// src/lib/message/upload-message.js\nvar aoProto = proto(\"ao\");\nvar removeAoProtoByName = curry_default(aoProto.removeAllByName);\nvar concatAoProto = curry_default(aoProto.concat);\nvar concatUnassoc2 = curry_default(aoProto.concatUnassoc);\nvar tagSchema2 = z2.array(z2.object({\n  name: z2.string(),\n  value: z2.string()\n}));\nfunction buildTagsWith() {\n  return (ctx) => {\n    return of(ctx.tags).map(defaultTo_default([])).map(removeAoProtoByName(\"Variant\")).map(removeAoProtoByName(\"Type\")).map(concatAoProto([\n      { name: \"Variant\", value: \"ao.TN.1\" },\n      { name: \"Type\", value: \"Message\" }\n    ])).map(tagSchema2.parse).map(assoc_default(\"tags\", __default, ctx));\n  };\n}\nfunction buildDataWith({ logger }) {\n  return (ctx) => {\n    return of(ctx).chain(ifElse_default(\n      always_default(ctx.data),\n      /**\n       * data is provided as input, so do nothing\n       */\n      () => Resolved(ctx),\n      /**\n       * No data is provided, so replace with one space\n       */\n      () => Resolved(\" \").map(assoc_default(\"data\", __default, ctx)).map(\n        (ctx2) => pipe(\n          prop_default(\"tags\"),\n          concatUnassoc2([{ name: \"Content-Type\", value: \"text/plain\" }]),\n          assoc_default(\"tags\", __default, ctx2)\n        )(ctx2)\n      ).map(logger.tap('added pseudo-random string as message \"data\"'))\n    )).map(\n      (ctx2) => pipe(\n        prop_default(\"tags\"),\n        concatUnassoc2([{ name: \"SDK\", value: \"aoconnect\" }]),\n        assoc_default(\"tags\", __default, ctx2)\n      )(ctx2)\n    );\n  };\n}\nfunction uploadMessageWith(env) {\n  const buildTags = buildTagsWith(env);\n  const buildData = buildDataWith(env);\n  const deployMessage = deployMessageSchema.implement(env.deployMessage);\n  return (ctx) => {\n    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(\n      ({ id, data, tags, anchor, signer }) => deployMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer) })\n    )).map((res) => assoc_default(\"messageId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/message/index.js\nfunction messageWith(env) {\n  const uploadMessage = uploadMessageWith(env);\n  return ({ process: process2, data, tags, anchor, signer }) => {\n    return of({ id: process2, data, tags, anchor, signer }).chain(uploadMessage).map((ctx) => ctx.messageId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/spawn/verify-inputs.js\nvar checkTag = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);\nfunction verifyModuleWith({ loadTransactionMeta, logger }) {\n  loadTransactionMeta = fromPromise(loadTransactionMetaSchema.implement(loadTransactionMeta));\n  return (module) => of(module).chain(loadTransactionMeta).map(prop_default(\"tags\")).map(parseTags).chain(checkTag(\"Data-Protocol\", eqOrIncludes(\"ao\"), \"value 'ao' was not found on module\")).chain(checkTag(\"Type\", eqOrIncludes(\"Module\"), \"value 'Module' was not found on module\")).chain(checkTag(\"Module-Format\", isNotNil_default, \"was not found on module\")).chain(checkTag(\"Input-Encoding\", isNotNil_default, \"was not found on module\")).chain(checkTag(\"Output-Encoding\", isNotNil_default, \"was not found on module\")).bimap(\n    logger.tap(\"Verifying module source failed: %s\"),\n    logger.tap(\"Verified module source\")\n  );\n}\nfunction verifySchedulerWith({ logger, validateScheduler }) {\n  validateScheduler = fromPromise(validateSchedulerSchema.implement(validateScheduler));\n  return (scheduler) => of(scheduler).chain(\n    (scheduler2) => validateScheduler(scheduler2).chain((isValid2) => isValid2 ? Resolved(scheduler2) : Rejected(`Valid Scheduler-Location owned by ${scheduler2} not found`))\n  ).bimap(\n    logger.tap(\"Verifying scheduler failed: %s\"),\n    logger.tap(\"Verified scheduler\")\n  );\n}\nfunction verifySignerWith({ logger }) {\n  return (signer) => of(signer).map(logger.tap(\"Checking for signer\")).chain((signer2) => signer2 ? Resolved(signer2) : Rejected(\"signer not found\"));\n}\nfunction verifyInputsWith(env) {\n  const logger = env.logger.child(\"verifyInput\");\n  env = { ...env, logger };\n  const verifyModule = verifyModuleWith(env);\n  const verifyScheduler = verifySchedulerWith(env);\n  const verifySigner = verifySignerWith(env);\n  return (ctx) => {\n    return of(ctx).chain((ctx2) => verifyModule(ctx2.module).map(() => ctx2)).chain((ctx2) => verifyScheduler(ctx2.scheduler)).map(() => ctx).chain((ctx2) => verifySigner(ctx2.signer).map(() => ctx2)).bimap(\n      logger.tap(\"Error when verify input: %s\"),\n      logger.tap(\"Successfully verified inputs\")\n    );\n  };\n}\n\n// src/lib/spawn/upload-process.js\nvar aoProto2 = proto(\"ao\");\nvar removeAoProtoByName2 = curry_default(aoProto2.removeAllByName);\nvar concatAoProto2 = curry_default(aoProto2.concat);\nvar concatUnassoc3 = curry_default(aoProto2.concatUnassoc);\nvar tagSchema3 = z2.array(z2.object({\n  name: z2.string(),\n  value: z2.string()\n}));\nfunction buildTagsWith2() {\n  return (ctx) => {\n    return of(ctx).map(prop_default(\"tags\")).map(defaultTo_default([])).map(removeAoProtoByName2(\"Variant\")).map(removeAoProtoByName2(\"Type\")).map(removeAoProtoByName2(\"Module\")).map(removeAoProtoByName2(\"Scheduler\")).map(concatAoProto2([\n      { name: \"Variant\", value: \"ao.TN.1\" },\n      { name: \"Type\", value: \"Process\" },\n      { name: \"Module\", value: ctx.module },\n      { name: \"Scheduler\", value: ctx.scheduler }\n    ])).map(tagSchema3.parse).map(assoc_default(\"tags\", __default, ctx));\n  };\n}\nfunction buildDataWith2({ logger }) {\n  return (ctx) => {\n    return of(ctx).chain(ifElse_default(\n      always_default(ctx.data),\n      /**\n       * data is provided as input, so do nothing\n       */\n      () => Resolved(ctx),\n      /**\n       * No data is provided, so replace with one space\n       */\n      () => Resolved(\" \").map(assoc_default(\"data\", __default, ctx)).map(\n        (ctx2) => pipe(\n          prop_default(\"tags\"),\n          concatUnassoc3([{ name: \"Content-Type\", value: \"text/plain\" }]),\n          assoc_default(\"tags\", __default, ctx2)\n        )(ctx2)\n      ).map(logger.tap('added pseudo-random string as process \"data\"'))\n    )).map(\n      (ctx2) => pipe(\n        prop_default(\"tags\"),\n        concatUnassoc3([{ name: \"SDK\", value: \"aoconnect\" }]),\n        assoc_default(\"tags\", __default, ctx2)\n      )(ctx2)\n    );\n  };\n}\nfunction uploadProcessWith(env) {\n  const logger = env.logger.child(\"uploadProcess\");\n  env = { ...env, logger };\n  const buildTags = buildTagsWith2(env);\n  const buildData = buildDataWith2(env);\n  const deployProcess = deployProcessSchema.implement(env.deployProcess);\n  return (ctx) => {\n    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(\n      ({ data, tags, signer }) => deployProcess({ data, tags, signer: signerSchema.implement(signer) })\n    )).map((res) => assoc_default(\"processId\", res.processId, ctx));\n  };\n}\n\n// src/lib/spawn/index.js\nfunction spawnWith(env) {\n  const verifyInputs = verifyInputsWith(env);\n  const uploadProcess = uploadProcessWith(env);\n  return ({ module, scheduler, signer, tags, data }) => {\n    return of({ module, scheduler, signer, tags, data }).chain(verifyInputs).chain(uploadProcess).map((ctx) => ctx.processId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/monitor/upload-monitor.js\nfunction uploadMonitorWith(env) {\n  const deployMonitor = deployMonitorSchema.implement(env.deployMonitor);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ id, signer }) => deployMonitor({\n        processId: id,\n        signer: signerSchema.implement(signer),\n        /**\n         * No tags or data can be provided right now,\n         *\n         * so just set data to single space and set tags to an empty array\n         */\n        data: \" \",\n        tags: []\n      })\n    )).map((res) => assoc_default(\"monitorId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/monitor/index.js\nfunction monitorWith(env) {\n  const uploadMonitor = uploadMonitorWith(env);\n  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadMonitor).map((ctx) => ctx.monitorId).bimap(errFrom, identity_default).toPromise();\n}\n\n// src/lib/unmonitor/upload-unmonitor.js\nfunction uploadUnmonitorWith(env) {\n  const deployUnmonitor = deployMonitorSchema.implement(env.deployUnmonitor);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ id, signer }) => deployUnmonitor({\n        processId: id,\n        signer: signerSchema.implement(signer),\n        /**\n         * No tags or data can be provided right now,\n         *\n         * so just set data to single space and set tags to an empty array\n         */\n        data: \" \",\n        tags: []\n      })\n    )).map((res) => assoc_default(\"monitorId\", res.messageId, ctx));\n  };\n}\n\n// src/lib/unmonitor/index.js\nfunction unmonitorWith(env) {\n  const uploadUnmonitor = uploadUnmonitorWith(env);\n  return ({ process: process2, signer }) => of({ id: process2, signer }).chain(uploadUnmonitor).map((ctx) => ctx.monitorId).bimap(errFrom, identity_default).toPromise();\n}\n\n// src/lib/results/verify-input.js\nvar inputSchema2 = z2.object({\n  process: z2.string().min(1, { message: \"process identifier is required\" }),\n  from: z2.string().optional(),\n  to: z2.string().optional(),\n  sort: z2.enum([\"ASC\", \"DESC\"]).default(\"ASC\"),\n  limit: z2.number().optional()\n});\nfunction verifyInputWith2() {\n  return (ctx) => {\n    return of(ctx).map(inputSchema2.parse).map(() => ctx);\n  };\n}\n\n// src/lib/results/query.js\nfunction queryWith({ queryResults }) {\n  queryResults = fromPromise(queryResultsSchema.implement(queryResults));\n  return (ctx) => {\n    return of({ process: ctx.process, from: ctx.from, to: ctx.to, sort: ctx.sort, limit: ctx.limit }).chain(queryResults);\n  };\n}\n\n// src/lib/results/index.js\nfunction resultsWith(env) {\n  const verifyInput = verifyInputWith2(env);\n  const query = queryWith(env);\n  return ({ process: process2, from, to, sort, limit }) => {\n    return of({ process: process2, from, to, sort, limit }).chain(verifyInput).chain(query).map(\n      env.logger.tap(\n        'readResults result for message \"%s\": %O',\n        process2\n      )\n    ).map((result2) => result2).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/dryrun/verify-input.js\nvar inputSchema3 = z2.object({\n  Id: z2.string(),\n  Target: z2.string(),\n  Owner: z2.string(),\n  Anchor: z2.string().optional(),\n  Data: z2.any().default(\"1234\"),\n  Tags: z2.array(z2.object({ name: z2.string(), value: z2.string() }))\n});\nfunction verifyInputWith3() {\n  return (msg) => {\n    return of(msg).map(inputSchema3.parse).map((m2) => {\n      m2.Tags = m2.Tags.concat([\n        { name: \"Data-Protocol\", value: \"ao\" },\n        { name: \"Type\", value: \"Message\" },\n        { name: \"Variant\", value: \"ao.TN.1\" }\n      ]);\n      return m2;\n    });\n  };\n}\n\n// src/lib/dryrun/run.js\nfunction runWith({ dryrunFetch }) {\n  return fromPromise(dryrunResultSchema.implement(dryrunFetch));\n}\n\n// src/lib/dryrun/index.js\nfunction dryrunWith(env) {\n  const verifyInput = verifyInputWith3(env);\n  const dryrun2 = runWith(env);\n  return (msg) => of(msg).map(convert).chain(verifyInput).chain(dryrun2).toPromise();\n}\nfunction convert({ process: process2, data, tags, anchor, ...rest }) {\n  return {\n    Id: \"1234\",\n    Owner: \"1234\",\n    ...rest,\n    Target: process2,\n    Data: data || \"1234\",\n    Tags: tags || [],\n    Anchor: anchor || \"0\"\n  };\n}\n\n// src/lib/assign/send-assign.js\nfunction sendAssignWith(env) {\n  const deployAssign = deployAssignSchema.implement(env.deployAssign);\n  return (ctx) => {\n    return of(ctx).chain(fromPromise(\n      ({ process: process2, message: message2, baseLayer, exclude }) => deployAssign({ process: process2, message: message2, baseLayer, exclude })\n    )).map((res) => assoc_default(\"assignmentId\", res.assignmentId, ctx));\n  };\n}\n\n// src/lib/assign/index.js\nfunction assignWith(env) {\n  const sendAssign = sendAssignWith(env);\n  return ({ process: process2, message: message2, baseLayer, exclude }) => {\n    return of({ process: process2, message: message2, baseLayer, exclude }).chain(sendAssign).map((ctx) => ctx.assignmentId).bimap(errFrom, identity_default).toPromise();\n  };\n}\n\n// src/lib/serializeCron/index.js\nfunction serializeCron(cron) {\n  function parseInterval(interval2 = \"\") {\n    if (typeof interval2 !== \"string\") throw new Error(\"Encountered Error serializing cron: invalid interval\");\n    const [value, unit] = interval2.split(\"-\").map((s) => s.trim());\n    if (!value || !unit) throw new Error(\"Encountered Error serializing cron: invalid interval\");\n    if (!parseInt(value) || parseInt(value) < 0) throw new Error(\"Encountered Error serializing cron: invalid interval value\");\n    const singularRegex = /^(millisecond|second|minute|hour|day|month|year|block)$/;\n    const pluralRegex = /^(milliseconds|seconds|minutes|hours|days|months|years|blocks)$/;\n    const unitSingularMatch = unit.match(singularRegex);\n    const unitPluralMatch = unit.match(pluralRegex);\n    if (parseInt(value) > 1 && !unitPluralMatch || parseInt(value) === 1 && !unitSingularMatch) throw new Error(\"Encountered Error serializing cron: invalid interval type\");\n    return `${value}-${unit}`;\n  }\n  function parseTags3(tags2 = []) {\n    return map_default((tag) => {\n      if (!tag.name || !tag.value) throw new Error(\"Encountered Error serializing cron: invalid tag structure\");\n      if (typeof tag.name !== \"string\" || typeof tag.value !== \"string\") throw new Error(\"Encountered Error serializing cron: invalid interval tag types\");\n      return { name: `Cron-Tag-${tag.name}`, value: tag.value };\n    }, tags2);\n  }\n  const interval = parseInterval(cron.interval);\n  const tags = parseTags3(cron.tags);\n  return [{ name: \"Cron-Interval\", value: interval }, ...tags];\n}\n\n// src/index.common.js\nvar DEFAULT_GATEWAY_URL = \"https://arweave.net\";\nvar DEFAULT_MU_URL = \"https://mu.ao-testnet.xyz\";\nvar DEFAULT_CU_URL = \"https://cu.ao-testnet.xyz\";\nfunction connect({\n  GRAPHQL_URL: GRAPHQL_URL2,\n  GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2,\n  GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2,\n  GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL,\n  MU_URL: MU_URL2 = DEFAULT_MU_URL,\n  CU_URL: CU_URL2 = DEFAULT_CU_URL\n} = {}) {\n  const logger = createLogger();\n  if (!GRAPHQL_URL2) GRAPHQL_URL2 = joinUrl({ url: GATEWAY_URL2, path: \"/graphql\" });\n  const { validate } = en({ cacheSize: 100, GRAPHQL_URL: GRAPHQL_URL2, GRAPHQL_MAX_RETRIES: GRAPHQL_MAX_RETRIES2, GRAPHQL_RETRY_BACKOFF: GRAPHQL_RETRY_BACKOFF2 });\n  const processMetaCache2 = createProcessMetaCache({ MAX_SIZE: 25 });\n  const resultLogger = logger.child(\"result\");\n  const result2 = resultWith({\n    loadResult: loadResultWith({ fetch, CU_URL: CU_URL2, logger: resultLogger }),\n    logger: resultLogger\n  });\n  const messageLogger = logger.child(\"message\");\n  const message2 = messageWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: messageLogger\n    }),\n    // locateScheduler: locate,\n    deployMessage: deployMessageWith({ fetch, MU_URL: MU_URL2, logger: messageLogger }),\n    logger: messageLogger\n  });\n  const spawnLogger = logger.child(\"spawn\");\n  const spawn2 = spawnWith({\n    loadTransactionMeta: loadTransactionMetaWith({ fetch, GRAPHQL_URL: GRAPHQL_URL2, logger: spawnLogger }),\n    validateScheduler: validate,\n    deployProcess: deployProcessWith({ fetch, MU_URL: MU_URL2, logger: spawnLogger }),\n    logger: spawnLogger\n  });\n  const monitorLogger = logger.child(\"monitor\");\n  const monitor2 = monitorWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: monitorLogger\n    }),\n    // locateScheduler: locate,\n    deployMonitor: deployMonitorWith({ fetch, MU_URL: MU_URL2, logger: monitorLogger }),\n    logger: monitorLogger\n  });\n  const unmonitorLogger = logger.child(\"unmonitor\");\n  const unmonitor2 = unmonitorWith({\n    loadProcessMeta: loadProcessMetaWith({\n      fetch,\n      cache: processMetaCache2,\n      logger: unmonitorLogger\n    }),\n    // locateScheduler: locate,\n    deployUnmonitor: deployUnmonitorWith({ fetch, MU_URL: MU_URL2, logger: unmonitorLogger }),\n    logger: monitorLogger\n  });\n  const resultsLogger = logger.child(\"results\");\n  const results2 = resultsWith({\n    queryResults: queryResultsWith({ fetch, CU_URL: CU_URL2, logger: resultsLogger }),\n    logger: resultsLogger\n  });\n  const dryrunLogger = logger.child(\"dryrun\");\n  const dryrun2 = dryrunWith({\n    dryrunFetch: dryrunFetchWith({ fetch, CU_URL: CU_URL2, logger: dryrunLogger }),\n    logger: dryrunLogger\n  });\n  const assignLogger = logger.child(\"assign\");\n  const assign2 = assignWith({\n    deployAssign: deployAssignWith({\n      fetch,\n      MU_URL: MU_URL2,\n      logger: assignLogger\n    }),\n    logger: messageLogger\n  });\n  return { result: result2, results: results2, message: message2, spawn: spawn2, monitor: monitor2, unmonitor: unmonitor2, dryrun: dryrun2, assign: assign2 };\n}\n\n// src/client/browser/wallet.js\nvar wallet_exports = {};\n__export(wallet_exports, {\n  createDataItemSigner: () => createDataItemSigner\n});\nvar import_buffer = __toESM(require_buffer(), 1);\n\n// node_modules/warp-arbundles/build/web/esm/bundle.js\nvar bundle_exports = {};\n__export(bundle_exports, {\n  AVSCTap: () => $2,\n  ArweaveSigner: () => N2,\n  DataItem: () => _2,\n  MAX_TAG_BYTES: () => tt2,\n  MIN_BINARY_SIZE: () => gr2,\n  SIG_CONFIG: () => P2,\n  SignatureConfig: () => B,\n  Signer: () => ot2,\n  createData: () => ge2,\n  default: () => wn2,\n  deserializeTags: () => Q,\n  indexToType: () => wt2,\n  serializeTags: () => dt2,\n  tagsExceedLimit: () => jr2,\n  warparbundles: () => dn2\n});\nvar xr2 = Object.create;\nvar it2 = Object.defineProperty;\nvar mr2 = Object.getOwnPropertyDescriptor;\nvar Br2 = Object.getOwnPropertyNames;\nvar Er2 = Object.getPrototypeOf;\nvar br2 = Object.prototype.hasOwnProperty;\nvar T2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);\nvar Ar2 = (e, t) => {\n  for (var r18 in t) it2(e, r18, { get: t[r18], enumerable: true });\n};\nvar Tr2 = (e, t, r18, n) => {\n  if (t && typeof t == \"object\" || typeof t == \"function\") for (let i of Br2(t)) !br2.call(e, i) && i !== r18 && it2(e, i, { get: () => t[i], enumerable: !(n = mr2(t, i)) || n.enumerable });\n  return e;\n};\nvar C = (e, t, r18) => (r18 = e != null ? xr2(Er2(e)) : {}, Tr2(t || !e || !e.__esModule ? it2(r18, \"default\", { value: e, enumerable: true }) : r18, e));\nvar Rt2 = T2((st2) => {\n  \"use strict\";\n  Object.defineProperty(st2, \"__esModule\", { value: true });\n  function Ir2(e) {\n    var t = 4, r18 = e.length, n = r18 % t;\n    if (!n) return e;\n    var i = r18, o = t - n, s = r18 + o, u = Buffer.alloc(s);\n    for (u.write(e); o--; ) u.write(\"=\", i++);\n    return u.toString();\n  }\n  st2.default = Ir2;\n});\nvar Dt2 = T2((ht2) => {\n  \"use strict\";\n  Object.defineProperty(ht2, \"__esModule\", { value: true });\n  var Sr2 = Rt2();\n  function Ct2(e, t) {\n    return t === void 0 && (t = \"utf8\"), Buffer.isBuffer(e) ? at2(e.toString(\"base64\")) : at2(Buffer.from(e, t).toString(\"base64\"));\n  }\n  function Ur2(e, t) {\n    return t === void 0 && (t = \"utf8\"), Buffer.from(ut2(e), \"base64\").toString(t);\n  }\n  function ut2(e) {\n    return e = e.toString(), Sr2.default(e).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n  }\n  function at2(e) {\n    return e.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  }\n  function Fr2(e) {\n    return Buffer.from(ut2(e), \"base64\");\n  }\n  var O = Ct2;\n  O.encode = Ct2;\n  O.decode = Ur2;\n  O.toBase64 = ut2;\n  O.fromBase64 = at2;\n  O.toBuffer = Fr2;\n  ht2.default = O;\n});\nvar z3 = T2((me2, V) => {\n  V.exports = Dt2().default;\n  V.exports.default = V.exports;\n});\nvar ct2 = T2((J2) => {\n  \"use strict\";\n  J2.byteLength = _r2;\n  J2.toByteArray = Cr2;\n  J2.fromByteArray = Nr2;\n  var b2 = [], m2 = [], Lr2 = typeof Uint8Array < \"u\" ? Uint8Array : Array, ft2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (D2 = 0, Pt2 = ft2.length; D2 < Pt2; ++D2) b2[D2] = ft2[D2], m2[ft2.charCodeAt(D2)] = D2;\n  var D2, Pt2;\n  m2[\"-\".charCodeAt(0)] = 62;\n  m2[\"_\".charCodeAt(0)] = 63;\n  function Nt2(e) {\n    var t = e.length;\n    if (t % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var r18 = e.indexOf(\"=\");\n    r18 === -1 && (r18 = t);\n    var n = r18 === t ? 0 : 4 - r18 % 4;\n    return [r18, n];\n  }\n  function _r2(e) {\n    var t = Nt2(e), r18 = t[0], n = t[1];\n    return (r18 + n) * 3 / 4 - n;\n  }\n  function Rr2(e, t, r18) {\n    return (t + r18) * 3 / 4 - r18;\n  }\n  function Cr2(e) {\n    var t, r18 = Nt2(e), n = r18[0], i = r18[1], o = new Lr2(Rr2(e, n, i)), s = 0, u = i > 0 ? n - 4 : n, h;\n    for (h = 0; h < u; h += 4) t = m2[e.charCodeAt(h)] << 18 | m2[e.charCodeAt(h + 1)] << 12 | m2[e.charCodeAt(h + 2)] << 6 | m2[e.charCodeAt(h + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;\n    return i === 2 && (t = m2[e.charCodeAt(h)] << 2 | m2[e.charCodeAt(h + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = m2[e.charCodeAt(h)] << 10 | m2[e.charCodeAt(h + 1)] << 4 | m2[e.charCodeAt(h + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;\n  }\n  function Dr2(e) {\n    return b2[e >> 18 & 63] + b2[e >> 12 & 63] + b2[e >> 6 & 63] + b2[e & 63];\n  }\n  function Pr2(e, t, r18) {\n    for (var n, i = [], o = t; o < r18; o += 3) n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(Dr2(n));\n    return i.join(\"\");\n  }\n  function Nr2(e) {\n    for (var t, r18 = e.length, n = r18 % 3, i = [], o = 16383, s = 0, u = r18 - n; s < u; s += o) i.push(Pr2(e, s, s + o > u ? u : s + o));\n    return n === 1 ? (t = e[r18 - 1], i.push(b2[t >> 2] + b2[t << 4 & 63] + \"==\")) : n === 2 && (t = (e[r18 - 2] << 8) + e[r18 - 1], i.push(b2[t >> 10] + b2[t >> 4 & 63] + b2[t << 2 & 63] + \"=\")), i.join(\"\");\n  }\n});\nvar pt2 = T2((g2) => {\n  \"use strict\";\n  Object.defineProperty(g2, \"__esModule\", { value: true });\n  g2.b64UrlDecode = g2.b64UrlEncode = g2.bufferTob64Url = g2.bufferTob64 = g2.b64UrlToBuffer = g2.stringToB64Url = g2.stringToBuffer = g2.bufferToString = g2.b64UrlToString = g2.concatBuffers = void 0;\n  var kt2 = ct2();\n  function kr2(e) {\n    let t = 0;\n    for (let i = 0; i < e.length; i++) t += e[i].byteLength;\n    let r18 = new Uint8Array(t), n = 0;\n    r18.set(new Uint8Array(e[0]), n), n += e[0].byteLength;\n    for (let i = 1; i < e.length; i++) r18.set(new Uint8Array(e[i]), n), n += e[i].byteLength;\n    return r18;\n  }\n  g2.concatBuffers = kr2;\n  function Mr2(e) {\n    let t = $t2(e);\n    return Mt2(t);\n  }\n  g2.b64UrlToString = Mr2;\n  function Mt2(e) {\n    return new TextDecoder(\"utf-8\", { fatal: true }).decode(e);\n  }\n  g2.bufferToString = Mt2;\n  function Ot2(e) {\n    return new TextEncoder().encode(e);\n  }\n  g2.stringToBuffer = Ot2;\n  function Or2(e) {\n    return Ht2(Ot2(e));\n  }\n  g2.stringToB64Url = Or2;\n  function $t2(e) {\n    return new Uint8Array(kt2.toByteArray(qt2(e)));\n  }\n  g2.b64UrlToBuffer = $t2;\n  function Kt2(e) {\n    return kt2.fromByteArray(new Uint8Array(e));\n  }\n  g2.bufferTob64 = Kt2;\n  function Ht2(e) {\n    return jt2(Kt2(e));\n  }\n  g2.bufferTob64Url = Ht2;\n  function jt2(e) {\n    return e.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n  }\n  g2.b64UrlEncode = jt2;\n  function qt2(e) {\n    e = e.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n    let t;\n    return e.length % 4 == 0 ? t = 0 : t = 4 - e.length % 4, e.concat(\"=\".repeat(t));\n  }\n  g2.b64UrlDecode = qt2;\n});\nvar Yt = T2((gt2) => {\n  \"use strict\";\n  Object.defineProperty(gt2, \"__esModule\", { value: true });\n  var F3 = pt2(), lt2 = class {\n    keyLength = 4096;\n    publicExponent = 65537;\n    hashAlgorithm = \"sha256\";\n    driver;\n    constructor() {\n      if (!this.detectWebCrypto()) throw new Error(\"SubtleCrypto not available!\");\n      this.driver = crypto.subtle;\n    }\n    async generateJWK() {\n      let t = await this.driver.generateKey({ name: \"RSA-PSS\", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: \"SHA-256\" } }, true, [\"sign\"]), r18 = await this.driver.exportKey(\"jwk\", t.privateKey);\n      return { kty: r18.kty, e: r18.e, n: r18.n, d: r18.d, p: r18.p, q: r18.q, dp: r18.dp, dq: r18.dq, qi: r18.qi };\n    }\n    async sign(t, r18, { saltLength: n } = {}) {\n      let i = await this.driver.sign({ name: \"RSA-PSS\", saltLength: 32 }, await this.jwkToCryptoKey(t), r18);\n      return new Uint8Array(i);\n    }\n    async hash(t, r18 = \"SHA-256\") {\n      let n = await this.driver.digest(r18, t);\n      return new Uint8Array(n);\n    }\n    async verify(t, r18, n) {\n      let i = { kty: \"RSA\", e: \"AQAB\", n: t }, o = await this.jwkToPublicCryptoKey(i), s = await this.driver.digest(\"SHA-256\", r18), u = await this.driver.verify({ name: \"RSA-PSS\", saltLength: 0 }, o, n, r18), h = await this.driver.verify({ name: \"RSA-PSS\", saltLength: 32 }, o, n, r18), p2 = await this.driver.verify({ name: \"RSA-PSS\", saltLength: Math.ceil((o.algorithm.modulusLength - 1) / 8) - s.byteLength - 2 }, o, n, r18);\n      return u || h || p2;\n    }\n    async jwkToCryptoKey(t) {\n      return this.driver.importKey(\"jwk\", t, { name: \"RSA-PSS\", hash: { name: \"SHA-256\" } }, false, [\"sign\"]);\n    }\n    async jwkToPublicCryptoKey(t) {\n      return this.driver.importKey(\"jwk\", t, { name: \"RSA-PSS\", hash: { name: \"SHA-256\" } }, false, [\"verify\"]);\n    }\n    detectWebCrypto() {\n      if (typeof crypto > \"u\") return false;\n      let t = crypto?.subtle;\n      return t === void 0 ? false : [\"generateKey\", \"importKey\", \"exportKey\", \"digest\", \"sign\"].every((n) => typeof t[n] == \"function\");\n    }\n    async encrypt(t, r18, n) {\n      let i = await this.driver.importKey(\"raw\", typeof r18 == \"string\" ? F3.stringToBuffer(r18) : r18, { name: \"PBKDF2\", length: 32 }, false, [\"deriveKey\"]), o = await this.driver.deriveKey({ name: \"PBKDF2\", salt: n ? F3.stringToBuffer(n) : F3.stringToBuffer(\"salt\"), iterations: 1e5, hash: \"SHA-256\" }, i, { name: \"AES-CBC\", length: 256 }, false, [\"encrypt\", \"decrypt\"]), s = new Uint8Array(16);\n      crypto.getRandomValues(s);\n      let u = await this.driver.encrypt({ name: \"AES-CBC\", iv: s }, o, t);\n      return F3.concatBuffers([s, u]);\n    }\n    async decrypt(t, r18, n) {\n      let i = await this.driver.importKey(\"raw\", typeof r18 == \"string\" ? F3.stringToBuffer(r18) : r18, { name: \"PBKDF2\", length: 32 }, false, [\"deriveKey\"]), o = await this.driver.deriveKey({ name: \"PBKDF2\", salt: n ? F3.stringToBuffer(n) : F3.stringToBuffer(\"salt\"), iterations: 1e5, hash: \"SHA-256\" }, i, { name: \"AES-CBC\", length: 256 }, false, [\"encrypt\", \"decrypt\"]), s = t.slice(0, 16), u = await this.driver.decrypt({ name: \"AES-CBC\", iv: s }, o, t.slice(16));\n      return F3.concatBuffers([u]);\n    }\n  };\n  gt2.default = lt2;\n});\nvar zt2 = T2((mt2) => {\n  mt2.read = function(e, t, r18, n, i) {\n    var o, s, u = i * 8 - n - 1, h = (1 << u) - 1, p2 = h >> 1, f2 = -7, c2 = r18 ? i - 1 : 0, U2 = r18 ? -1 : 1, l = e[t + c2];\n    for (c2 += U2, o = l & (1 << -f2) - 1, l >>= -f2, f2 += u; f2 > 0; o = o * 256 + e[t + c2], c2 += U2, f2 -= 8) ;\n    for (s = o & (1 << -f2) - 1, o >>= -f2, f2 += n; f2 > 0; s = s * 256 + e[t + c2], c2 += U2, f2 -= 8) ;\n    if (o === 0) o = 1 - p2;\n    else {\n      if (o === h) return s ? NaN : (l ? -1 : 1) * (1 / 0);\n      s = s + Math.pow(2, n), o = o - p2;\n    }\n    return (l ? -1 : 1) * s * Math.pow(2, o - n);\n  };\n  mt2.write = function(e, t, r18, n, i, o) {\n    var s, u, h, p2 = o * 8 - i - 1, f2 = (1 << p2) - 1, c2 = f2 >> 1, U2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, l = n ? 0 : o - 1, R2 = n ? 1 : -1, G2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;\n    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, s = f2) : (s = Math.floor(Math.log(t) / Math.LN2), t * (h = Math.pow(2, -s)) < 1 && (s--, h *= 2), s + c2 >= 1 ? t += U2 / h : t += U2 * Math.pow(2, 1 - c2), t * h >= 2 && (s++, h /= 2), s + c2 >= f2 ? (u = 0, s = f2) : s + c2 >= 1 ? (u = (t * h - 1) * Math.pow(2, i), s = s + c2) : (u = t * Math.pow(2, c2 - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r18 + l] = u & 255, l += R2, u /= 256, i -= 8) ;\n    for (s = s << i | u, p2 += i; p2 > 0; e[r18 + l] = s & 255, l += R2, s /= 256, p2 -= 8) ;\n    e[r18 + l - R2] |= G2 * 128;\n  };\n});\nvar nt2 = T2((q2) => {\n  \"use strict\";\n  var Bt2 = ct2(), H2 = zt2(), Jt = typeof Symbol == \"function\" && typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n  q2.Buffer = a;\n  q2.SlowBuffer = Vr2;\n  q2.INSPECT_MAX_BYTES = 50;\n  var rt2 = 2147483647;\n  q2.kMaxLength = rt2;\n  a.TYPED_ARRAY_SUPPORT = qr2();\n  !a.TYPED_ARRAY_SUPPORT && typeof console < \"u\" && typeof console.error == \"function\" && console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  function qr2() {\n    try {\n      let e = new Uint8Array(1), t = { foo: function() {\n        return 42;\n      } };\n      return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;\n    } catch {\n      return false;\n    }\n  }\n  Object.defineProperty(a.prototype, \"parent\", { enumerable: true, get: function() {\n    if (a.isBuffer(this)) return this.buffer;\n  } });\n  Object.defineProperty(a.prototype, \"offset\", { enumerable: true, get: function() {\n    if (a.isBuffer(this)) return this.byteOffset;\n  } });\n  function S(e) {\n    if (e > rt2) throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n    let t = new Uint8Array(e);\n    return Object.setPrototypeOf(t, a.prototype), t;\n  }\n  function a(e, t, r18) {\n    if (typeof e == \"number\") {\n      if (typeof t == \"string\") throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      return Tt2(e);\n    }\n    return tr2(e, t, r18);\n  }\n  a.poolSize = 8192;\n  function tr2(e, t, r18) {\n    if (typeof e == \"string\") return Yr2(e, t);\n    if (ArrayBuffer.isView(e)) return vr2(e);\n    if (e == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n    if (A(e, ArrayBuffer) || e && A(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < \"u\" && (A(e, SharedArrayBuffer) || e && A(e.buffer, SharedArrayBuffer))) return bt2(e, t, r18);\n    if (typeof e == \"number\") throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    let n = e.valueOf && e.valueOf();\n    if (n != null && n !== e) return a.from(n, t, r18);\n    let i = Wr2(e);\n    if (i) return i;\n    if (typeof Symbol < \"u\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == \"function\") return a.from(e[Symbol.toPrimitive](\"string\"), t, r18);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n  }\n  a.from = function(e, t, r18) {\n    return tr2(e, t, r18);\n  };\n  Object.setPrototypeOf(a.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(a, Uint8Array);\n  function rr2(e) {\n    if (typeof e != \"number\") throw new TypeError('\"size\" argument must be of type number');\n    if (e < 0) throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n  }\n  function Gr2(e, t, r18) {\n    return rr2(e), e <= 0 ? S(e) : t !== void 0 ? typeof r18 == \"string\" ? S(e).fill(t, r18) : S(e).fill(t) : S(e);\n  }\n  a.alloc = function(e, t, r18) {\n    return Gr2(e, t, r18);\n  };\n  function Tt2(e) {\n    return rr2(e), S(e < 0 ? 0 : It2(e) | 0);\n  }\n  a.allocUnsafe = function(e) {\n    return Tt2(e);\n  };\n  a.allocUnsafeSlow = function(e) {\n    return Tt2(e);\n  };\n  function Yr2(e, t) {\n    if ((typeof t != \"string\" || t === \"\") && (t = \"utf8\"), !a.isEncoding(t)) throw new TypeError(\"Unknown encoding: \" + t);\n    let r18 = er2(e, t) | 0, n = S(r18), i = n.write(e, t);\n    return i !== r18 && (n = n.slice(0, i)), n;\n  }\n  function Et2(e) {\n    let t = e.length < 0 ? 0 : It2(e.length) | 0, r18 = S(t);\n    for (let n = 0; n < t; n += 1) r18[n] = e[n] & 255;\n    return r18;\n  }\n  function vr2(e) {\n    if (A(e, Uint8Array)) {\n      let t = new Uint8Array(e);\n      return bt2(t.buffer, t.byteOffset, t.byteLength);\n    }\n    return Et2(e);\n  }\n  function bt2(e, t, r18) {\n    if (t < 0 || e.byteLength < t) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (e.byteLength < t + (r18 || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let n;\n    return t === void 0 && r18 === void 0 ? n = new Uint8Array(e) : r18 === void 0 ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r18), Object.setPrototypeOf(n, a.prototype), n;\n  }\n  function Wr2(e) {\n    if (a.isBuffer(e)) {\n      let t = It2(e.length) | 0, r18 = S(t);\n      return r18.length === 0 || e.copy(r18, 0, 0, t), r18;\n    }\n    if (e.length !== void 0) return typeof e.length != \"number\" || Ut2(e.length) ? S(0) : Et2(e);\n    if (e.type === \"Buffer\" && Array.isArray(e.data)) return Et2(e.data);\n  }\n  function It2(e) {\n    if (e >= rt2) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + rt2.toString(16) + \" bytes\");\n    return e | 0;\n  }\n  function Vr2(e) {\n    return +e != e && (e = 0), a.alloc(+e);\n  }\n  a.isBuffer = function(t) {\n    return t != null && t._isBuffer === true && t !== a.prototype;\n  };\n  a.compare = function(t, r18) {\n    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), A(r18, Uint8Array) && (r18 = a.from(r18, r18.offset, r18.byteLength)), !a.isBuffer(t) || !a.isBuffer(r18)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (t === r18) return 0;\n    let n = t.length, i = r18.length;\n    for (let o = 0, s = Math.min(n, i); o < s; ++o) if (t[o] !== r18[o]) {\n      n = t[o], i = r18[o];\n      break;\n    }\n    return n < i ? -1 : i < n ? 1 : 0;\n  };\n  a.isEncoding = function(t) {\n    switch (String(t).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  a.concat = function(t, r18) {\n    if (!Array.isArray(t)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (t.length === 0) return a.alloc(0);\n    let n;\n    if (r18 === void 0) for (r18 = 0, n = 0; n < t.length; ++n) r18 += t[n].length;\n    let i = a.allocUnsafe(r18), o = 0;\n    for (n = 0; n < t.length; ++n) {\n      let s = t[n];\n      if (A(s, Uint8Array)) o + s.length > i.length ? (a.isBuffer(s) || (s = a.from(s)), s.copy(i, o)) : Uint8Array.prototype.set.call(i, s, o);\n      else if (a.isBuffer(s)) s.copy(i, o);\n      else throw new TypeError('\"list\" argument must be an Array of Buffers');\n      o += s.length;\n    }\n    return i;\n  };\n  function er2(e, t) {\n    if (a.isBuffer(e)) return e.length;\n    if (ArrayBuffer.isView(e) || A(e, ArrayBuffer)) return e.byteLength;\n    if (typeof e != \"string\") throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);\n    let r18 = e.length, n = arguments.length > 2 && arguments[2] === true;\n    if (!n && r18 === 0) return 0;\n    let i = false;\n    for (; ; ) switch (t) {\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n        return r18;\n      case \"utf8\":\n      case \"utf-8\":\n        return At2(e).length;\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return r18 * 2;\n      case \"hex\":\n        return r18 >>> 1;\n      case \"base64\":\n        return cr2(e).length;\n      default:\n        if (i) return n ? -1 : At2(e).length;\n        t = (\"\" + t).toLowerCase(), i = true;\n    }\n  }\n  a.byteLength = er2;\n  function zr2(e, t, r18) {\n    let n = false;\n    if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((r18 === void 0 || r18 > this.length) && (r18 = this.length), r18 <= 0) || (r18 >>>= 0, t >>>= 0, r18 <= t)) return \"\";\n    for (e || (e = \"utf8\"); ; ) switch (e) {\n      case \"hex\":\n        return oe(this, t, r18);\n      case \"utf8\":\n      case \"utf-8\":\n        return ir2(this, t, r18);\n      case \"ascii\":\n        return ne2(this, t, r18);\n      case \"latin1\":\n      case \"binary\":\n        return ie2(this, t, r18);\n      case \"base64\":\n        return re2(this, t, r18);\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return se2(this, t, r18);\n      default:\n        if (n) throw new TypeError(\"Unknown encoding: \" + e);\n        e = (e + \"\").toLowerCase(), n = true;\n    }\n  }\n  a.prototype._isBuffer = true;\n  function k2(e, t, r18) {\n    let n = e[t];\n    e[t] = e[r18], e[r18] = n;\n  }\n  a.prototype.swap16 = function() {\n    let t = this.length;\n    if (t % 2 !== 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for (let r18 = 0; r18 < t; r18 += 2) k2(this, r18, r18 + 1);\n    return this;\n  };\n  a.prototype.swap32 = function() {\n    let t = this.length;\n    if (t % 4 !== 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for (let r18 = 0; r18 < t; r18 += 4) k2(this, r18, r18 + 3), k2(this, r18 + 1, r18 + 2);\n    return this;\n  };\n  a.prototype.swap64 = function() {\n    let t = this.length;\n    if (t % 8 !== 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for (let r18 = 0; r18 < t; r18 += 8) k2(this, r18, r18 + 7), k2(this, r18 + 1, r18 + 6), k2(this, r18 + 2, r18 + 5), k2(this, r18 + 3, r18 + 4);\n    return this;\n  };\n  a.prototype.toString = function() {\n    let t = this.length;\n    return t === 0 ? \"\" : arguments.length === 0 ? ir2(this, 0, t) : zr2.apply(this, arguments);\n  };\n  a.prototype.toLocaleString = a.prototype.toString;\n  a.prototype.equals = function(t) {\n    if (!a.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n    return this === t ? true : a.compare(this, t) === 0;\n  };\n  a.prototype.inspect = function() {\n    let t = \"\", r18 = q2.INSPECT_MAX_BYTES;\n    return t = this.toString(\"hex\", 0, r18).replace(/(.{2})/g, \"$1 \").trim(), this.length > r18 && (t += \" ... \"), \"<Buffer \" + t + \">\";\n  };\n  Jt && (a.prototype[Jt] = a.prototype.inspect);\n  a.prototype.compare = function(t, r18, n, i, o) {\n    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(t)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);\n    if (r18 === void 0 && (r18 = 0), n === void 0 && (n = t ? t.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), r18 < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError(\"out of range index\");\n    if (i >= o && r18 >= n) return 0;\n    if (i >= o) return -1;\n    if (r18 >= n) return 1;\n    if (r18 >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === t) return 0;\n    let s = o - i, u = n - r18, h = Math.min(s, u), p2 = this.slice(i, o), f2 = t.slice(r18, n);\n    for (let c2 = 0; c2 < h; ++c2) if (p2[c2] !== f2[c2]) {\n      s = p2[c2], u = f2[c2];\n      break;\n    }\n    return s < u ? -1 : u < s ? 1 : 0;\n  };\n  function nr2(e, t, r18, n, i) {\n    if (e.length === 0) return -1;\n    if (typeof r18 == \"string\" ? (n = r18, r18 = 0) : r18 > 2147483647 ? r18 = 2147483647 : r18 < -2147483648 && (r18 = -2147483648), r18 = +r18, Ut2(r18) && (r18 = i ? 0 : e.length - 1), r18 < 0 && (r18 = e.length + r18), r18 >= e.length) {\n      if (i) return -1;\n      r18 = e.length - 1;\n    } else if (r18 < 0) if (i) r18 = 0;\n    else return -1;\n    if (typeof t == \"string\" && (t = a.from(t, n)), a.isBuffer(t)) return t.length === 0 ? -1 : Xt2(e, t, r18, n, i);\n    if (typeof t == \"number\") return t = t & 255, typeof Uint8Array.prototype.indexOf == \"function\" ? i ? Uint8Array.prototype.indexOf.call(e, t, r18) : Uint8Array.prototype.lastIndexOf.call(e, t, r18) : Xt2(e, [t], r18, n, i);\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function Xt2(e, t, r18, n, i) {\n    let o = 1, s = e.length, u = t.length;\n    if (n !== void 0 && (n = String(n).toLowerCase(), n === \"ucs2\" || n === \"ucs-2\" || n === \"utf16le\" || n === \"utf-16le\")) {\n      if (e.length < 2 || t.length < 2) return -1;\n      o = 2, s /= 2, u /= 2, r18 /= 2;\n    }\n    function h(f2, c2) {\n      return o === 1 ? f2[c2] : f2.readUInt16BE(c2 * o);\n    }\n    let p2;\n    if (i) {\n      let f2 = -1;\n      for (p2 = r18; p2 < s; p2++) if (h(e, p2) === h(t, f2 === -1 ? 0 : p2 - f2)) {\n        if (f2 === -1 && (f2 = p2), p2 - f2 + 1 === u) return f2 * o;\n      } else f2 !== -1 && (p2 -= p2 - f2), f2 = -1;\n    } else for (r18 + u > s && (r18 = s - u), p2 = r18; p2 >= 0; p2--) {\n      let f2 = true;\n      for (let c2 = 0; c2 < u; c2++) if (h(e, p2 + c2) !== h(t, c2)) {\n        f2 = false;\n        break;\n      }\n      if (f2) return p2;\n    }\n    return -1;\n  }\n  a.prototype.includes = function(t, r18, n) {\n    return this.indexOf(t, r18, n) !== -1;\n  };\n  a.prototype.indexOf = function(t, r18, n) {\n    return nr2(this, t, r18, n, true);\n  };\n  a.prototype.lastIndexOf = function(t, r18, n) {\n    return nr2(this, t, r18, n, false);\n  };\n  function Jr2(e, t, r18, n) {\n    r18 = Number(r18) || 0;\n    let i = e.length - r18;\n    n ? (n = Number(n), n > i && (n = i)) : n = i;\n    let o = t.length;\n    n > o / 2 && (n = o / 2);\n    let s;\n    for (s = 0; s < n; ++s) {\n      let u = parseInt(t.substr(s * 2, 2), 16);\n      if (Ut2(u)) return s;\n      e[r18 + s] = u;\n    }\n    return s;\n  }\n  function Xr2(e, t, r18, n) {\n    return et2(At2(t, e.length - r18), e, r18, n);\n  }\n  function Zr2(e, t, r18, n) {\n    return et2(fe2(t), e, r18, n);\n  }\n  function Qr2(e, t, r18, n) {\n    return et2(cr2(t), e, r18, n);\n  }\n  function te2(e, t, r18, n) {\n    return et2(ce2(t, e.length - r18), e, r18, n);\n  }\n  a.prototype.write = function(t, r18, n, i) {\n    if (r18 === void 0) i = \"utf8\", n = this.length, r18 = 0;\n    else if (n === void 0 && typeof r18 == \"string\") i = r18, n = this.length, r18 = 0;\n    else if (isFinite(r18)) r18 = r18 >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = \"utf8\")) : (i = n, n = void 0);\n    else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    let o = this.length - r18;\n    if ((n === void 0 || n > o) && (n = o), t.length > 0 && (n < 0 || r18 < 0) || r18 > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    i || (i = \"utf8\");\n    let s = false;\n    for (; ; ) switch (i) {\n      case \"hex\":\n        return Jr2(this, t, r18, n);\n      case \"utf8\":\n      case \"utf-8\":\n        return Xr2(this, t, r18, n);\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n        return Zr2(this, t, r18, n);\n      case \"base64\":\n        return Qr2(this, t, r18, n);\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return te2(this, t, r18, n);\n      default:\n        if (s) throw new TypeError(\"Unknown encoding: \" + i);\n        i = (\"\" + i).toLowerCase(), s = true;\n    }\n  };\n  a.prototype.toJSON = function() {\n    return { type: \"Buffer\", data: Array.prototype.slice.call(this._arr || this, 0) };\n  };\n  function re2(e, t, r18) {\n    return t === 0 && r18 === e.length ? Bt2.fromByteArray(e) : Bt2.fromByteArray(e.slice(t, r18));\n  }\n  function ir2(e, t, r18) {\n    r18 = Math.min(e.length, r18);\n    let n = [], i = t;\n    for (; i < r18; ) {\n      let o = e[i], s = null, u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;\n      if (i + u <= r18) {\n        let h, p2, f2, c2;\n        switch (u) {\n          case 1:\n            o < 128 && (s = o);\n            break;\n          case 2:\n            h = e[i + 1], (h & 192) === 128 && (c2 = (o & 31) << 6 | h & 63, c2 > 127 && (s = c2));\n            break;\n          case 3:\n            h = e[i + 1], p2 = e[i + 2], (h & 192) === 128 && (p2 & 192) === 128 && (c2 = (o & 15) << 12 | (h & 63) << 6 | p2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (s = c2));\n            break;\n          case 4:\n            h = e[i + 1], p2 = e[i + 2], f2 = e[i + 3], (h & 192) === 128 && (p2 & 192) === 128 && (f2 & 192) === 128 && (c2 = (o & 15) << 18 | (h & 63) << 12 | (p2 & 63) << 6 | f2 & 63, c2 > 65535 && c2 < 1114112 && (s = c2));\n        }\n      }\n      s === null ? (s = 65533, u = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), i += u;\n    }\n    return ee2(n);\n  }\n  var Zt2 = 4096;\n  function ee2(e) {\n    let t = e.length;\n    if (t <= Zt2) return String.fromCharCode.apply(String, e);\n    let r18 = \"\", n = 0;\n    for (; n < t; ) r18 += String.fromCharCode.apply(String, e.slice(n, n += Zt2));\n    return r18;\n  }\n  function ne2(e, t, r18) {\n    let n = \"\";\n    r18 = Math.min(e.length, r18);\n    for (let i = t; i < r18; ++i) n += String.fromCharCode(e[i] & 127);\n    return n;\n  }\n  function ie2(e, t, r18) {\n    let n = \"\";\n    r18 = Math.min(e.length, r18);\n    for (let i = t; i < r18; ++i) n += String.fromCharCode(e[i]);\n    return n;\n  }\n  function oe(e, t, r18) {\n    let n = e.length;\n    (!t || t < 0) && (t = 0), (!r18 || r18 < 0 || r18 > n) && (r18 = n);\n    let i = \"\";\n    for (let o = t; o < r18; ++o) i += pe2[e[o]];\n    return i;\n  }\n  function se2(e, t, r18) {\n    let n = e.slice(t, r18), i = \"\";\n    for (let o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);\n    return i;\n  }\n  a.prototype.slice = function(t, r18) {\n    let n = this.length;\n    t = ~~t, r18 = r18 === void 0 ? n : ~~r18, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r18 < 0 ? (r18 += n, r18 < 0 && (r18 = 0)) : r18 > n && (r18 = n), r18 < t && (r18 = t);\n    let i = this.subarray(t, r18);\n    return Object.setPrototypeOf(i, a.prototype), i;\n  };\n  function y2(e, t, r18) {\n    if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n    if (e + t > r18) throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  a.prototype.readUintLE = a.prototype.readUIntLE = function(t, r18, n) {\n    t = t >>> 0, r18 = r18 >>> 0, n || y2(t, r18, this.length);\n    let i = this[t], o = 1, s = 0;\n    for (; ++s < r18 && (o *= 256); ) i += this[t + s] * o;\n    return i;\n  };\n  a.prototype.readUintBE = a.prototype.readUIntBE = function(t, r18, n) {\n    t = t >>> 0, r18 = r18 >>> 0, n || y2(t, r18, this.length);\n    let i = this[t + --r18], o = 1;\n    for (; r18 > 0 && (o *= 256); ) i += this[t + --r18] * o;\n    return i;\n  };\n  a.prototype.readUint8 = a.prototype.readUInt8 = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 1, this.length), this[t];\n  };\n  a.prototype.readUint16LE = a.prototype.readUInt16LE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 2, this.length), this[t] | this[t + 1] << 8;\n  };\n  a.prototype.readUint16BE = a.prototype.readUInt16BE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 2, this.length), this[t] << 8 | this[t + 1];\n  };\n  a.prototype.readUint32LE = a.prototype.readUInt32LE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;\n  };\n  a.prototype.readUint32BE = a.prototype.readUInt32BE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);\n  };\n  a.prototype.readBigUInt64LE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r18 = this[t], n = this[t + 7];\n    (r18 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = r18 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;\n    return BigInt(i) + (BigInt(o) << BigInt(32));\n  });\n  a.prototype.readBigUInt64BE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r18 = this[t], n = this[t + 7];\n    (r18 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = r18 * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;\n    return (BigInt(i) << BigInt(32)) + BigInt(o);\n  });\n  a.prototype.readIntLE = function(t, r18, n) {\n    t = t >>> 0, r18 = r18 >>> 0, n || y2(t, r18, this.length);\n    let i = this[t], o = 1, s = 0;\n    for (; ++s < r18 && (o *= 256); ) i += this[t + s] * o;\n    return o *= 128, i >= o && (i -= Math.pow(2, 8 * r18)), i;\n  };\n  a.prototype.readIntBE = function(t, r18, n) {\n    t = t >>> 0, r18 = r18 >>> 0, n || y2(t, r18, this.length);\n    let i = r18, o = 1, s = this[t + --i];\n    for (; i > 0 && (o *= 256); ) s += this[t + --i] * o;\n    return o *= 128, s >= o && (s -= Math.pow(2, 8 * r18)), s;\n  };\n  a.prototype.readInt8 = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];\n  };\n  a.prototype.readInt16LE = function(t, r18) {\n    t = t >>> 0, r18 || y2(t, 2, this.length);\n    let n = this[t] | this[t + 1] << 8;\n    return n & 32768 ? n | 4294901760 : n;\n  };\n  a.prototype.readInt16BE = function(t, r18) {\n    t = t >>> 0, r18 || y2(t, 2, this.length);\n    let n = this[t + 1] | this[t] << 8;\n    return n & 32768 ? n | 4294901760 : n;\n  };\n  a.prototype.readInt32LE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;\n  };\n  a.prototype.readInt32BE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];\n  };\n  a.prototype.readBigInt64LE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r18 = this[t], n = this[t + 7];\n    (r18 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);\n    return (BigInt(i) << BigInt(32)) + BigInt(r18 + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);\n  });\n  a.prototype.readBigInt64BE = L(function(t) {\n    t = t >>> 0, j2(t, \"offset\");\n    let r18 = this[t], n = this[t + 7];\n    (r18 === void 0 || n === void 0) && W(t, this.length - 8);\n    let i = (r18 << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];\n    return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);\n  });\n  a.prototype.readFloatLE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), H2.read(this, t, true, 23, 4);\n  };\n  a.prototype.readFloatBE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 4, this.length), H2.read(this, t, false, 23, 4);\n  };\n  a.prototype.readDoubleLE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 8, this.length), H2.read(this, t, true, 52, 8);\n  };\n  a.prototype.readDoubleBE = function(t, r18) {\n    return t = t >>> 0, r18 || y2(t, 8, this.length), H2.read(this, t, false, 52, 8);\n  };\n  function d2(e, t, r18, n, i, o) {\n    if (!a.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (t > i || t < o) throw new RangeError('\"value\" argument is out of bounds');\n    if (r18 + n > e.length) throw new RangeError(\"Index out of range\");\n  }\n  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(t, r18, n, i) {\n    if (t = +t, r18 = r18 >>> 0, n = n >>> 0, !i) {\n      let u = Math.pow(2, 8 * n) - 1;\n      d2(this, t, r18, n, u, 0);\n    }\n    let o = 1, s = 0;\n    for (this[r18] = t & 255; ++s < n && (o *= 256); ) this[r18 + s] = t / o & 255;\n    return r18 + n;\n  };\n  a.prototype.writeUintBE = a.prototype.writeUIntBE = function(t, r18, n, i) {\n    if (t = +t, r18 = r18 >>> 0, n = n >>> 0, !i) {\n      let u = Math.pow(2, 8 * n) - 1;\n      d2(this, t, r18, n, u, 0);\n    }\n    let o = n - 1, s = 1;\n    for (this[r18 + o] = t & 255; --o >= 0 && (s *= 256); ) this[r18 + o] = t / s & 255;\n    return r18 + n;\n  };\n  a.prototype.writeUint8 = a.prototype.writeUInt8 = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 1, 255, 0), this[r18] = t & 255, r18 + 1;\n  };\n  a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 2, 65535, 0), this[r18] = t & 255, this[r18 + 1] = t >>> 8, r18 + 2;\n  };\n  a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 2, 65535, 0), this[r18] = t >>> 8, this[r18 + 1] = t & 255, r18 + 2;\n  };\n  a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 4, 4294967295, 0), this[r18 + 3] = t >>> 24, this[r18 + 2] = t >>> 16, this[r18 + 1] = t >>> 8, this[r18] = t & 255, r18 + 4;\n  };\n  a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 4, 4294967295, 0), this[r18] = t >>> 24, this[r18 + 1] = t >>> 16, this[r18 + 2] = t >>> 8, this[r18 + 3] = t & 255, r18 + 4;\n  };\n  function or2(e, t, r18, n, i) {\n    fr2(t, n, i, e, r18, 7);\n    let o = Number(t & BigInt(4294967295));\n    e[r18++] = o, o = o >> 8, e[r18++] = o, o = o >> 8, e[r18++] = o, o = o >> 8, e[r18++] = o;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r18++] = s, s = s >> 8, e[r18++] = s, s = s >> 8, e[r18++] = s, s = s >> 8, e[r18++] = s, r18;\n  }\n  function sr2(e, t, r18, n, i) {\n    fr2(t, n, i, e, r18, 7);\n    let o = Number(t & BigInt(4294967295));\n    e[r18 + 7] = o, o = o >> 8, e[r18 + 6] = o, o = o >> 8, e[r18 + 5] = o, o = o >> 8, e[r18 + 4] = o;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r18 + 3] = s, s = s >> 8, e[r18 + 2] = s, s = s >> 8, e[r18 + 1] = s, s = s >> 8, e[r18] = s, r18 + 8;\n  }\n  a.prototype.writeBigUInt64LE = L(function(t, r18 = 0) {\n    return or2(this, t, r18, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n  a.prototype.writeBigUInt64BE = L(function(t, r18 = 0) {\n    return sr2(this, t, r18, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  });\n  a.prototype.writeIntLE = function(t, r18, n, i) {\n    if (t = +t, r18 = r18 >>> 0, !i) {\n      let h = Math.pow(2, 8 * n - 1);\n      d2(this, t, r18, n, h - 1, -h);\n    }\n    let o = 0, s = 1, u = 0;\n    for (this[r18] = t & 255; ++o < n && (s *= 256); ) t < 0 && u === 0 && this[r18 + o - 1] !== 0 && (u = 1), this[r18 + o] = (t / s >> 0) - u & 255;\n    return r18 + n;\n  };\n  a.prototype.writeIntBE = function(t, r18, n, i) {\n    if (t = +t, r18 = r18 >>> 0, !i) {\n      let h = Math.pow(2, 8 * n - 1);\n      d2(this, t, r18, n, h - 1, -h);\n    }\n    let o = n - 1, s = 1, u = 0;\n    for (this[r18 + o] = t & 255; --o >= 0 && (s *= 256); ) t < 0 && u === 0 && this[r18 + o + 1] !== 0 && (u = 1), this[r18 + o] = (t / s >> 0) - u & 255;\n    return r18 + n;\n  };\n  a.prototype.writeInt8 = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r18] = t & 255, r18 + 1;\n  };\n  a.prototype.writeInt16LE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 2, 32767, -32768), this[r18] = t & 255, this[r18 + 1] = t >>> 8, r18 + 2;\n  };\n  a.prototype.writeInt16BE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 2, 32767, -32768), this[r18] = t >>> 8, this[r18 + 1] = t & 255, r18 + 2;\n  };\n  a.prototype.writeInt32LE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 4, 2147483647, -2147483648), this[r18] = t & 255, this[r18 + 1] = t >>> 8, this[r18 + 2] = t >>> 16, this[r18 + 3] = t >>> 24, r18 + 4;\n  };\n  a.prototype.writeInt32BE = function(t, r18, n) {\n    return t = +t, r18 = r18 >>> 0, n || d2(this, t, r18, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r18] = t >>> 24, this[r18 + 1] = t >>> 16, this[r18 + 2] = t >>> 8, this[r18 + 3] = t & 255, r18 + 4;\n  };\n  a.prototype.writeBigInt64LE = L(function(t, r18 = 0) {\n    return or2(this, t, r18, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n  a.prototype.writeBigInt64BE = L(function(t, r18 = 0) {\n    return sr2(this, t, r18, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  });\n  function ar2(e, t, r18, n, i, o) {\n    if (r18 + n > e.length) throw new RangeError(\"Index out of range\");\n    if (r18 < 0) throw new RangeError(\"Index out of range\");\n  }\n  function ur2(e, t, r18, n, i) {\n    return t = +t, r18 = r18 >>> 0, i || ar2(e, t, r18, 4, 34028234663852886e22, -34028234663852886e22), H2.write(e, t, r18, n, 23, 4), r18 + 4;\n  }\n  a.prototype.writeFloatLE = function(t, r18, n) {\n    return ur2(this, t, r18, true, n);\n  };\n  a.prototype.writeFloatBE = function(t, r18, n) {\n    return ur2(this, t, r18, false, n);\n  };\n  function hr2(e, t, r18, n, i) {\n    return t = +t, r18 = r18 >>> 0, i || ar2(e, t, r18, 8, 17976931348623157e292, -17976931348623157e292), H2.write(e, t, r18, n, 52, 8), r18 + 8;\n  }\n  a.prototype.writeDoubleLE = function(t, r18, n) {\n    return hr2(this, t, r18, true, n);\n  };\n  a.prototype.writeDoubleBE = function(t, r18, n) {\n    return hr2(this, t, r18, false, n);\n  };\n  a.prototype.copy = function(t, r18, n, i) {\n    if (!a.isBuffer(t)) throw new TypeError(\"argument should be a Buffer\");\n    if (n || (n = 0), !i && i !== 0 && (i = this.length), r18 >= t.length && (r18 = t.length), r18 || (r18 = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0) return 0;\n    if (r18 < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (n < 0 || n >= this.length) throw new RangeError(\"Index out of range\");\n    if (i < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    i > this.length && (i = this.length), t.length - r18 < i - n && (i = t.length - r18 + n);\n    let o = i - n;\n    return this === t && typeof Uint8Array.prototype.copyWithin == \"function\" ? this.copyWithin(r18, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r18), o;\n  };\n  a.prototype.fill = function(t, r18, n, i) {\n    if (typeof t == \"string\") {\n      if (typeof r18 == \"string\" ? (i = r18, r18 = 0, n = this.length) : typeof n == \"string\" && (i = n, n = this.length), i !== void 0 && typeof i != \"string\") throw new TypeError(\"encoding must be a string\");\n      if (typeof i == \"string\" && !a.isEncoding(i)) throw new TypeError(\"Unknown encoding: \" + i);\n      if (t.length === 1) {\n        let s = t.charCodeAt(0);\n        (i === \"utf8\" && s < 128 || i === \"latin1\") && (t = s);\n      }\n    } else typeof t == \"number\" ? t = t & 255 : typeof t == \"boolean\" && (t = Number(t));\n    if (r18 < 0 || this.length < r18 || this.length < n) throw new RangeError(\"Out of range index\");\n    if (n <= r18) return this;\n    r18 = r18 >>> 0, n = n === void 0 ? this.length : n >>> 0, t || (t = 0);\n    let o;\n    if (typeof t == \"number\") for (o = r18; o < n; ++o) this[o] = t;\n    else {\n      let s = a.isBuffer(t) ? t : a.from(t, i), u = s.length;\n      if (u === 0) throw new TypeError('The value \"' + t + '\" is invalid for argument \"value\"');\n      for (o = 0; o < n - r18; ++o) this[o + r18] = s[o % u];\n    }\n    return this;\n  };\n  var K2 = {};\n  function St2(e, t, r18) {\n    K2[e] = class extends r18 {\n      constructor() {\n        super(), Object.defineProperty(this, \"message\", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;\n      }\n      get code() {\n        return e;\n      }\n      set code(i) {\n        Object.defineProperty(this, \"code\", { configurable: true, enumerable: true, value: i, writable: true });\n      }\n      toString() {\n        return `${this.name} [${e}]: ${this.message}`;\n      }\n    };\n  }\n  St2(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(e) {\n    return e ? `${e} is outside of buffer bounds` : \"Attempt to access memory outside buffer bounds\";\n  }, RangeError);\n  St2(\"ERR_INVALID_ARG_TYPE\", function(e, t) {\n    return `The \"${e}\" argument must be of type number. Received type ${typeof t}`;\n  }, TypeError);\n  St2(\"ERR_OUT_OF_RANGE\", function(e, t, r18) {\n    let n = `The value of \"${e}\" is out of range.`, i = r18;\n    return Number.isInteger(r18) && Math.abs(r18) > 2 ** 32 ? i = Qt2(String(r18)) : typeof r18 == \"bigint\" && (i = String(r18), (r18 > BigInt(2) ** BigInt(32) || r18 < -(BigInt(2) ** BigInt(32))) && (i = Qt2(i)), i += \"n\"), n += ` It must be ${t}. Received ${i}`, n;\n  }, RangeError);\n  function Qt2(e) {\n    let t = \"\", r18 = e.length, n = e[0] === \"-\" ? 1 : 0;\n    for (; r18 >= n + 4; r18 -= 3) t = `_${e.slice(r18 - 3, r18)}${t}`;\n    return `${e.slice(0, r18)}${t}`;\n  }\n  function ae2(e, t, r18) {\n    j2(t, \"offset\"), (e[t] === void 0 || e[t + r18] === void 0) && W(t, e.length - (r18 + 1));\n  }\n  function fr2(e, t, r18, n, i, o) {\n    if (e > r18 || e < t) {\n      let s = typeof t == \"bigint\" ? \"n\" : \"\", u;\n      throw o > 3 ? t === 0 || t === BigInt(0) ? u = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : u = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : u = `>= ${t}${s} and <= ${r18}${s}`, new K2.ERR_OUT_OF_RANGE(\"value\", u, e);\n    }\n    ae2(n, i, o);\n  }\n  function j2(e, t) {\n    if (typeof e != \"number\") throw new K2.ERR_INVALID_ARG_TYPE(t, \"number\", e);\n  }\n  function W(e, t, r18) {\n    throw Math.floor(e) !== e ? (j2(e, r18), new K2.ERR_OUT_OF_RANGE(r18 || \"offset\", \"an integer\", e)) : t < 0 ? new K2.ERR_BUFFER_OUT_OF_BOUNDS() : new K2.ERR_OUT_OF_RANGE(r18 || \"offset\", `>= ${r18 ? 1 : 0} and <= ${t}`, e);\n  }\n  var ue2 = /[^+/0-9A-Za-z-_]/g;\n  function he2(e) {\n    if (e = e.split(\"=\")[0], e = e.trim().replace(ue2, \"\"), e.length < 2) return \"\";\n    for (; e.length % 4 !== 0; ) e = e + \"=\";\n    return e;\n  }\n  function At2(e, t) {\n    t = t || 1 / 0;\n    let r18, n = e.length, i = null, o = [];\n    for (let s = 0; s < n; ++s) {\n      if (r18 = e.charCodeAt(s), r18 > 55295 && r18 < 57344) {\n        if (!i) {\n          if (r18 > 56319) {\n            (t -= 3) > -1 && o.push(239, 191, 189);\n            continue;\n          } else if (s + 1 === n) {\n            (t -= 3) > -1 && o.push(239, 191, 189);\n            continue;\n          }\n          i = r18;\n          continue;\n        }\n        if (r18 < 56320) {\n          (t -= 3) > -1 && o.push(239, 191, 189), i = r18;\n          continue;\n        }\n        r18 = (i - 55296 << 10 | r18 - 56320) + 65536;\n      } else i && (t -= 3) > -1 && o.push(239, 191, 189);\n      if (i = null, r18 < 128) {\n        if ((t -= 1) < 0) break;\n        o.push(r18);\n      } else if (r18 < 2048) {\n        if ((t -= 2) < 0) break;\n        o.push(r18 >> 6 | 192, r18 & 63 | 128);\n      } else if (r18 < 65536) {\n        if ((t -= 3) < 0) break;\n        o.push(r18 >> 12 | 224, r18 >> 6 & 63 | 128, r18 & 63 | 128);\n      } else if (r18 < 1114112) {\n        if ((t -= 4) < 0) break;\n        o.push(r18 >> 18 | 240, r18 >> 12 & 63 | 128, r18 >> 6 & 63 | 128, r18 & 63 | 128);\n      } else throw new Error(\"Invalid code point\");\n    }\n    return o;\n  }\n  function fe2(e) {\n    let t = [];\n    for (let r18 = 0; r18 < e.length; ++r18) t.push(e.charCodeAt(r18) & 255);\n    return t;\n  }\n  function ce2(e, t) {\n    let r18, n, i, o = [];\n    for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) r18 = e.charCodeAt(s), n = r18 >> 8, i = r18 % 256, o.push(i), o.push(n);\n    return o;\n  }\n  function cr2(e) {\n    return Bt2.toByteArray(he2(e));\n  }\n  function et2(e, t, r18, n) {\n    let i;\n    for (i = 0; i < n && !(i + r18 >= t.length || i >= e.length); ++i) t[i + r18] = e[i];\n    return i;\n  }\n  function A(e, t) {\n    return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;\n  }\n  function Ut2(e) {\n    return e !== e;\n  }\n  var pe2 = function() {\n    let e = \"0123456789abcdef\", t = new Array(256);\n    for (let r18 = 0; r18 < 16; ++r18) {\n      let n = r18 * 16;\n      for (let i = 0; i < 16; ++i) t[n + i] = e[r18] + e[i];\n    }\n    return t;\n  }();\n  function L(e) {\n    return typeof BigInt > \"u\" ? le2 : e;\n  }\n  function le2() {\n    throw new Error(\"BigInt not supported\");\n  }\n});\nvar pr2 = T2((Je2, Ft2) => {\n  typeof window < \"u\" ? (window.global = window, global.fetch = window.fetch, Ft2.exports = { Buffer: nt2().Buffer, Crypto: window.crypto }) : Ft2.exports = { Buffer: nt2().Buffer, Crypto: crypto };\n});\nvar Lt2 = {};\nAr2(Lt2, { AVSCTap: () => $2, ArweaveSigner: () => N2, DataItem: () => _2, MAX_TAG_BYTES: () => tt2, MIN_BINARY_SIZE: () => gr2, SIG_CONFIG: () => P2, SignatureConfig: () => B, Signer: () => ot2, createData: () => ge2, deserializeTags: () => Q, indexToType: () => wt2, serializeTags: () => dt2, tagsExceedLimit: () => jr2 });\nvar ot2 = class {\n  signer;\n  publicKey;\n  signatureType;\n  signatureLength;\n  ownerLength;\n  pem;\n  static verify(t, r18, n, i) {\n    throw new Error(\"You must implement verify method on child\");\n  }\n};\nvar vt2 = C(z3(), 1);\nvar w2 = C(pt2(), 1);\nasync function X2(e) {\n  if (Array.isArray(e)) {\n    let i = (0, w2.concatBuffers)([(0, w2.stringToBuffer)(\"list\"), (0, w2.stringToBuffer)(e.length.toString())]);\n    return await Gt2(e, await x2().hash(i, \"SHA-384\"));\n  }\n  let t = e, r18 = (0, w2.concatBuffers)([(0, w2.stringToBuffer)(\"blob\"), (0, w2.stringToBuffer)(t.byteLength.toString())]), n = (0, w2.concatBuffers)([await x2().hash(r18, \"SHA-384\"), await x2().hash(t, \"SHA-384\")]);\n  return await x2().hash(n, \"SHA-384\");\n}\nasync function Gt2(e, t) {\n  if (e.length < 1) return t;\n  let r18 = (0, w2.concatBuffers)([t, await X2(e[0])]), n = await x2().hash(r18, \"SHA-384\");\n  return await Gt2(e.slice(1), n);\n}\nvar Z2 = C(Yt(), 1);\nvar $r2 = Z2.default.default ? Z2.default.default : Z2.default;\nvar yt2 = class extends $r2 {\n  getPublicKey(t) {\n    throw new Error(\"Unimplemented\");\n  }\n};\nvar Kr2;\nfunction x2() {\n  return Kr2 ??= new yt2();\n}\nvar B;\n(function(e) {\n  e[e.ARWEAVE = 1] = \"ARWEAVE\", e[e.ED25519 = 2] = \"ED25519\", e[e.ETHEREUM = 3] = \"ETHEREUM\", e[e.SOLANA = 4] = \"SOLANA\", e[e.INJECTEDAPTOS = 5] = \"INJECTEDAPTOS\", e[e.MULTIAPTOS = 6] = \"MULTIAPTOS\", e[e.TYPEDETHEREUM = 7] = \"TYPEDETHEREUM\";\n})(B || (B = {}));\nvar P2 = { [B.ARWEAVE]: { sigLength: 512, pubLength: 512, sigName: \"arweave\" }, [B.ED25519]: { sigLength: 64, pubLength: 32, sigName: \"ed25519\" }, [B.ETHEREUM]: { sigLength: 65, pubLength: 65, sigName: \"ethereum\" }, [B.SOLANA]: { sigLength: 64, pubLength: 32, sigName: \"solana\" }, [B.INJECTEDAPTOS]: { sigLength: 64, pubLength: 32, sigName: \"injectedAptos\" }, [B.MULTIAPTOS]: { sigLength: 64 * 32 + 4, pubLength: 32 * 32 + 1, sigName: \"multiAptos\" }, [B.TYPEDETHEREUM]: { sigLength: 65, pubLength: 42, sigName: \"typedEthereum\" } };\nvar N2 = class {\n  signatureType = 1;\n  ownerLength = P2[1].pubLength;\n  signatureLength = P2[1].sigLength;\n  jwk;\n  pk;\n  constructor(t) {\n    this.pk = t.n, this.jwk = t;\n  }\n  get publicKey() {\n    return vt2.default.toBuffer(this.pk);\n  }\n  sign(t) {\n    return x2().sign(this.jwk, t);\n  }\n  static async verify(t, r18, n) {\n    return await x2().verify(t, r18, n);\n  }\n};\nvar wt2 = { 1: N2 };\nvar E2 = C(z3(), 1);\nasync function v(e) {\n  return X2([(0, w2.stringToBuffer)(\"dataitem\"), (0, w2.stringToBuffer)(\"1\"), (0, w2.stringToBuffer)(e.signatureType.toString()), e.rawOwner, e.rawTarget, e.rawAnchor, e.rawTags, e.rawData]);\n}\nasync function Hr2(e, t) {\n  let r18 = await v(e), n = await t.sign(r18), i = await x2().hash(n);\n  return { signature: Buffer.from(n), id: Buffer.from(i) };\n}\nasync function Wt2(e, t) {\n  let { signature: r18, id: n } = await Hr2(e, t);\n  return e.getRaw().set(r18, 2), n;\n}\nvar $2 = class {\n  buf;\n  pos;\n  constructor(t = Buffer.alloc(tt2), r18 = 0) {\n    this.buf = t, this.pos = r18;\n  }\n  writeTags(t) {\n    if (!Array.isArray(t)) throw new Error(\"input must be array\");\n    let r18 = t.length, n;\n    if (r18) for (this.writeLong(r18), n = 0; n < r18; n++) {\n      let i = t[n];\n      if (i?.name === void 0 || i?.value === void 0) throw new Error(`Invalid tag format for ${i}, expected {name:string, value: string}`);\n      this.writeString(i.name), this.writeString(i.value);\n    }\n    this.writeLong(0);\n  }\n  toBuffer() {\n    let t = Buffer.alloc(this.pos);\n    if (this.pos > this.buf.length) throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);\n    return this.buf.copy(t, 0, 0, this.pos), t;\n  }\n  tagsExceedLimit() {\n    return this.pos > this.buf.length;\n  }\n  writeLong(t) {\n    let r18 = this.buf, n, i;\n    if (t >= -1073741824 && t < 1073741824) {\n      i = t >= 0 ? t << 1 : ~t << 1 | 1;\n      do\n        r18[this.pos] = i & 127, i >>= 7;\n      while (i && (r18[this.pos++] |= 128));\n    } else {\n      n = t >= 0 ? t * 2 : -t * 2 - 1;\n      do\n        r18[this.pos] = n & 127, n /= 128;\n      while (n >= 1 && (r18[this.pos++] |= 128));\n    }\n    this.pos++, this.buf = r18;\n  }\n  writeString(t) {\n    let r18 = Buffer.byteLength(t), n = this.buf;\n    this.writeLong(r18);\n    let i = this.pos;\n    if (this.pos += r18, !(this.pos > n.length)) {\n      if (r18 > 64) this.buf.write(t, this.pos - r18, r18, \"utf8\");\n      else {\n        let o, s, u, h;\n        for (o = 0, s = r18; o < s; o++) u = t.charCodeAt(o), u < 128 ? n[i++] = u : u < 2048 ? (n[i++] = u >> 6 | 192, n[i++] = u & 63 | 128) : (u & 64512) === 55296 && ((h = t.charCodeAt(o + 1)) & 64512) === 56320 ? (u = 65536 + ((u & 1023) << 10) + (h & 1023), o++, n[i++] = u >> 18 | 240, n[i++] = u >> 12 & 63 | 128, n[i++] = u >> 6 & 63 | 128, n[i++] = u & 63 | 128) : (n[i++] = u >> 12 | 224, n[i++] = u >> 6 & 63 | 128, n[i++] = u & 63 | 128);\n      }\n      this.buf = n;\n    }\n  }\n  readLong() {\n    let t = 0, r18 = 0, n = this.buf, i, o, s, u;\n    do\n      i = n[this.pos++], o = i & 128, t |= (i & 127) << r18, r18 += 7;\n    while (o && r18 < 28);\n    if (o) {\n      s = t, u = 268435456;\n      do\n        i = n[this.pos++], s += (i & 127) * u, u *= 128;\n      while (i & 128);\n      return (s % 2 ? -(s + 1) : s) / 2;\n    }\n    return t >> 1 ^ -(t & 1);\n  }\n  skipLong() {\n    let t = this.buf;\n    for (; t[this.pos++] & 128; ) ;\n  }\n  readTags() {\n    let t = [], r18;\n    for (; r18 = this.readLong(); ) for (r18 < 0 && (r18 = -r18, this.skipLong()); r18--; ) {\n      let n = this.readString(), i = this.readString();\n      t.push({ name: n, value: i });\n    }\n    return t;\n  }\n  readString() {\n    let t = this.readLong(), r18 = this.pos, n = this.buf;\n    if (this.pos += t, !(this.pos > n.length)) return this.buf.slice(r18, r18 + t).toString();\n  }\n};\nfunction dt2(e) {\n  let t = new $2();\n  return t.writeTags(e), t.toBuffer();\n}\nfunction jr2(e) {\n  let t = new $2();\n  return t.writeTags(e), t.tagsExceedLimit();\n}\nfunction Q(e) {\n  return new $2(e).readTags();\n}\nfunction I(e) {\n  let t = 0;\n  for (let r18 = e.length - 1; r18 >= 0; r18--) t = t * 256 + e[r18];\n  return t;\n}\nfunction Vt2(e) {\n  if (e > (2 ^ 32 - 1)) throw new Error(\"Short too long\");\n  let t = [0, 0];\n  for (let r18 = 0; r18 < t.length; r18++) {\n    let n = e & 255;\n    t[r18] = n, e = (e - n) / 256;\n  }\n  return Uint8Array.from(t);\n}\nfunction xt2(e) {\n  let t = [0, 0, 0, 0, 0, 0, 0, 0];\n  for (let r18 = 0; r18 < t.length; r18++) {\n    let n = e & 255;\n    t[r18] = n, e = (e - n) / 256;\n  }\n  return Uint8Array.from(t);\n}\nvar lr2 = C(pr2(), 1);\nvar M2 = C(nt2(), 1);\nvar tt2 = 4096;\nvar gr2 = 80;\nvar _2 = class {\n  binary;\n  _id;\n  constructor(t) {\n    this.binary = t;\n  }\n  static isDataItem(t) {\n    return t.binary !== void 0;\n  }\n  get signatureType() {\n    let t = I(this.binary.subarray(0, 2));\n    if (B?.[t] !== void 0) return t;\n    throw new Error(\"Unknown signature type: \" + t);\n  }\n  async isValid() {\n    return _2.verify(this.binary);\n  }\n  get id() {\n    return (async () => E2.default.encode(await this.rawId))();\n  }\n  set id(t) {\n    this._id = E2.default.toBuffer(t);\n  }\n  get rawId() {\n    return (async () => M2.Buffer.from(await lr2.Crypto.subtle.digest(\"SHA-256\", this.rawSignature)))();\n  }\n  set rawId(t) {\n    this._id = t;\n  }\n  get rawSignature() {\n    return this.binary.subarray(2, 2 + this.signatureLength);\n  }\n  get signature() {\n    return E2.default.encode(this.rawSignature);\n  }\n  set rawOwner(t) {\n    if (t.byteLength != this.ownerLength) throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t.byteLength} bytes.`);\n    this.binary.set(t, 2 + this.signatureLength);\n  }\n  get rawOwner() {\n    return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);\n  }\n  get signatureLength() {\n    return P2[this.signatureType].sigLength;\n  }\n  get owner() {\n    return E2.default.encode(this.rawOwner);\n  }\n  get ownerLength() {\n    return P2[this.signatureType].pubLength;\n  }\n  get rawTarget() {\n    let t = this.getTargetStart();\n    return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M2.Buffer.alloc(0);\n  }\n  get target() {\n    return E2.default.encode(this.rawTarget);\n  }\n  get rawAnchor() {\n    let t = this.getAnchorStart();\n    return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M2.Buffer.alloc(0);\n  }\n  get anchor() {\n    return this.rawAnchor.toString();\n  }\n  get rawTags() {\n    let t = this.getTagsStart(), r18 = I(this.binary.subarray(t + 8, t + 16));\n    return this.binary.subarray(t + 16, t + 16 + r18);\n  }\n  get tags() {\n    let t = this.getTagsStart();\n    if (I(this.binary.subarray(t, t + 8)) == 0) return [];\n    let n = I(this.binary.subarray(t + 8, t + 16));\n    return Q(M2.Buffer.from(this.binary.subarray(t + 16, t + 16 + n)));\n  }\n  get tagsB64Url() {\n    return this.tags.map((r18) => ({ name: E2.default.encode(r18.name), value: E2.default.encode(r18.value) }));\n  }\n  getStartOfData() {\n    let t = this.getTagsStart(), r18 = this.binary.subarray(t + 8, t + 16), n = I(r18);\n    return t + 16 + n;\n  }\n  get rawData() {\n    let t = this.getTagsStart(), r18 = this.binary.subarray(t + 8, t + 16), n = I(r18), i = t + 16 + n;\n    return this.binary.subarray(i, this.binary.length);\n  }\n  get data() {\n    return E2.default.encode(this.rawData);\n  }\n  getRaw() {\n    return this.binary;\n  }\n  async sign(t) {\n    return this._id = await Wt2(this, t), this.rawId;\n  }\n  async setSignature(t) {\n    this.binary.set(t, 2), this._id = M2.Buffer.from(await x2().hash(t));\n  }\n  isSigned() {\n    return (this._id?.length ?? 0) > 0;\n  }\n  toJSON() {\n    return { signature: this.signature, owner: this.owner, target: this.target, tags: this.tags.map((t) => ({ name: E2.default.encode(t.name), value: E2.default.encode(t.value) })), data: this.data };\n  }\n  static async verify(t) {\n    if (t.byteLength < gr2) return false;\n    let r18 = new _2(t), n = r18.signatureType, i = r18.getTagsStart(), o = I(t.subarray(i, i + 8)), s = t.subarray(i + 8, i + 16), u = I(s);\n    if (u > tt2) return false;\n    if (o > 0) try {\n      if (Q(M2.Buffer.from(t.subarray(i + 16, i + 16 + u))).length !== o) return false;\n    } catch {\n      return false;\n    }\n    let h = wt2[n], p2 = await v(r18);\n    return await h.verify(r18.rawOwner, p2, r18.rawSignature);\n  }\n  async getSignatureData() {\n    return v(this);\n  }\n  getTagsStart() {\n    let t = this.getTargetStart(), r18 = this.binary[t] == 1, n = t + (r18 ? 33 : 1), i = this.binary[n] == 1;\n    return n += i ? 33 : 1, n;\n  }\n  getTargetStart() {\n    return 2 + this.signatureLength + this.ownerLength;\n  }\n  getAnchorStart() {\n    let t = this.getTargetStart() + 1, r18 = this.binary[this.getTargetStart()] == 1;\n    return t += r18 ? 32 : 0, t;\n  }\n};\nvar yr2 = C(z3(), 1);\nfunction ge2(e, t, r18) {\n  let n = t.publicKey, i = r18?.target ? yr2.default.toBuffer(r18.target) : null, o = 1 + (i?.byteLength ?? 0), s = r18?.anchor ? Buffer.from(r18.anchor) : null, u = 1 + (s?.byteLength ?? 0), h = (r18?.tags?.length ?? 0) > 0 ? dt2(r18.tags) : null, p2 = 16 + (h ? h.byteLength : 0), f2 = Buffer.from(e), c2 = f2.byteLength, U2 = 2 + t.signatureLength + t.ownerLength + o + u + p2 + c2, l = Buffer.alloc(U2);\n  if (l.set(Vt2(t.signatureType), 0), l.set(new Uint8Array(t.signatureLength).fill(0), 2), n.byteLength !== t.ownerLength) throw new Error(`Owner must be ${t.ownerLength} bytes, but was incorrectly ${n.byteLength}`);\n  l.set(n, 2 + t.signatureLength);\n  let R2 = 2 + t.signatureLength + t.ownerLength;\n  if (l[R2] = i ? 1 : 0, i) {\n    if (i.byteLength !== 32) throw new Error(`Target must be 32 bytes but was incorrectly ${i.byteLength}`);\n    l.set(i, R2 + 1);\n  }\n  let G2 = R2 + o, Y2 = G2 + 1;\n  if (l[G2] = s ? 1 : 0, s) {\n    if (Y2 += s.byteLength, s.byteLength !== 32) throw new Error(\"Anchor must be 32 bytes\");\n    l.set(s, G2 + 1);\n  }\n  l.set(xt2(r18?.tags?.length ?? 0), Y2);\n  let wr2 = xt2(h?.byteLength ?? 0);\n  l.set(wr2, Y2 + 8), h && l.set(h, Y2 + 16);\n  let dr2 = Y2 + p2;\n  return l.set(f2, dr2), new _2(l);\n}\nvar _t2 = { ...Lt2 };\nglobalThis.arbundles ??= _t2;\nvar wn2 = _t2;\nvar dn2 = _t2;\n\n// src/client/browser/wallet.js\nif (!globalThis.Buffer) globalThis.Buffer = import_buffer.Buffer;\nvar { DataItem } = bundle_exports;\nfunction createDataItemSigner(arweaveWallet) {\n  const signer = async ({ data, tags, target, anchor, createDataItem = (buf) => new DataItem(buf) }) => {\n    const view = await arweaveWallet.signDataItem({ data, tags, target, anchor });\n    const dataItem = createDataItem(import_buffer.Buffer.from(view));\n    return {\n      id: await dataItem.id,\n      raw: await dataItem.getRaw()\n    };\n  };\n  return signer;\n}\n\n// src/index.browser.js\nvar GATEWAY_URL = globalThis.GATEWAY_URL || void 0;\nvar MU_URL = globalThis.MU_URL || void 0;\nvar CU_URL = globalThis.CU_URL || void 0;\nvar GRAPHQL_URL = globalThis.GRAPHQL_URL || void 0;\nvar GRAPHQL_MAX_RETRIES = globalThis.GRAPHQL_MAX_RETRIES || void 0;\nvar GRAPHQL_RETRY_BACKOFF = globalThis.GRAPHQL_RETRY_BACKOFF || void 0;\nvar { result, results, message, spawn, monitor, unmonitor, dryrun, assign } = connect({ GATEWAY_URL, MU_URL, CU_URL, GRAPHQL_URL, GRAPHQL_MAX_RETRIES, GRAPHQL_RETRY_BACKOFF });\nvar createDataItemSigner2 = wallet_exports.createDataItemSigner;\n\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n\nwarp-arbundles/build/web/esm/bundle.js:\n  (*! Bundled license information:\n  \n  ieee754/index.js:\n    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n  \n  buffer/index.js:\n    (*!\n     * The buffer module from node.js, for the browser.\n     *\n     * @author   Feross Aboukhadijeh <https://feross.org>\n     * @license  MIT\n     *)\n  *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlcm1hd2ViL2FvY29ubmVjdC9kaXN0L2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa1lBQWtZO0FBQzVZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQWtEO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBaUQ7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBOEM7QUFDMUU7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBLDRCQUE0QixpREFBaUQ7QUFDN0U7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBK0M7QUFDM0U7QUFDQTtBQUNBLDRCQUE0QixpREFBaUQ7QUFDN0U7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBNEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFtRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUJBQXVCLHNCQUFzQixjQUFjO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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QXVCLHVDQUF1QztBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0MsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQyxzQkFBc0I7QUFDNUQsa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xELGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0NBQXdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixhQUFhO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxXQUFXO0FBQ2pCO0FBQ0EsMEJBQTBCLHlFQUF5RTtBQUNuRyxvREFBb0QsNEJBQTRCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNFQUFzRSxZQUFZLHNGQUFzRjtBQUM5SztBQWFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcREVMTFxcRGVza3RvcFxcYXJ3ZWF2ZS1oaFxcZHVtZHVtYmlyZFxcbm9kZV9tb2R1bGVzXFxAcGVybWF3ZWJcXGFvY29ubmVjdFxcZGlzdFxcYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xuXG4vLyBub2RlX21vZHVsZXMvb2JsaXRlcmF0b3IvaXRlcmF0b3IuanNcbnZhciByZXF1aXJlX2l0ZXJhdG9yID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL29ibGl0ZXJhdG9yL2l0ZXJhdG9yLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0ICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ibGl0ZXJhdG9yL2l0ZXJhdG9yOiBleHBlY3RpbmcgYSBmdW5jdGlvbiFcIik7XG4gICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIEl0ZXJhdG9yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICBJdGVyYXRvci5vZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGwgPSBhcmdzLmxlbmd0aCwgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaSA+PSBsKSByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYXJnc1tpKytdIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH07XG4gICAgSXRlcmF0b3IuZnJvbVNlcXVlbmNlID0gZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgICAgIHZhciBpID0gMCwgbCA9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpID49IGwpIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzZXF1ZW5jZVtpKytdIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yLmlzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEl0ZXJhdG9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLm5leHQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gSXRlcmF0b3I7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvb2JsaXRlcmF0b3Ivc3VwcG9ydC5qc1xudmFyIHJlcXVpcmVfc3VwcG9ydCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9vYmxpdGVyYXRvci9zdXBwb3J0LmpzXCIoZXhwb3J0cykge1xuICAgIGV4cG9ydHMuQVJSQVlfQlVGRkVSX1NVUFBPUlQgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgZXhwb3J0cy5TWU1CT0xfU1VQUE9SVCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCI7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvb2JsaXRlcmF0b3IvZm9yZWFjaC5qc1xudmFyIHJlcXVpcmVfZm9yZWFjaCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9vYmxpdGVyYXRvci9mb3JlYWNoLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIHN1cHBvcnQgPSByZXF1aXJlX3N1cHBvcnQoKTtcbiAgICB2YXIgQVJSQVlfQlVGRkVSX1NVUFBPUlQgPSBzdXBwb3J0LkFSUkFZX0JVRkZFUl9TVVBQT1JUO1xuICAgIHZhciBTWU1CT0xfU1VQUE9SVCA9IHN1cHBvcnQuU1lNQk9MX1NVUFBPUlQ7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhYmxlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGl0ZXJhdG9yLCBrMiwgaSwgbCwgcztcbiAgICAgIGlmICghaXRlcmFibGUpIHRocm93IG5ldyBFcnJvcihcIm9ibGl0ZXJhdG9yL2ZvckVhY2g6IGludmFsaWQgaXRlcmFibGUuXCIpO1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmxpdGVyYXRvci9mb3JFYWNoOiBleHBlY3RpbmcgYSBjYWxsYmFjay5cIik7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVyYWJsZSkgfHwgQVJSQVlfQlVGRkVSX1NVUFBPUlQgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGl0ZXJhYmxlKSB8fCB0eXBlb2YgaXRlcmFibGUgPT09IFwic3RyaW5nXCIgfHwgaXRlcmFibGUudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikge1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXRlcmFibGUubGVuZ3RoOyBpIDwgbDsgaSsrKSBjYWxsYmFjayhpdGVyYWJsZVtpXSwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUuZm9yRWFjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGl0ZXJhYmxlLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoU1lNQk9MX1NVUFBPUlQgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGl0ZXJhYmxlICYmIHR5cGVvZiBpdGVyYWJsZS5uZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaXRlcmFibGUgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHMgPSBpdGVyYXRvci5uZXh0KCksIHMuZG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKHMudmFsdWUsIGkpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGsyIGluIGl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChpdGVyYWJsZS5oYXNPd25Qcm9wZXJ0eShrMikpIHtcbiAgICAgICAgICBjYWxsYmFjayhpdGVyYWJsZVtrMl0sIGsyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbW5lbW9uaXN0L3V0aWxzL3R5cGVkLWFycmF5cy5qc1xudmFyIHJlcXVpcmVfdHlwZWRfYXJyYXlzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21uZW1vbmlzdC91dGlscy90eXBlZC1hcnJheXMuanNcIihleHBvcnRzKSB7XG4gICAgdmFyIE1BWF84QklUX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA4KSAtIDE7XG4gICAgdmFyIE1BWF8xNkJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgMTYpIC0gMTtcbiAgICB2YXIgTUFYXzMyQklUX0lOVEVHRVIgPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuICAgIHZhciBNQVhfU0lHTkVEXzhCSVRfSU5URUdFUiA9IE1hdGgucG93KDIsIDcpIC0gMTtcbiAgICB2YXIgTUFYX1NJR05FRF8xNkJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgMTUpIC0gMTtcbiAgICB2YXIgTUFYX1NJR05FRF8zMkJJVF9JTlRFR0VSID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcbiAgICBleHBvcnRzLmdldFBvaW50ZXJBcnJheSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IHNpemUgLSAxO1xuICAgICAgaWYgKG1heEluZGV4IDw9IE1BWF84QklUX0lOVEVHRVIpXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgICAgaWYgKG1heEluZGV4IDw9IE1BWF8xNkJJVF9JTlRFR0VSKVxuICAgICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgICBpZiAobWF4SW5kZXggPD0gTUFYXzMyQklUX0lOVEVHRVIpXG4gICAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmlzdDogUG9pbnRlciBBcnJheSBvZiBzaXplID4gNDI5NDk2NzI5NSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2V0U2lnbmVkUG9pbnRlckFycmF5ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIG1heEluZGV4ID0gc2l6ZSAtIDE7XG4gICAgICBpZiAobWF4SW5kZXggPD0gTUFYX1NJR05FRF84QklUX0lOVEVHRVIpXG4gICAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgICBpZiAobWF4SW5kZXggPD0gTUFYX1NJR05FRF8xNkJJVF9JTlRFR0VSKVxuICAgICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICAgIGlmIChtYXhJbmRleCA8PSBNQVhfU0lHTkVEXzMyQklUX0lOVEVHRVIpXG4gICAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2V0TnVtYmVyVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICh2YWx1ZSB8IDApKSB7XG4gICAgICAgIGlmIChNYXRoLnNpZ24odmFsdWUpID09PSAtMSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8PSAxMjcgJiYgdmFsdWUgPj0gLTEyOClcbiAgICAgICAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgICAgICAgaWYgKHZhbHVlIDw9IDMyNzY3ICYmIHZhbHVlID49IC0zMjc2OClcbiAgICAgICAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSA8PSAyNTUpXG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICAgICAgICBpZiAodmFsdWUgPD0gNjU1MzUpXG4gICAgICAgICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgIH07XG4gICAgdmFyIFRZUEVfUFJJT1JJVFkgPSB7XG4gICAgICBVaW50OEFycmF5OiAxLFxuICAgICAgSW50OEFycmF5OiAyLFxuICAgICAgVWludDE2QXJyYXk6IDMsXG4gICAgICBJbnQxNkFycmF5OiA0LFxuICAgICAgVWludDMyQXJyYXk6IDUsXG4gICAgICBJbnQzMkFycmF5OiA2LFxuICAgICAgRmxvYXQzMkFycmF5OiA3LFxuICAgICAgRmxvYXQ2NEFycmF5OiA4XG4gICAgfTtcbiAgICBleHBvcnRzLmdldE1pbmltYWxSZXByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uKGFycmF5LCBnZXR0ZXIpIHtcbiAgICAgIHZhciBtYXhUeXBlID0gbnVsbCwgbWF4UHJpb3JpdHkgPSAwLCBwMiwgdCwgdjIsIGksIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHYyID0gZ2V0dGVyID8gZ2V0dGVyKGFycmF5W2ldKSA6IGFycmF5W2ldO1xuICAgICAgICB0ID0gZXhwb3J0cy5nZXROdW1iZXJUeXBlKHYyKTtcbiAgICAgICAgcDIgPSBUWVBFX1BSSU9SSVRZW3QubmFtZV07XG4gICAgICAgIGlmIChwMiA+IG1heFByaW9yaXR5KSB7XG4gICAgICAgICAgbWF4UHJpb3JpdHkgPSBwMjtcbiAgICAgICAgICBtYXhUeXBlID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFR5cGU7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzVHlwZWRBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IDAsIGksIG8sIGw7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgbGVuZ3RoICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhcnJheS5zZXQoYXJndW1lbnRzW2ldLCBvKTtcbiAgICAgICAgbyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gICAgZXhwb3J0cy5pbmRpY2VzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICB2YXIgUG9pbnRlckFycmF5ID0gZXhwb3J0cy5nZXRQb2ludGVyQXJyYXkobGVuZ3RoKTtcbiAgICAgIHZhciBhcnJheSA9IG5ldyBQb2ludGVyQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gaTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21uZW1vbmlzdC91dGlscy9pdGVyYWJsZXMuanNcbnZhciByZXF1aXJlX2l0ZXJhYmxlcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tbmVtb25pc3QvdXRpbHMvaXRlcmFibGVzLmpzXCIoZXhwb3J0cykge1xuICAgIHZhciBmb3JFYWNoID0gcmVxdWlyZV9mb3JlYWNoKCk7XG4gICAgdmFyIHR5cGVkID0gcmVxdWlyZV90eXBlZF9hcnJheXMoKTtcbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZTIodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpIHx8IHR5cGVkLmlzVHlwZWRBcnJheSh0YXJnZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBndWVzc0xlbmd0aCh0YXJnZXQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0Lmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldC5zaXplID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdGFyZ2V0LnNpemU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQXJyYXkodGFyZ2V0KSB7XG4gICAgICB2YXIgbCA9IGd1ZXNzTGVuZ3RoKHRhcmdldCk7XG4gICAgICB2YXIgYXJyYXkgPSB0eXBlb2YgbCA9PT0gXCJudW1iZXJcIiA/IG5ldyBBcnJheShsKSA6IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yRWFjaCh0YXJnZXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFycmF5W2krK10gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b0FycmF5V2l0aEluZGljZXModGFyZ2V0KSB7XG4gICAgICB2YXIgbCA9IGd1ZXNzTGVuZ3RoKHRhcmdldCk7XG4gICAgICB2YXIgSW5kZXhBcnJheSA9IHR5cGVvZiBsID09PSBcIm51bWJlclwiID8gdHlwZWQuZ2V0UG9pbnRlckFycmF5KGwpIDogQXJyYXk7XG4gICAgICB2YXIgYXJyYXkgPSB0eXBlb2YgbCA9PT0gXCJudW1iZXJcIiA/IG5ldyBBcnJheShsKSA6IFtdO1xuICAgICAgdmFyIGluZGljZXMgPSB0eXBlb2YgbCA9PT0gXCJudW1iZXJcIiA/IG5ldyBJbmRleEFycmF5KGwpIDogW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3JFYWNoKHRhcmdldCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgYXJyYXlbaV0gPSB2YWx1ZTtcbiAgICAgICAgaW5kaWNlc1tpXSA9IGkrKztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFthcnJheSwgaW5kaWNlc107XG4gICAgfVxuICAgIGV4cG9ydHMuaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTI7XG4gICAgZXhwb3J0cy5ndWVzc0xlbmd0aCA9IGd1ZXNzTGVuZ3RoO1xuICAgIGV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgZXhwb3J0cy50b0FycmF5V2l0aEluZGljZXMgPSB0b0FycmF5V2l0aEluZGljZXM7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbW5lbW9uaXN0L2xydS1jYWNoZS5qc1xudmFyIHJlcXVpcmVfbHJ1X2NhY2hlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21uZW1vbmlzdC9scnUtY2FjaGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgSXRlcmF0b3IgPSByZXF1aXJlX2l0ZXJhdG9yKCk7XG4gICAgdmFyIGZvckVhY2ggPSByZXF1aXJlX2ZvcmVhY2goKTtcbiAgICB2YXIgdHlwZWQgPSByZXF1aXJlX3R5cGVkX2FycmF5cygpO1xuICAgIHZhciBpdGVyYWJsZXMgPSByZXF1aXJlX2l0ZXJhYmxlcygpO1xuICAgIGZ1bmN0aW9uIExSVUNhY2hlKEtleXMsIFZhbHVlcywgY2FwYWNpdHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBjYXBhY2l0eSA9IEtleXM7XG4gICAgICAgIEtleXMgPSBudWxsO1xuICAgICAgICBWYWx1ZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhcGFjaXR5ICE9PSBcIm51bWJlclwiIHx8IHRoaXMuY2FwYWNpdHkgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaXN0L2xydS1jYWNoZTogY2FwYWNpdHkgc2hvdWxkIGJlIHBvc2l0aXZlIG51bWJlci5cIik7XG4gICAgICBlbHNlIGlmICghaXNGaW5pdGUodGhpcy5jYXBhY2l0eSkgfHwgTWF0aC5mbG9vcih0aGlzLmNhcGFjaXR5KSAhPT0gdGhpcy5jYXBhY2l0eSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaXN0L2xydS1jYWNoZTogY2FwYWNpdHkgc2hvdWxkIGJlIGEgZmluaXRlIHBvc2l0aXZlIGludGVnZXIuXCIpO1xuICAgICAgdmFyIFBvaW50ZXJBcnJheSA9IHR5cGVkLmdldFBvaW50ZXJBcnJheShjYXBhY2l0eSk7XG4gICAgICB0aGlzLmZvcndhcmQgPSBuZXcgUG9pbnRlckFycmF5KGNhcGFjaXR5KTtcbiAgICAgIHRoaXMuYmFja3dhcmQgPSBuZXcgUG9pbnRlckFycmF5KGNhcGFjaXR5KTtcbiAgICAgIHRoaXMuSyA9IHR5cGVvZiBLZXlzID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgS2V5cyhjYXBhY2l0eSkgOiBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuICAgICAgdGhpcy5WID0gdHlwZW9mIFZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gbmV3IFZhbHVlcyhjYXBhY2l0eSkgOiBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuaGVhZCA9IDA7XG4gICAgICB0aGlzLnRhaWwgPSAwO1xuICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIH1cbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLmhlYWQgPSAwO1xuICAgICAgdGhpcy50YWlsID0gMDtcbiAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5zcGxheU9uVG9wID0gZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdmFyIG9sZEhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICBpZiAodGhpcy5oZWFkID09PSBwb2ludGVyKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuYmFja3dhcmRbcG9pbnRlcl0sIG5leHQgPSB0aGlzLmZvcndhcmRbcG9pbnRlcl07XG4gICAgICBpZiAodGhpcy50YWlsID09PSBwb2ludGVyKSB7XG4gICAgICAgIHRoaXMudGFpbCA9IHByZXZpb3VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYWNrd2FyZFtuZXh0XSA9IHByZXZpb3VzO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3J3YXJkW3ByZXZpb3VzXSA9IG5leHQ7XG4gICAgICB0aGlzLmJhY2t3YXJkW29sZEhlYWRdID0gcG9pbnRlcjtcbiAgICAgIHRoaXMuaGVhZCA9IHBvaW50ZXI7XG4gICAgICB0aGlzLmZvcndhcmRbcG9pbnRlcl0gPSBvbGRIZWFkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLml0ZW1zW2tleV07XG4gICAgICBpZiAodHlwZW9mIHBvaW50ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zcGxheU9uVG9wKHBvaW50ZXIpO1xuICAgICAgICB0aGlzLlZbcG9pbnRlcl0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA8IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuc2l6ZSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy5iYWNrd2FyZFtwb2ludGVyXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaXRlbXNbdGhpcy5LW3BvaW50ZXJdXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXRlbXNba2V5XSA9IHBvaW50ZXI7XG4gICAgICB0aGlzLktbcG9pbnRlcl0gPSBrZXk7XG4gICAgICB0aGlzLlZbcG9pbnRlcl0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZm9yd2FyZFtwb2ludGVyXSA9IHRoaXMuaGVhZDtcbiAgICAgIHRoaXMuYmFja3dhcmRbdGhpcy5oZWFkXSA9IHBvaW50ZXI7XG4gICAgICB0aGlzLmhlYWQgPSBwb2ludGVyO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLnNldHBvcCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICB2YXIgb2xkS2V5ID0gbnVsbDtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5pdGVtc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuc3BsYXlPblRvcChwb2ludGVyKTtcbiAgICAgICAgb2xkVmFsdWUgPSB0aGlzLlZbcG9pbnRlcl07XG4gICAgICAgIHRoaXMuVltwb2ludGVyXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4geyBldmljdGVkOiBmYWxzZSwga2V5LCB2YWx1ZTogb2xkVmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPCB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnNpemUrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnRhaWw7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMuYmFja3dhcmRbcG9pbnRlcl07XG4gICAgICAgIG9sZFZhbHVlID0gdGhpcy5WW3BvaW50ZXJdO1xuICAgICAgICBvbGRLZXkgPSB0aGlzLktbcG9pbnRlcl07XG4gICAgICAgIGRlbGV0ZSB0aGlzLml0ZW1zW29sZEtleV07XG4gICAgICB9XG4gICAgICB0aGlzLml0ZW1zW2tleV0gPSBwb2ludGVyO1xuICAgICAgdGhpcy5LW3BvaW50ZXJdID0ga2V5O1xuICAgICAgdGhpcy5WW3BvaW50ZXJdID0gdmFsdWU7XG4gICAgICB0aGlzLmZvcndhcmRbcG9pbnRlcl0gPSB0aGlzLmhlYWQ7XG4gICAgICB0aGlzLmJhY2t3YXJkW3RoaXMuaGVhZF0gPSBwb2ludGVyO1xuICAgICAgdGhpcy5oZWFkID0gcG9pbnRlcjtcbiAgICAgIGlmIChvbGRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgZXZpY3RlZDogdHJ1ZSwga2V5OiBvbGRLZXksIHZhbHVlOiBvbGRWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4ga2V5IGluIHRoaXMuaXRlbXM7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuaXRlbXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zcGxheU9uVG9wKHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuVltwb2ludGVyXTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuaXRlbXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIHRoaXMuVltwb2ludGVyXTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICBzY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2NvcGUgOiB0aGlzO1xuICAgICAgdmFyIGkgPSAwLCBsID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmhlYWQsIGtleXM0ID0gdGhpcy5LLCB2YWx1ZXMgPSB0aGlzLlYsIGZvcndhcmQgPSB0aGlzLmZvcndhcmQ7XG4gICAgICB3aGlsZSAoaSA8IGwpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSwgdmFsdWVzW3BvaW50ZXJdLCBrZXlzNFtwb2ludGVyXSwgdGhpcyk7XG4gICAgICAgIHBvaW50ZXIgPSBmb3J3YXJkW3BvaW50ZXJdO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSAwLCBsID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmhlYWQsIGtleXM0ID0gdGhpcy5LLCBmb3J3YXJkID0gdGhpcy5mb3J3YXJkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkgPj0gbClcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIHZhciBrZXkgPSBrZXlzNFtwb2ludGVyXTtcbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAoaSA8IGwpXG4gICAgICAgICAgcG9pbnRlciA9IGZvcndhcmRbcG9pbnRlcl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGtleVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IDAsIGwgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuaGVhZCwgdmFsdWVzID0gdGhpcy5WLCBmb3J3YXJkID0gdGhpcy5mb3J3YXJkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkgPj0gbClcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1twb2ludGVyXTtcbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAoaSA8IGwpXG4gICAgICAgICAgcG9pbnRlciA9IGZvcndhcmRbcG9pbnRlcl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gMCwgbCA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5oZWFkLCBrZXlzNCA9IHRoaXMuSywgdmFsdWVzID0gdGhpcy5WLCBmb3J3YXJkID0gdGhpcy5mb3J3YXJkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGkgPj0gbClcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgIHZhciBrZXkgPSBrZXlzNFtwb2ludGVyXSwgdmFsdWUgPSB2YWx1ZXNbcG9pbnRlcl07XG4gICAgICAgIGkrKztcbiAgICAgICAgaWYgKGkgPCBsKVxuICAgICAgICAgIHBvaW50ZXIgPSBmb3J3YXJkW3BvaW50ZXJdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICBMUlVDYWNoZS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IExSVUNhY2hlLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJveHkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5lbnRyaWVzKCksIHN0ZXA7XG4gICAgICB3aGlsZSAoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSwgIXN0ZXAuZG9uZSlcbiAgICAgICAgcHJveHkuc2V0KHN0ZXAudmFsdWVbMF0sIHN0ZXAudmFsdWVbMV0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICAgICAgdmFsdWU6IExSVUNhY2hlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJveHk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIExSVUNhY2hlLnByb3RvdHlwZVtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gTFJVQ2FjaGUucHJvdG90eXBlLmluc3BlY3Q7XG4gICAgTFJVQ2FjaGUuZnJvbSA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBLZXlzLCBWYWx1ZXMsIGNhcGFjaXR5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2FwYWNpdHkgPSBpdGVyYWJsZXMuZ3Vlc3NMZW5ndGgoaXRlcmFibGUpO1xuICAgICAgICBpZiAodHlwZW9mIGNhcGFjaXR5ICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmlzdC9scnUtY2FjaGUuZnJvbTogY291bGQgbm90IGd1ZXNzIGl0ZXJhYmxlIGxlbmd0aC4gUGxlYXNlIHByb3ZpZGUgZGVzaXJlZCBjYXBhY2l0eSBhcyBsYXN0IGFyZ3VtZW50LlwiKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBjYXBhY2l0eSA9IEtleXM7XG4gICAgICAgIEtleXMgPSBudWxsO1xuICAgICAgICBWYWx1ZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGNhY2hlID0gbmV3IExSVUNhY2hlKEtleXMsIFZhbHVlcywgY2FwYWNpdHkpO1xuICAgICAgZm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbW5lbW9uaXN0L2xydS1tYXAuanNcbnZhciByZXF1aXJlX2xydV9tYXAgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbW5lbW9uaXN0L2xydS1tYXAuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgTFJVQ2FjaGUgPSByZXF1aXJlX2xydV9jYWNoZSgpO1xuICAgIHZhciBmb3JFYWNoID0gcmVxdWlyZV9mb3JlYWNoKCk7XG4gICAgdmFyIHR5cGVkID0gcmVxdWlyZV90eXBlZF9hcnJheXMoKTtcbiAgICB2YXIgaXRlcmFibGVzID0gcmVxdWlyZV9pdGVyYWJsZXMoKTtcbiAgICBmdW5jdGlvbiBMUlVNYXAoS2V5cywgVmFsdWVzLCBjYXBhY2l0eSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNhcGFjaXR5ID0gS2V5cztcbiAgICAgICAgS2V5cyA9IG51bGw7XG4gICAgICAgIFZhbHVlcyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY2FwYWNpdHkgIT09IFwibnVtYmVyXCIgfHwgdGhpcy5jYXBhY2l0eSA8PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtbmVtb25pc3QvbHJ1LW1hcDogY2FwYWNpdHkgc2hvdWxkIGJlIHBvc2l0aXZlIG51bWJlci5cIik7XG4gICAgICBlbHNlIGlmICghaXNGaW5pdGUodGhpcy5jYXBhY2l0eSkgfHwgTWF0aC5mbG9vcih0aGlzLmNhcGFjaXR5KSAhPT0gdGhpcy5jYXBhY2l0eSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaXN0L2xydS1tYXA6IGNhcGFjaXR5IHNob3VsZCBiZSBhIGZpbml0ZSBwb3NpdGl2ZSBpbnRlZ2VyLlwiKTtcbiAgICAgIHZhciBQb2ludGVyQXJyYXkgPSB0eXBlZC5nZXRQb2ludGVyQXJyYXkoY2FwYWNpdHkpO1xuICAgICAgdGhpcy5mb3J3YXJkID0gbmV3IFBvaW50ZXJBcnJheShjYXBhY2l0eSk7XG4gICAgICB0aGlzLmJhY2t3YXJkID0gbmV3IFBvaW50ZXJBcnJheShjYXBhY2l0eSk7XG4gICAgICB0aGlzLksgPSB0eXBlb2YgS2V5cyA9PT0gXCJmdW5jdGlvblwiID8gbmV3IEtleXMoY2FwYWNpdHkpIDogbmV3IEFycmF5KGNhcGFjaXR5KTtcbiAgICAgIHRoaXMuViA9IHR5cGVvZiBWYWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBWYWx1ZXMoY2FwYWNpdHkpIDogbmV3IEFycmF5KGNhcGFjaXR5KTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLmhlYWQgPSAwO1xuICAgICAgdGhpcy50YWlsID0gMDtcbiAgICAgIHRoaXMuaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBMUlVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5oZWFkID0gMDtcbiAgICAgIHRoaXMudGFpbCA9IDA7XG4gICAgICB0aGlzLml0ZW1zLmNsZWFyKCk7XG4gICAgfTtcbiAgICBMUlVNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5pdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLnNwbGF5T25Ub3AocG9pbnRlcik7XG4gICAgICAgIHRoaXMuVltwb2ludGVyXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplIDwgdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5zaXplKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludGVyID0gdGhpcy50YWlsO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmJhY2t3YXJkW3BvaW50ZXJdO1xuICAgICAgICB0aGlzLml0ZW1zLmRlbGV0ZSh0aGlzLktbcG9pbnRlcl0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pdGVtcy5zZXQoa2V5LCBwb2ludGVyKTtcbiAgICAgIHRoaXMuS1twb2ludGVyXSA9IGtleTtcbiAgICAgIHRoaXMuVltwb2ludGVyXSA9IHZhbHVlO1xuICAgICAgdGhpcy5mb3J3YXJkW3BvaW50ZXJdID0gdGhpcy5oZWFkO1xuICAgICAgdGhpcy5iYWNrd2FyZFt0aGlzLmhlYWRdID0gcG9pbnRlcjtcbiAgICAgIHRoaXMuaGVhZCA9IHBvaW50ZXI7XG4gICAgfTtcbiAgICBMUlVNYXAucHJvdG90eXBlLnNldHBvcCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICB2YXIgb2xkS2V5ID0gbnVsbDtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5pdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLnNwbGF5T25Ub3AocG9pbnRlcik7XG4gICAgICAgIG9sZFZhbHVlID0gdGhpcy5WW3BvaW50ZXJdO1xuICAgICAgICB0aGlzLlZbcG9pbnRlcl0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgZXZpY3RlZDogZmFsc2UsIGtleSwgdmFsdWU6IG9sZFZhbHVlIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplIDwgdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5zaXplKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludGVyID0gdGhpcy50YWlsO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLmJhY2t3YXJkW3BvaW50ZXJdO1xuICAgICAgICBvbGRWYWx1ZSA9IHRoaXMuVltwb2ludGVyXTtcbiAgICAgICAgb2xkS2V5ID0gdGhpcy5LW3BvaW50ZXJdO1xuICAgICAgICB0aGlzLml0ZW1zLmRlbGV0ZShvbGRLZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pdGVtcy5zZXQoa2V5LCBwb2ludGVyKTtcbiAgICAgIHRoaXMuS1twb2ludGVyXSA9IGtleTtcbiAgICAgIHRoaXMuVltwb2ludGVyXSA9IHZhbHVlO1xuICAgICAgdGhpcy5mb3J3YXJkW3BvaW50ZXJdID0gdGhpcy5oZWFkO1xuICAgICAgdGhpcy5iYWNrd2FyZFt0aGlzLmhlYWRdID0gcG9pbnRlcjtcbiAgICAgIHRoaXMuaGVhZCA9IHBvaW50ZXI7XG4gICAgICBpZiAob2xkS2V5KSB7XG4gICAgICAgIHJldHVybiB7IGV2aWN0ZWQ6IHRydWUsIGtleTogb2xkS2V5LCB2YWx1ZTogb2xkVmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyhrZXkpO1xuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5pdGVtcy5nZXQoa2V5KTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zcGxheU9uVG9wKHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuVltwb2ludGVyXTtcbiAgICB9O1xuICAgIExSVU1hcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLml0ZW1zLmdldChrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludGVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICByZXR1cm4gdGhpcy5WW3BvaW50ZXJdO1xuICAgIH07XG4gICAgTFJVTWFwLnByb3RvdHlwZS5zcGxheU9uVG9wID0gTFJVQ2FjaGUucHJvdG90eXBlLnNwbGF5T25Ub3A7XG4gICAgTFJVTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2g7XG4gICAgTFJVTWFwLnByb3RvdHlwZS5rZXlzID0gTFJVQ2FjaGUucHJvdG90eXBlLmtleXM7XG4gICAgTFJVTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBMUlVDYWNoZS5wcm90b3R5cGUudmFsdWVzO1xuICAgIExSVU1hcC5wcm90b3R5cGUuZW50cmllcyA9IExSVUNhY2hlLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgTFJVTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gTFJVTWFwLnByb3RvdHlwZS5lbnRyaWVzO1xuICAgIExSVU1hcC5wcm90b3R5cGUuaW5zcGVjdCA9IExSVUNhY2hlLnByb3RvdHlwZS5pbnNwZWN0O1xuICAgIExSVU1hcC5mcm9tID0gZnVuY3Rpb24oaXRlcmFibGUsIEtleXMsIFZhbHVlcywgY2FwYWNpdHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBjYXBhY2l0eSA9IGl0ZXJhYmxlcy5ndWVzc0xlbmd0aChpdGVyYWJsZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW5lbW9uaXN0L2xydS1jYWNoZS5mcm9tOiBjb3VsZCBub3QgZ3Vlc3MgaXRlcmFibGUgbGVuZ3RoLiBQbGVhc2UgcHJvdmlkZSBkZXNpcmVkIGNhcGFjaXR5IGFzIGxhc3QgYXJndW1lbnQuXCIpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGNhcGFjaXR5ID0gS2V5cztcbiAgICAgICAgS2V5cyA9IG51bGw7XG4gICAgICAgIFZhbHVlcyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgY2FjaGUgPSBuZXcgTFJVTWFwKEtleXMsIFZhbHVlcywgY2FwYWNpdHkpO1xuICAgICAgZm9yRWFjaChpdGVyYWJsZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gTFJVTWFwO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG52YXIgcmVxdWlyZV9tcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBzID0gMWUzO1xuICAgIHZhciBtMiA9IHMgKiA2MDtcbiAgICB2YXIgaCA9IG0yICogNjA7XG4gICAgdmFyIGQyID0gaCAqIDI0O1xuICAgIHZhciB3MyA9IGQyICogNztcbiAgICB2YXIgeTIgPSBkMiAqIDM2NS4yNTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgdHlwZTMgPSB0eXBlb2YgdmFsO1xuICAgICAgaWYgKHR5cGUzID09PSBcInN0cmluZ1wiICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZTIodmFsKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZTMgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJ2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlMihzdHIpIHtcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgICAgICBzdHJcbiAgICAgICk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICB2YXIgdHlwZTMgPSAobWF0Y2hbMl0gfHwgXCJtc1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoICh0eXBlMykge1xuICAgICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgY2FzZSBcInlyc1wiOlxuICAgICAgICBjYXNlIFwieXJcIjpcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHkyO1xuICAgICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHczO1xuICAgICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBkMjtcbiAgICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgIGNhc2UgXCJocnNcIjpcbiAgICAgICAgY2FzZSBcImhyXCI6XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIG4gKiBoO1xuICAgICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAgIGNhc2UgXCJtaW5zXCI6XG4gICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICByZXR1cm4gbiAqIG0yO1xuICAgICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgIGNhc2UgXCJzZWNzXCI6XG4gICAgICAgIGNhc2UgXCJzZWNcIjpcbiAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICByZXR1cm4gbiAqIHM7XG4gICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICAgIGNhc2UgXCJtc2Vjc1wiOlxuICAgICAgICBjYXNlIFwibXNlY1wiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbXRTaG9ydChtczIpIHtcbiAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zMik7XG4gICAgICBpZiAobXNBYnMgPj0gZDIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMyIC8gZDIpICsgXCJkXCI7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtczIgLyBoKSArIFwiaFwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IG0yKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zMiAvIG0yKSArIFwibVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IHMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMyIC8gcykgKyBcInNcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtczIgKyBcIm1zXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZtdExvbmcobXMyKSB7XG4gICAgICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtczIpO1xuICAgICAgaWYgKG1zQWJzID49IGQyKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMyLCBtc0FicywgZDIsIFwiZGF5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1zQWJzID49IGgpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtczIsIG1zQWJzLCBoLCBcImhvdXJcIik7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gbTIpIHtcbiAgICAgICAgcmV0dXJuIHBsdXJhbChtczIsIG1zQWJzLCBtMiwgXCJtaW51dGVcIik7XG4gICAgICB9XG4gICAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zMiwgbXNBYnMsIHMsIFwic2Vjb25kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1zMiArIFwiIG1zXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBsdXJhbChtczIsIG1zQWJzLCBuLCBuYW1lKSB7XG4gICAgICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMyIC8gbikgKyBcIiBcIiArIG5hbWUgKyAoaXNQbHVyYWwgPyBcInNcIiA6IFwiXCIpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzXG52YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIGZ1bmN0aW9uIHNldHVwKGVudikge1xuICAgICAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgICAgIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgICAgIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTI7XG4gICAgICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlX21zKCk7XG4gICAgICBjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgICAgIH0pO1xuICAgICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gICAgICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBoYXNoIHw9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgICAgICBsZXQgcHJldlRpbWU7XG4gICAgICAgIGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG4gICAgICAgIGxldCBuYW1lc3BhY2VzQ2FjaGU7XG4gICAgICAgIGxldCBlbmFibGVkQ2FjaGU7XG4gICAgICAgIGZ1bmN0aW9uIGRlYnVnMiguLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKCFkZWJ1ZzIuZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzZWxmID0gZGVidWcyO1xuICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpO1xuICAgICAgICAgIGNvbnN0IG1zMiA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICAgICAgc2VsZi5kaWZmID0gbXMyO1xuICAgICAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoXCIlT1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gXCIlJVwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG4gICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICAgICAgY29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcyLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgZGVidWcyLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgICAgICBkZWJ1ZzIuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgICAgICBkZWJ1ZzIuZXh0ZW5kID0gZXh0ZW5kO1xuICAgICAgICBkZWJ1ZzIuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZzIsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmFibGVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcbiAgICAgICAgICAgICAgZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRDYWNoZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogKHYyKSA9PiB7XG4gICAgICAgICAgICBlbmFibGVPdmVycmlkZSA9IHYyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1ZzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWJ1ZzI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgY29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSBcInVuZGVmaW5lZFwiID8gXCI6XCIgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgICAgICAgbmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG4gICAgICAgIHJldHVybiBuZXdEZWJ1ZztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09IFwic3RyaW5nXCIgPyBuYW1lc3BhY2VzIDogXCJcIikuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICAgICAgY29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCBcIi4qP1wiKTtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyBcIiRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lc3BhY2VzICsgXCIkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBbXG4gICAgICAgICAgLi4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcbiAgICAgICAgICAuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcCgobmFtZXNwYWNlKSA9PiBcIi1cIiArIG5hbWVzcGFjZSlcbiAgICAgICAgXS5qb2luKFwiLFwiKTtcbiAgICAgICAgY3JlYXRlRGVidWcuZW5hYmxlKFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlcztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSBcIipcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4cC50b1N0cmluZygpLnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXC5cXCpcXD8kLywgXCIqXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY29lcmNlMih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG52YXIgcmVxdWlyZV9icm93c2VyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICBleHBvcnRzLnNhdmUgPSBzYXZlO1xuICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7XG4gICAgZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG4gICAgZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4gICAgZXhwb3J0cy5kZXN0cm95ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGV4cG9ydHMuY29sb3JzID0gW1xuICAgICAgXCIjMDAwMENDXCIsXG4gICAgICBcIiMwMDAwRkZcIixcbiAgICAgIFwiIzAwMzNDQ1wiLFxuICAgICAgXCIjMDAzM0ZGXCIsXG4gICAgICBcIiMwMDY2Q0NcIixcbiAgICAgIFwiIzAwNjZGRlwiLFxuICAgICAgXCIjMDA5OUNDXCIsXG4gICAgICBcIiMwMDk5RkZcIixcbiAgICAgIFwiIzAwQ0MwMFwiLFxuICAgICAgXCIjMDBDQzMzXCIsXG4gICAgICBcIiMwMENDNjZcIixcbiAgICAgIFwiIzAwQ0M5OVwiLFxuICAgICAgXCIjMDBDQ0NDXCIsXG4gICAgICBcIiMwMENDRkZcIixcbiAgICAgIFwiIzMzMDBDQ1wiLFxuICAgICAgXCIjMzMwMEZGXCIsXG4gICAgICBcIiMzMzMzQ0NcIixcbiAgICAgIFwiIzMzMzNGRlwiLFxuICAgICAgXCIjMzM2NkNDXCIsXG4gICAgICBcIiMzMzY2RkZcIixcbiAgICAgIFwiIzMzOTlDQ1wiLFxuICAgICAgXCIjMzM5OUZGXCIsXG4gICAgICBcIiMzM0NDMDBcIixcbiAgICAgIFwiIzMzQ0MzM1wiLFxuICAgICAgXCIjMzNDQzY2XCIsXG4gICAgICBcIiMzM0NDOTlcIixcbiAgICAgIFwiIzMzQ0NDQ1wiLFxuICAgICAgXCIjMzNDQ0ZGXCIsXG4gICAgICBcIiM2NjAwQ0NcIixcbiAgICAgIFwiIzY2MDBGRlwiLFxuICAgICAgXCIjNjYzM0NDXCIsXG4gICAgICBcIiM2NjMzRkZcIixcbiAgICAgIFwiIzY2Q0MwMFwiLFxuICAgICAgXCIjNjZDQzMzXCIsXG4gICAgICBcIiM5OTAwQ0NcIixcbiAgICAgIFwiIzk5MDBGRlwiLFxuICAgICAgXCIjOTkzM0NDXCIsXG4gICAgICBcIiM5OTMzRkZcIixcbiAgICAgIFwiIzk5Q0MwMFwiLFxuICAgICAgXCIjOTlDQzMzXCIsXG4gICAgICBcIiNDQzAwMDBcIixcbiAgICAgIFwiI0NDMDAzM1wiLFxuICAgICAgXCIjQ0MwMDY2XCIsXG4gICAgICBcIiNDQzAwOTlcIixcbiAgICAgIFwiI0NDMDBDQ1wiLFxuICAgICAgXCIjQ0MwMEZGXCIsXG4gICAgICBcIiNDQzMzMDBcIixcbiAgICAgIFwiI0NDMzMzM1wiLFxuICAgICAgXCIjQ0MzMzY2XCIsXG4gICAgICBcIiNDQzMzOTlcIixcbiAgICAgIFwiI0NDMzNDQ1wiLFxuICAgICAgXCIjQ0MzM0ZGXCIsXG4gICAgICBcIiNDQzY2MDBcIixcbiAgICAgIFwiI0NDNjYzM1wiLFxuICAgICAgXCIjQ0M5OTAwXCIsXG4gICAgICBcIiNDQzk5MzNcIixcbiAgICAgIFwiI0NDQ0MwMFwiLFxuICAgICAgXCIjQ0NDQzMzXCIsXG4gICAgICBcIiNGRjAwMDBcIixcbiAgICAgIFwiI0ZGMDAzM1wiLFxuICAgICAgXCIjRkYwMDY2XCIsXG4gICAgICBcIiNGRjAwOTlcIixcbiAgICAgIFwiI0ZGMDBDQ1wiLFxuICAgICAgXCIjRkYwMEZGXCIsXG4gICAgICBcIiNGRjMzMDBcIixcbiAgICAgIFwiI0ZGMzMzM1wiLFxuICAgICAgXCIjRkYzMzY2XCIsXG4gICAgICBcIiNGRjMzOTlcIixcbiAgICAgIFwiI0ZGMzNDQ1wiLFxuICAgICAgXCIjRkYzM0ZGXCIsXG4gICAgICBcIiNGRjY2MDBcIixcbiAgICAgIFwiI0ZGNjYzM1wiLFxuICAgICAgXCIjRkY5OTAwXCIsXG4gICAgICBcIiNGRjk5MzNcIixcbiAgICAgIFwiI0ZGQ0MwMFwiLFxuICAgICAgXCIjRkZDQzMzXCJcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBtMjtcbiAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCAvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobTIgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSkgJiYgcGFyc2VJbnQobTJbMV0sIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICAgIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyBcIiVjXCIgOiBcIlwiKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gXCIgJWNcIiA6IFwiIFwiKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyBcIiVjIFwiIDogXCIgXCIpICsgXCIrXCIgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuICAgICAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjMiA9IFwiY29sb3I6IFwiICsgdGhpcy5jb2xvcjtcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIGMyLCBcImNvbG9yOiBpbmhlcml0XCIpO1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIGxldCBsYXN0QyA9IDA7XG4gICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gXCIlJVwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gXCIlY1wiKSB7XG4gICAgICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYzIpO1xuICAgIH1cbiAgICBleHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oXCJkZWJ1Z1wiLCBuYW1lc3BhY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbShcImRlYnVnXCIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgbGV0IHIxODtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIxOCA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKFwiZGVidWdcIik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgICAgaWYgKCFyMTggJiYgdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJlbnZcIiBpbiBwcm9jZXNzKSB7XG4gICAgICAgIHIxOCA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIxODtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9jb21tb24oKShleHBvcnRzKTtcbiAgICB2YXIgeyBmb3JtYXR0ZXJzIH0gPSBtb2R1bGUuZXhwb3J0cztcbiAgICBmb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2Mikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBcIltVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiBcIiArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbnZhciByZXF1aXJlX2Jhc2U2NF9qcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICBleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG4gICAgZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheTtcbiAgICB2YXIgbG9va3VwID0gW107XG4gICAgdmFyIHJldkxvb2t1cCA9IFtdO1xuICAgIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbiAgICB2YXIgY29kZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgcmV2TG9va3VwW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gICAgcmV2TG9va3VwW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gNjM7XG4gICAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHtcbiAgICAgIHZhciBsZW4yID0gYjY0Lmxlbmd0aDtcbiAgICAgIGlmIChsZW4yICUgNCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKFwiPVwiKTtcbiAgICAgIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuMjtcbiAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuMiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0O1xuICAgICAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChiNjQpIHtcbiAgICAgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuICAgICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICAgICAgcmV0dXJuICh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0xlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gICAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHtcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgICAgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gICAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuICAgICAgdmFyIGN1ckJ5dGUgPSAwO1xuICAgICAgdmFyIGxlbjIgPSBwbGFjZUhvbGRlcnNMZW4gPiAwID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47XG4gICAgICB2YXIgaTI7XG4gICAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW4yOyBpMiArPSA0KSB7XG4gICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMildIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMildIDw8IDYgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAzKV07XG4gICAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDEpXSA+PiA0O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyO1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMjU1O1xuICAgICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgNjNdICsgbG9va3VwW251bSA+PiAxMiAmIDYzXSArIGxvb2t1cFtudW0gPj4gNiAmIDYzXSArIGxvb2t1cFtudW0gJiA2M107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHtcbiAgICAgICAgdG1wID0gKHVpbnQ4W2kyXSA8PCAxNiAmIDE2NzExNjgwKSArICh1aW50OFtpMiArIDFdIDw8IDggJiA2NTI4MCkgKyAodWludDhbaTIgKyAyXSAmIDI1NSk7XG4gICAgICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBsZW4yID0gdWludDgubGVuZ3RoO1xuICAgICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMztcbiAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7XG4gICAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGkyLCBpMiArIG1heENodW5rTGVuZ3RoID4gbGVuMjIgPyBsZW4yMiA6IGkyICsgbWF4Q2h1bmtMZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICAgIHRtcCA9IHVpbnQ4W2xlbjIgLSAxXTtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgXCI9PVwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDYzXSArIGxvb2t1cFt0bXAgPDwgMiAmIDYzXSArIFwiPVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xudmFyIHJlcXVpcmVfaWVlZTc1NCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIGV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICAgIHZhciBlLCBtMjtcbiAgICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICAgICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gICAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgICB2YXIgbkJpdHMgPSAtNztcbiAgICAgIHZhciBpID0gaXNMRSA/IG5CeXRlcyAtIDEgOiAwO1xuICAgICAgdmFyIGQyID0gaXNMRSA/IC0xIDogMTtcbiAgICAgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuICAgICAgaSArPSBkMjtcbiAgICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gICAgICBzID4+PSAtbkJpdHM7XG4gICAgICBuQml0cyArPSBlTGVuO1xuICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZDIsIG5CaXRzIC09IDgpIHtcbiAgICAgIH1cbiAgICAgIG0yID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICAgICAgZSA+Pj0gLW5CaXRzO1xuICAgICAgbkJpdHMgKz0gbUxlbjtcbiAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0yID0gbTIgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZDIsIG5CaXRzIC09IDgpIHtcbiAgICAgIH1cbiAgICAgIGlmIChlID09PSAwKSB7XG4gICAgICAgIGUgPSAxIC0gZUJpYXM7XG4gICAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICAgICAgcmV0dXJuIG0yID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtMiA9IG0yICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICAgIGUgPSBlIC0gZUJpYXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbTIgKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG4gICAgfTtcbiAgICBleHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICAgIHZhciBlLCBtMiwgYzI7XG4gICAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICAgICAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICAgICAgdmFyIHJ0MiA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwO1xuICAgICAgdmFyIGkgPSBpc0xFID8gMCA6IG5CeXRlcyAtIDE7XG4gICAgICB2YXIgZDIgPSBpc0xFID8gMSA6IC0xO1xuICAgICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICBtMiA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgICBlID0gZU1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICAgICAgaWYgKHZhbHVlICogKGMyID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgICAgICBlLS07XG4gICAgICAgICAgYzIgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgICB2YWx1ZSArPSBydDIgLyBjMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSBydDIgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAqIGMyID49IDIpIHtcbiAgICAgICAgICBlKys7XG4gICAgICAgICAgYzIgLz0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgICAgICBtMiA9IDA7XG4gICAgICAgICAgZSA9IGVNYXg7XG4gICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgICBtMiA9ICh2YWx1ZSAqIGMyIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgICBlID0gZSArIGVCaWFzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0yID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICAgICAgZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0yICYgMjU1LCBpICs9IGQyLCBtMiAvPSAyNTYsIG1MZW4gLT0gOCkge1xuICAgICAgfVxuICAgICAgZSA9IGUgPDwgbUxlbiB8IG0yO1xuICAgICAgZUxlbiArPSBtTGVuO1xuICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMjU1LCBpICs9IGQyLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7XG4gICAgICB9XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGQyXSB8PSBzICogMTI4O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXG52YXIgcmVxdWlyZV9idWZmZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXCIoZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiYXNlNjQgPSByZXF1aXJlX2Jhc2U2NF9qcygpO1xuICAgIHZhciBpZWVlNzU0ID0gcmVxdWlyZV9pZWVlNzU0KCk7XG4gICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbFtcImZvclwiXSA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sW1wiZm9yXCJdKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIikgOiBudWxsO1xuICAgIGV4cG9ydHMuQnVmZmVyID0gQnVmZmVyMztcbiAgICBleHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuICAgIGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcbiAgICB2YXIgS19NQVhfTEVOR1RIID0gMjE0NzQ4MzY0NztcbiAgICBleHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7XG4gICAgQnVmZmVyMy5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTtcbiAgICBpZiAoIUJ1ZmZlcjMuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICBjb25zdCBwcm90bzIgPSB7IGZvbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIDQyO1xuICAgICAgICB9IH07XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bzIsIFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8yKTtcbiAgICAgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjMucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlcjMucHJvdG90eXBlLCBcIm9mZnNldFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQnVmZmVyMyhhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBCdWZmZXIzLnBvb2xTaXplID0gODE5MjtcbiAgICBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkge1xuICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlcjMuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgYjIgPSBmcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChiMikgcmV0dXJuIGIyO1xuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gQnVmZmVyMy5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIiksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICBCdWZmZXIzLmZyb20gPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIzLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIzLCBVaW50OEFycmF5KTtcbiAgICBmdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICAgIGFzc2VydFNpemUoc2l6ZSk7XG4gICAgICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09IFwic3RyaW5nXCIgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZykgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSk7XG4gICAgfVxuICAgIEJ1ZmZlcjMuYWxsb2MgPSBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgIGFzc2VydFNpemUoc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcbiAgICB9XG4gICAgQnVmZmVyMy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSBcInN0cmluZ1wiIHx8IGVuY29kaW5nID09PSBcIlwiKSB7XG4gICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCI7XG4gICAgICB9XG4gICAgICBpZiAoIUJ1ZmZlcjMuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gICAgICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7XG4gICAgICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG4gICAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gICAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmcm9tQXJyYXlWaWV3KGFycmF5Vmlldykge1xuICAgICAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KTtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7XG4gICAgICB9XG4gICAgICBsZXQgYnVmO1xuICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHZvaWQgMCAmJiBsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgICAgIGlmIChCdWZmZXIzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pO1xuICAgICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5sZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaik7XG4gICAgICB9XG4gICAgICBpZiAob2JqLnR5cGUgPT09IFwiQnVmZmVyXCIgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja2VkKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgXCIgYnl0ZXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuZ3RoIHwgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2xvd0J1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1ZmZlcjMuYWxsb2MoK2xlbmd0aCk7XG4gICAgfVxuICAgIEJ1ZmZlcjMuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiMikge1xuICAgICAgcmV0dXJuIGIyICE9IG51bGwgJiYgYjIuX2lzQnVmZmVyID09PSB0cnVlICYmIGIyICE9PSBCdWZmZXIzLnByb3RvdHlwZTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYjIpIHtcbiAgICAgIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyMy5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuICAgICAgaWYgKGlzSW5zdGFuY2UoYjIsIFVpbnQ4QXJyYXkpKSBiMiA9IEJ1ZmZlcjMuZnJvbShiMiwgYjIub2Zmc2V0LCBiMi5ieXRlTGVuZ3RoKTtcbiAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyMy5pc0J1ZmZlcihiMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhID09PSBiMikgcmV0dXJuIDA7XG4gICAgICBsZXQgeDMgPSBhLmxlbmd0aDtcbiAgICAgIGxldCB5MiA9IGIyLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4MywgeTIpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGIyW2ldKSB7XG4gICAgICAgICAgeDMgPSBhW2ldO1xuICAgICAgICAgIHkyID0gYjJbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh4MyA8IHkyKSByZXR1cm4gLTE7XG4gICAgICBpZiAoeTIgPCB4MykgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEJ1ZmZlcjMuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICAgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyMy5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQ0KGxpc3QsIGxlbmd0aCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIzLmFsbG9jKDApO1xuICAgICAgfVxuICAgICAgbGV0IGk7XG4gICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlcjMuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IGJ1ZiA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghQnVmZmVyMy5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIzLmZyb20oYnVmKTtcbiAgICAgICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgYnVmLFxuICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoQnVmZmVyMy5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBjb25zdCBtdXN0TWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWU7XG4gICAgICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwO1xuICAgICAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7XG4gICAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlbiAqIDI7XG4gICAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTtcbiAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5jb2RpbmcgPSAoXCJcIiArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlcjMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwIHx8IHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IHZvaWQgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPD0gMCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGVuZCA+Pj49IDA7XG4gICAgICBzdGFydCA+Pj49IDA7XG4gICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBCdWZmZXIzLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIHN3YXAoYjIsIG4sIG0yKSB7XG4gICAgICBjb25zdCBpID0gYjJbbl07XG4gICAgICBiMltuXSA9IGIyW20yXTtcbiAgICAgIGIyW20yXSA9IGk7XG4gICAgfVxuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkge1xuICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgICAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZzQoKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiBcIlwiO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyMy5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgQnVmZmVyMy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzMyhiMikge1xuICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKGIyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gICAgICBpZiAodGhpcyA9PT0gYjIpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIEJ1ZmZlcjMuY29tcGFyZSh0aGlzLCBiMikgPT09IDA7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgY29uc3QgbWF4MyA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM7XG4gICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKFwiaGV4XCIsIDAsIG1heDMpLnJlcGxhY2UoLyguezJ9KS9nLCBcIiQxIFwiKS50cmltKCk7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgzKSBzdHIgKz0gXCIgLi4uIFwiO1xuICAgICAgcmV0dXJuIFwiPEJ1ZmZlciBcIiArIHN0ciArIFwiPlwiO1xuICAgIH07XG4gICAgaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgICAgIEJ1ZmZlcjMucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMy5wcm90b3R5cGUuaW5zcGVjdDtcbiAgICB9XG4gICAgQnVmZmVyMy5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGFyZ2V0ID0gQnVmZmVyMy5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNTdGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXNTdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpc0VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgIGVuZCA+Pj49IDA7XG4gICAgICB0aGlzU3RhcnQgPj4+PSAwO1xuICAgICAgdGhpc0VuZCA+Pj49IDA7XG4gICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMDtcbiAgICAgIGxldCB4MyA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gICAgICBsZXQgeTIgPSBlbmQgLSBzdGFydDtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHgzLCB5Mik7XG4gICAgICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgICAgIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgICAgIHgzID0gdGhpc0NvcHlbaV07XG4gICAgICAgICAgeTIgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoeDMgPCB5MikgcmV0dXJuIC0xO1xuICAgICAgaWYgKHkyIDwgeDMpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMTtcbiAgICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gMjE0NzQ4MzY0NztcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0yMTQ3NDgzNjQ4KSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSAtMjE0NzQ4MzY0ODtcbiAgICAgIH1cbiAgICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDtcbiAgICAgIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gICAgICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkaXIpIHJldHVybiAtMTtcbiAgICAgICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICBlbHNlIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbCA9IEJ1ZmZlcjMuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChCdWZmZXIzLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFsID0gdmFsICYgMjU1O1xuICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgICAgIGxldCBpbmRleFNpemUgPSAxO1xuICAgICAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IFwidWNzMlwiIHx8IGVuY29kaW5nID09PSBcInVjcy0yXCIgfHwgZW5jb2RpbmcgPT09IFwidXRmMTZsZVwiIHx8IGVuY29kaW5nID09PSBcInV0Zi0xNmxlXCIpIHtcbiAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlYWQoYnVmLCBpMikge1xuICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZltpMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaTtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgajIgPSAwOyBqMiA8IHZhbExlbmd0aDsgajIrKykge1xuICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgajIpICE9PSByZWFkKHZhbCwgajIpKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIEJ1ZmZlcjMucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMyKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgICAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgICAgIH1cbiAgICAgIGxldCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaTtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVjczJXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwICYmIHR5cGVvZiBvZmZzZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDA7XG4gICAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIGVuY29kaW5nID0gXCJ1dGY4XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICAgICAgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGVuY29kaW5nID0gKFwiXCIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJCdWZmZXJcIixcbiAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgICAgIGxldCBjb2RlUG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDIzOSA/IDQgOiBmaXJzdEJ5dGUgPiAyMjMgPyAzIDogZmlyc3RCeXRlID4gMTkxID8gMiA6IDE7XG4gICAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAzMSkgPDwgNiB8IHNlY29uZEJ5dGUgJiA2MztcbiAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKHRoaXJkQnl0ZSAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMTUpIDw8IDEyIHwgKHNlY29uZEJ5dGUgJiA2MykgPDwgNiB8IHRoaXJkQnl0ZSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMjA0NyAmJiAodGVtcENvZGVQb2ludCA8IDU1Mjk2IHx8IHRlbXBDb2RlUG9pbnQgPiA1NzM0MykpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG4gICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmIChmb3VydGhCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTggfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCAxMiB8ICh0aGlyZEJ5dGUgJiA2MykgPDwgNiB8IGZvdXJ0aEJ5dGUgJiA2MztcbiAgICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDY1NTM1ICYmIHRlbXBDb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgY29kZVBvaW50ID0gNjU1MzM7XG4gICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gNjU1MzUpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7XG4gICAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDEwMjMgfCA1NTI5Nik7XG4gICAgICAgICAgY29kZVBvaW50ID0gNTYzMjAgfCBjb2RlUG9pbnQgJiAxMDIzO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTtcbiAgICB9XG4gICAgdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gNDA5NjtcbiAgICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykge1xuICAgICAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgICAgIFN0cmluZyxcbiAgICAgICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgbGV0IHJldCA9IFwiXCI7XG4gICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMTI3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgbGV0IHJldCA9IFwiXCI7XG4gICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgICAgIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gICAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuICAgICAgbGV0IG91dCA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UzKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgc3RhcnQgPSB+fnN0YXJ0O1xuICAgICAgZW5kID0gZW5kID09PSB2b2lkIDAgPyBsZW4gOiB+fmVuZDtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgKz0gbGVuO1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbjtcbiAgICAgICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgICAgICBlbmQgPSBsZW47XG4gICAgICB9XG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuICAgICAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlcjMucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBuZXdCdWY7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja09mZnNldChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtcbiAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnRMRSA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgICAgIGxldCBtdWwgPSAxO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVWludEJFID0gQnVmZmVyMy5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdO1xuICAgICAgbGV0IG11bCA9IDE7XG4gICAgICB3aGlsZSAoYnl0ZUxlbmd0aDIgPiAwICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVWludDggPSBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpc1tvZmZzZXRdO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gQnVmZmVyMy5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPSBCdWZmZXIzLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2O1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZFVpbnQzMkJFID0gQnVmZmVyMy5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUob2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsIFwib2Zmc2V0XCIpO1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07XG4gICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTtcbiAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkge1xuICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsbyA9IGZpcnN0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQ7XG4gICAgICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgKyBsYXN0ICogMiAqKiAyNDtcbiAgICAgIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSk7XG4gICAgfSk7XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgXCJvZmZzZXRcIik7XG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XTtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddO1xuICAgICAgaWYgKGZpcnN0ID09PSB2b2lkIDAgfHwgbGFzdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyB0aGlzWysrb2Zmc2V0XTtcbiAgICAgIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICsgdGhpc1srK29mZnNldF0gKiAyICoqIDggKyBsYXN0O1xuICAgICAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKTtcbiAgICB9KTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdO1xuICAgICAgbGV0IG11bCA9IDE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aDIgJiYgKG11bCAqPSAyNTYpKSB7XG4gICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICAgICAgfVxuICAgICAgbXVsICo9IDEyODtcbiAgICAgIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgyLCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgaSA9IGJ5dGVMZW5ndGgyO1xuICAgICAgbGV0IG11bCA9IDE7XG4gICAgICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICAgICAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICAgICAgfVxuICAgICAgbXVsICo9IDEyODtcbiAgICAgIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgyKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICAgICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMTI4KSkgcmV0dXJuIHRoaXNbb2Zmc2V0XTtcbiAgICAgIHJldHVybiAoMjU1IC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG4gICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCB0aGlzW29mZnNldF0gPDwgODtcbiAgICAgIHJldHVybiB2YWwgJiAzMjc2OCA/IHZhbCB8IDQyOTQ5MDE3NjAgOiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzW29mZnNldCArIDNdIDw8IDI0O1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgMjQgfCB0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXTtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFKG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCBcIm9mZnNldFwiKTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdO1xuICAgICAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN107XG4gICAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCB8fCBsYXN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggKyB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArIChsYXN0IDw8IDI0KTtcbiAgICAgIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoZmlyc3QgKyB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCk7XG4gICAgfSk7XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUob2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsIFwib2Zmc2V0XCIpO1xuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF07XG4gICAgICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XTtcbiAgICAgIGlmIChmaXJzdCA9PT0gdm9pZCAwIHx8IGxhc3QgPT09IHZvaWQgMCkge1xuICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgdGhpc1srK29mZnNldF07XG4gICAgICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICsgbGFzdCk7XG4gICAgfSk7XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCk7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4MywgbWluKSB7XG4gICAgICBpZiAoIUJ1ZmZlcjMuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgICBpZiAodmFsdWUgPiBtYXgzIHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50TEUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxO1xuICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApO1xuICAgICAgfVxuICAgICAgbGV0IG11bCA9IDE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50QkUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxO1xuICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7XG4gICAgICBsZXQgbXVsID0gMTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50OCA9IEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDI1NSwgMCk7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID0gQnVmZmVyMy5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgNjU1MzUsIDApO1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlVWludDMyQkUgPSBCdWZmZXIzLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCA0Mjk0OTY3Mjk1LCAwKTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgzKSB7XG4gICAgICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heDMsIGJ1Ziwgb2Zmc2V0LCA3KTtcbiAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBidWZbb2Zmc2V0KytdID0gbG87XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gbG87XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gbG87XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gbG87XG4gICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBidWZbb2Zmc2V0KytdID0gaGk7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gaGk7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gaGk7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBidWZbb2Zmc2V0KytdID0gaGk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cnRCaWdVSW50NjRCRShidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4Mykge1xuICAgICAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgzLCBidWYsIG9mZnNldCwgNyk7XG4gICAgICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoNDI5NDk2NzI5NSkpO1xuICAgICAgYnVmW29mZnNldCArIDddID0gbG87XG4gICAgICBsbyA9IGxvID4+IDg7XG4gICAgICBidWZbb2Zmc2V0ICsgNl0gPSBsbztcbiAgICAgIGxvID0gbG8gPj4gODtcbiAgICAgIGJ1ZltvZmZzZXQgKyA1XSA9IGxvO1xuICAgICAgbG8gPSBsbyA+PiA4O1xuICAgICAgYnVmW29mZnNldCArIDRdID0gbG87XG4gICAgICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICBidWZbb2Zmc2V0ICsgM10gPSBoaTtcbiAgICAgIGhpID0gaGkgPj4gODtcbiAgICAgIGJ1ZltvZmZzZXQgKyAyXSA9IGhpO1xuICAgICAgaGkgPSBoaSA+PiA4O1xuICAgICAgYnVmW29mZnNldCArIDFdID0gaGk7XG4gICAgICBoaSA9IGhpID4+IDg7XG4gICAgICBidWZbb2Zmc2V0XSA9IGhpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDg7XG4gICAgfVxuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbiAgICB9KTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gICAgfSk7XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTtcbiAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBtdWwgPSAxO1xuICAgICAgbGV0IHN1YiA9IDA7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgICAgICBzdWIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMiAtIDEpO1xuICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbGltaXQgLSAxLCAtbGltaXQpO1xuICAgICAgfVxuICAgICAgbGV0IGkgPSBieXRlTGVuZ3RoMiAtIDE7XG4gICAgICBsZXQgbXVsID0gMTtcbiAgICAgIGxldCBzdWIgPSAwO1xuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMjU1O1xuICAgICAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgICAgIHN1YiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAxMjcsIC0xMjgpO1xuICAgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAyNTUgKyB2YWx1ZSArIDE7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDMyNzY3LCAtMzI3NjgpO1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpO1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gNDI5NDk2NzI5NSArIHZhbHVlICsgMTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9O1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICAgIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwXCIpLCBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpO1xuICAgIH0pO1xuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgICAgIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwXCIpLCBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4MywgbWluKSB7XG4gICAgICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIC0zNDAyODIzNDY2Mzg1Mjg4NmUyMik7XG4gICAgICB9XG4gICAgICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxNzk3NjkzMTM0ODYyMzE1N2UyOTIsIC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpO1xuICAgICAgfVxuICAgICAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDg7XG4gICAgfVxuICAgIEJ1ZmZlcjMucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xuICAgIH07XG4gICAgQnVmZmVyMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFCdWZmZXIzLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7XG4gICAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gICAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcbiAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICAgICAgdGFyZ2V0U3RhcnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfTtcbiAgICBCdWZmZXIzLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlcjMuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIgKyBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKGVuY29kaW5nID09PSBcInV0ZjhcIiAmJiBjb2RlIDwgMTI4IHx8IGVuY29kaW5nID09PSBcImxhdGluMVwiKSB7XG4gICAgICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdm9pZCAwID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG4gICAgICBpZiAoIXZhbCkgdmFsID0gMDtcbiAgICAgIGxldCBpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyMy5pc0J1ZmZlcih2YWwpID8gdmFsIDogQnVmZmVyMy5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICsgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdmFyIGVycm9ycyA9IHt9O1xuICAgIGZ1bmN0aW9uIEUzKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICAgICAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gO1xuICAgICAgICAgIHRoaXMuc3RhY2s7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY29kZSgpIHtcbiAgICAgICAgICByZXR1cm4gc3ltO1xuICAgICAgICB9XG4gICAgICAgIHNldCBjb2RlKHZhbHVlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBFMyhcbiAgICAgIFwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsXG4gICAgICBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiO1xuICAgICAgfSxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApO1xuICAgIEUzKFxuICAgICAgXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLFxuICAgICAgZnVuY3Rpb24obmFtZSwgYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gICAgICB9LFxuICAgICAgVHlwZUVycm9yXG4gICAgKTtcbiAgICBFMyhcbiAgICAgIFwiRVJSX09VVF9PRl9SQU5HRVwiLFxuICAgICAgZnVuY3Rpb24oc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICAgICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYDtcbiAgICAgICAgbGV0IHJlY2VpdmVkID0gaW5wdXQ7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjZWl2ZWQgKz0gXCJuXCI7XG4gICAgICAgIH1cbiAgICAgICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgfSxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApO1xuICAgIGZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvcih2YWwpIHtcbiAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgbGV0IGkgPSB2YWwubGVuZ3RoO1xuICAgICAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09IFwiLVwiID8gMSA6IDA7XG4gICAgICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgICAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aDIpIHtcbiAgICAgIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgXCJvZmZzZXRcIik7XG4gICAgICBpZiAoYnVmW29mZnNldF0gPT09IHZvaWQgMCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aDJdID09PSB2b2lkIDApIHtcbiAgICAgICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGgyICsgMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heDMsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMikge1xuICAgICAgaWYgKHZhbHVlID4gbWF4MyB8fCB2YWx1ZSA8IG1pbikge1xuICAgICAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gXCJiaWdpbnRcIiA/IFwiblwiIDogXCJcIjtcbiAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICBpZiAoYnl0ZUxlbmd0aDIgPiAzKSB7XG4gICAgICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDh9JHtufWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogJHsoYnl0ZUxlbmd0aDIgKyAxKSAqIDggLSAxfSR7bn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heDN9JHtufWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKFwidmFsdWVcIiwgcmFuZ2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgXCJudW1iZXJcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNFcnJvcih2YWx1ZSwgbGVuZ3RoLCB0eXBlMykge1xuICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZTMpO1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZTMgfHwgXCJvZmZzZXRcIiwgXCJhbiBpbnRlZ2VyXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoXG4gICAgICAgIHR5cGUzIHx8IFwib2Zmc2V0XCIsXG4gICAgICAgIGA+PSAke3R5cGUzID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZztcbiAgICBmdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHtcbiAgICAgIHN0ciA9IHN0ci5zcGxpdChcIj1cIilbMF07XG4gICAgICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsIFwiXCIpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gXCJcIjtcbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBzdHIgPSBzdHIgKyBcIj1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHtcbiAgICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gICAgICBsZXQgY29kZVBvaW50O1xuICAgICAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gNTUyOTUgJiYgY29kZVBvaW50IDwgNTczNDQpIHtcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NjMxOSkge1xuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCA1NjMyMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDU1Mjk2IDw8IDEwIHwgY29kZVBvaW50IC0gNTYzMjApICsgNjU1MzY7XG4gICAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgfVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyOCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVhaztcbiAgICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMjA0OCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVhaztcbiAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgY29kZVBvaW50ID4+IDYgfCAxOTIsXG4gICAgICAgICAgICBjb2RlUG9pbnQgJiA2MyB8IDEyOFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgNjU1MzYpIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgICAgIGNvZGVQb2ludCA+PiAxMiB8IDIyNCxcbiAgICAgICAgICAgIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsXG4gICAgICAgICAgICBjb2RlUG9pbnQgJiA2MyB8IDEyOFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMTExNDExMikge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgY29kZVBvaW50ID4+IDE4IHwgMjQwLFxuICAgICAgICAgICAgY29kZVBvaW50ID4+IDEyICYgNjMgfCAxMjgsXG4gICAgICAgICAgICBjb2RlUG9pbnQgPj4gNiAmIDYzIHwgMTI4LFxuICAgICAgICAgICAgY29kZVBvaW50ICYgNjMgfCAxMjhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gICAgICBjb25zdCBieXRlQXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlQXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0ciwgdW5pdHMpIHtcbiAgICAgIGxldCBjMiwgaGksIGxvO1xuICAgICAgY29uc3QgYnl0ZUFycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhpID0gYzIgPj4gODtcbiAgICAgICAgbG8gPSBjMiAlIDI1NjtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgICAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGxldCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGggfHwgaSA+PSBzcmMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSW5zdGFuY2Uob2JqLCB0eXBlMykge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUzIHx8IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUzLm5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bWJlcklzTmFOKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH1cbiAgICB2YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgY29uc3QgaTE2ID0gaSAqIDE2O1xuICAgICAgICBmb3IgKGxldCBqMiA9IDA7IGoyIDwgMTY7ICsrajIpIHtcbiAgICAgICAgICB0YWJsZVtpMTYgKyBqMl0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2oyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH0oKTtcbiAgICBmdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QoZm4yKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gXCJ1bmRlZmluZWRcIiA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmbjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHBlcm1hd2ViL2FvLXNjaGVkdWxlci11dGlscy9kaXN0L2Jyb3dzZXIuanNcbnZhciBRdCA9IHsgXCJAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXJcIjogdHJ1ZSB9O1xuZnVuY3Rpb24gayhyMTgpIHtcbiAgcmV0dXJuIHIxOCA9PT0gUXQ7XG59XG5mdW5jdGlvbiBFKHIxOCkge1xuICByZXR1cm4gZnVuY3Rpb24gZSh0KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgayh0KSA/IGUgOiByMTguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHgocjE4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHQsIG4pIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBrKHQpID8gZSA6IEUoZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiByMTgodCwgcyk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGsodCkgJiYgayhuKSA/IGUgOiBrKHQpID8gRShmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOChzLCBuKTtcbiAgICAgICAgfSkgOiBrKG4pID8gRShmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOCh0LCBzKTtcbiAgICAgICAgfSkgOiByMTgodCwgbik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcShyMTgsIGUpIHtcbiAgc3dpdGNoIChyMTgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhLCBpKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhLCBpLCBvKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhLCBpLCBvLCB1KSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhLCBpLCBvLCB1LCBsKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbih0LCBuLCBzLCBhLCBpLCBvLCB1LCBsLCBoKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCwgbiwgcywgYSwgaSwgbywgdSwgbCwgaCwgdjIpIHtcbiAgICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZXQocjE4LCBlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIHMgPSAwLCBhID0gcjE4LCBpID0gMCwgbyA9IGZhbHNlOyBpIDwgZS5sZW5ndGggfHwgcyA8IGFyZ3VtZW50cy5sZW5ndGg7ICkge1xuICAgICAgdmFyIHU7XG4gICAgICBpIDwgZS5sZW5ndGggJiYgKCFrKGVbaV0pIHx8IHMgPj0gYXJndW1lbnRzLmxlbmd0aCkgPyB1ID0gZVtpXSA6ICh1ID0gYXJndW1lbnRzW3NdLCBzICs9IDEpLCBuW2ldID0gdSwgayh1KSA/IG8gPSB0cnVlIDogYSAtPSAxLCBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiAhbyAmJiBhIDw9IDAgPyB0LmFwcGx5KHRoaXMsIG4pIDogcShNYXRoLm1heCgwLCBhKSwgZXQocjE4LCBuLCB0KSk7XG4gIH07XG59XG52YXIgcm4gPSB4KGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIGUgPT09IDEgPyBFKHQpIDogcShlLCBldChlLCBbXSwgdCkpO1xufSk7XG52YXIgdHQgPSBybjtcbmZ1bmN0aW9uIHVlKHIxOCkge1xuICByZXR1cm4gZnVuY3Rpb24gZSh0LCBuLCBzKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gayh0KSA/IGUgOiB4KGZ1bmN0aW9uKGEsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcjE4KHQsIGEsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGsodCkgJiYgayhuKSA/IGUgOiBrKHQpID8geChmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOChhLCBuLCBpKTtcbiAgICAgICAgfSkgOiBrKG4pID8geChmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOCh0LCBhLCBpKTtcbiAgICAgICAgfSkgOiBFKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gcjE4KHQsIG4sIGEpO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBrKHQpICYmIGsobikgJiYgayhzKSA/IGUgOiBrKHQpICYmIGsobikgPyB4KGZ1bmN0aW9uKGEsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcjE4KGEsIGksIHMpO1xuICAgICAgICB9KSA6IGsodCkgJiYgayhzKSA/IHgoZnVuY3Rpb24oYSwgaSkge1xuICAgICAgICAgIHJldHVybiByMTgoYSwgbiwgaSk7XG4gICAgICAgIH0pIDogayhuKSAmJiBrKHMpID8geChmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOCh0LCBhLCBpKTtcbiAgICAgICAgfSkgOiBrKHQpID8gRShmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOChhLCBuLCBzKTtcbiAgICAgICAgfSkgOiBrKG4pID8gRShmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOCh0LCBhLCBzKTtcbiAgICAgICAgfSkgOiBrKHMpID8gRShmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIHIxOCh0LCBuLCBhKTtcbiAgICAgICAgfSkgOiByMTgodCwgbiwgcyk7XG4gICAgfVxuICB9O1xufVxudmFyIE9lID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZS5sZW5ndGggPj0gMCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5mdW5jdGlvbiB3dChyMTgpIHtcbiAgcmV0dXJuIHIxOCAhPSBudWxsICYmIHR5cGVvZiByMThbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBsZShyMTgsIGUsIHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdCgpO1xuICAgIHZhciBuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIU9lKG4pKSB7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHIxOC5sZW5ndGg7ICkge1xuICAgICAgICBpZiAodHlwZW9mIG5bcjE4W3NdXSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBuW3IxOFtzXV0uYXBwbHkobiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSkpO1xuICAgICAgICBzICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAod3QobikpIHtcbiAgICAgICAgdmFyIGEgPSBlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpKTtcbiAgICAgICAgcmV0dXJuIGEobik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBidChyMTgpIHtcbiAgcmV0dXJuIHIxOCAmJiByMThbXCJAQHRyYW5zZHVjZXIvcmVkdWNlZFwiXSA/IHIxOCA6IHsgXCJAQHRyYW5zZHVjZXIvdmFsdWVcIjogcjE4LCBcIkBAdHJhbnNkdWNlci9yZWR1Y2VkXCI6IHRydWUgfTtcbn1cbnZhciBLID0geyBpbml0OiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSgpO1xufSwgcmVzdWx0OiBmdW5jdGlvbihyMTgpIHtcbiAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdKHIxOCk7XG59IH07XG5mdW5jdGlvbiBydChyMTgpIHtcbiAgZm9yICh2YXIgZSA9IFtdLCB0OyAhKHQgPSByMTgubmV4dCgpKS5kb25lOyApIGUucHVzaCh0LnZhbHVlKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBudChyMTgsIGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDAsIHMgPSB0Lmxlbmd0aDsgbiA8IHM7ICkge1xuICAgIGlmIChyMTgoZSwgdFtuXSkpIHJldHVybiB0cnVlO1xuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBTdChyMTgpIHtcbiAgdmFyIGUgPSBTdHJpbmcocjE4KS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICByZXR1cm4gZSA9PSBudWxsID8gXCJcIiA6IGVbMV07XG59XG5mdW5jdGlvbiBlZShyMTgsIGUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCByMTgpO1xufVxuZnVuY3Rpb24gbm4ocjE4LCBlKSB7XG4gIHJldHVybiByMTggPT09IGUgPyByMTggIT09IDAgfHwgMSAvIHIxOCA9PT0gMSAvIGUgOiByMTggIT09IHIxOCAmJiBlICE9PSBlO1xufVxudmFyIHN0ID0gdHlwZW9mIE9iamVjdC5pcyA9PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBubjtcbnZhciBLdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgc24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEt0LmNhbGwoYXJndW1lbnRzKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiA/IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gS3QuY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbiAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZWUoXCJjYWxsZWVcIiwgZSk7XG4gIH07XG59KCk7XG52YXIgZXIgPSBzbjtcbnZhciBhbiA9ICF7IHRvU3RyaW5nOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoXCJ0b1N0cmluZ1wiKTtcbnZhciB0ciA9IFtcImNvbnN0cnVjdG9yXCIsIFwidmFsdWVPZlwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiXTtcbnZhciByciA9IGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImxlbmd0aFwiKTtcbn0oKTtcbnZhciBvbiA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgKSB7XG4gICAgaWYgKGVbbl0gPT09IHQpIHJldHVybiB0cnVlO1xuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIHVuID0gdHlwZW9mIE9iamVjdC5rZXlzID09IFwiZnVuY3Rpb25cIiAmJiAhcnIgPyBFKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdChlKSAhPT0gZSA/IFtdIDogT2JqZWN0LmtleXMoZSk7XG59KSA6IEUoZnVuY3Rpb24oZSkge1xuICBpZiAoT2JqZWN0KGUpICE9PSBlKSByZXR1cm4gW107XG4gIHZhciB0LCBuLCBzID0gW10sIGEgPSByciAmJiBlcihlKTtcbiAgZm9yICh0IGluIGUpIGVlKHQsIGUpICYmICghYSB8fCB0ICE9PSBcImxlbmd0aFwiKSAmJiAoc1tzLmxlbmd0aF0gPSB0KTtcbiAgaWYgKGFuKSBmb3IgKG4gPSB0ci5sZW5ndGggLSAxOyBuID49IDA7ICkgdCA9IHRyW25dLCBlZSh0LCBlKSAmJiAhb24ocywgdCkgJiYgKHNbcy5sZW5ndGhdID0gdCksIG4gLT0gMTtcbiAgcmV0dXJuIHM7XG59KTtcbnZhciBGID0gdW47XG52YXIgbG4gPSBFKGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPT09IG51bGwgPyBcIk51bGxcIiA6IGUgPT09IHZvaWQgMCA/IFwiVW5kZWZpbmVkXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xufSk7XG52YXIga3QgPSBsbjtcbmZ1bmN0aW9uIG5yKHIxOCwgZSwgdCwgbikge1xuICB2YXIgcyA9IHJ0KHIxOCksIGEgPSBydChlKTtcbiAgZnVuY3Rpb24gaShvLCB1KSB7XG4gICAgcmV0dXJuIE1lKG8sIHUsIHQuc2xpY2UoKSwgbi5zbGljZSgpKTtcbiAgfVxuICByZXR1cm4gIW50KGZ1bmN0aW9uKG8sIHUpIHtcbiAgICByZXR1cm4gIW50KGksIHUsIG8pO1xuICB9LCBhLCBzKTtcbn1cbmZ1bmN0aW9uIE1lKHIxOCwgZSwgdCwgbikge1xuICBpZiAoc3QocjE4LCBlKSkgcmV0dXJuIHRydWU7XG4gIHZhciBzID0ga3QocjE4KTtcbiAgaWYgKHMgIT09IGt0KGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgcjE4W1wiZmFudGFzeS1sYW5kL2VxdWFsc1wiXSA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGVbXCJmYW50YXN5LWxhbmQvZXF1YWxzXCJdID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHR5cGVvZiByMThbXCJmYW50YXN5LWxhbmQvZXF1YWxzXCJdID09IFwiZnVuY3Rpb25cIiAmJiByMThbXCJmYW50YXN5LWxhbmQvZXF1YWxzXCJdKGUpICYmIHR5cGVvZiBlW1wiZmFudGFzeS1sYW5kL2VxdWFsc1wiXSA9PSBcImZ1bmN0aW9uXCIgJiYgZVtcImZhbnRhc3ktbGFuZC9lcXVhbHNcIl0ocjE4KTtcbiAgaWYgKHR5cGVvZiByMTguZXF1YWxzID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZS5lcXVhbHMgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHlwZW9mIHIxOC5lcXVhbHMgPT0gXCJmdW5jdGlvblwiICYmIHIxOC5lcXVhbHMoZSkgJiYgdHlwZW9mIGUuZXF1YWxzID09IFwiZnVuY3Rpb25cIiAmJiBlLmVxdWFscyhyMTgpO1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIFwiQXJndW1lbnRzXCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgaWYgKHR5cGVvZiByMTguY29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiICYmIFN0KHIxOC5jb25zdHJ1Y3RvcikgPT09IFwiUHJvbWlzZVwiKSByZXR1cm4gcjE4ID09PSBlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkJvb2xlYW5cIjpcbiAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgICAgaWYgKCEodHlwZW9mIHIxOCA9PSB0eXBlb2YgZSAmJiBzdChyMTgudmFsdWVPZigpLCBlLnZhbHVlT2YoKSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRGF0ZVwiOlxuICAgICAgaWYgKCFzdChyMTgudmFsdWVPZigpLCBlLnZhbHVlT2YoKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJFcnJvclwiOlxuICAgICAgcmV0dXJuIHIxOC5uYW1lID09PSBlLm5hbWUgJiYgcjE4Lm1lc3NhZ2UgPT09IGUubWVzc2FnZTtcbiAgICBjYXNlIFwiUmVnRXhwXCI6XG4gICAgICBpZiAoIShyMTguc291cmNlID09PSBlLnNvdXJjZSAmJiByMTguZ2xvYmFsID09PSBlLmdsb2JhbCAmJiByMTguaWdub3JlQ2FzZSA9PT0gZS5pZ25vcmVDYXNlICYmIHIxOC5tdWx0aWxpbmUgPT09IGUubXVsdGlsaW5lICYmIHIxOC5zdGlja3kgPT09IGUuc3RpY2t5ICYmIHIxOC51bmljb2RlID09PSBlLnVuaWNvZGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICBicmVhaztcbiAgfVxuICBmb3IgKHZhciBhID0gdC5sZW5ndGggLSAxOyBhID49IDA7ICkge1xuICAgIGlmICh0W2FdID09PSByMTgpIHJldHVybiBuW2FdID09PSBlO1xuICAgIGEgLT0gMTtcbiAgfVxuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgICByZXR1cm4gcjE4LnNpemUgIT09IGUuc2l6ZSA/IGZhbHNlIDogbnIocjE4LmVudHJpZXMoKSwgZS5lbnRyaWVzKCksIHQuY29uY2F0KFtyMThdKSwgbi5jb25jYXQoW2VdKSk7XG4gICAgY2FzZSBcIlNldFwiOlxuICAgICAgcmV0dXJuIHIxOC5zaXplICE9PSBlLnNpemUgPyBmYWxzZSA6IG5yKHIxOC52YWx1ZXMoKSwgZS52YWx1ZXMoKSwgdC5jb25jYXQoW3IxOF0pLCBuLmNvbmNhdChbZV0pKTtcbiAgICBjYXNlIFwiQXJndW1lbnRzXCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgY2FzZSBcIk51bWJlclwiOlxuICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICBjYXNlIFwiRGF0ZVwiOlxuICAgIGNhc2UgXCJFcnJvclwiOlxuICAgIGNhc2UgXCJSZWdFeHBcIjpcbiAgICBjYXNlIFwiSW50OEFycmF5XCI6XG4gICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICBjYXNlIFwiVWludDhDbGFtcGVkQXJyYXlcIjpcbiAgICBjYXNlIFwiSW50MTZBcnJheVwiOlxuICAgIGNhc2UgXCJVaW50MTZBcnJheVwiOlxuICAgIGNhc2UgXCJJbnQzMkFycmF5XCI6XG4gICAgY2FzZSBcIlVpbnQzMkFycmF5XCI6XG4gICAgY2FzZSBcIkZsb2F0MzJBcnJheVwiOlxuICAgIGNhc2UgXCJGbG9hdDY0QXJyYXlcIjpcbiAgICBjYXNlIFwiQXJyYXlCdWZmZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGkgPSBGKHIxOCk7XG4gIGlmIChpLmxlbmd0aCAhPT0gRihlKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIG8gPSB0LmNvbmNhdChbcjE4XSksIHUgPSBuLmNvbmNhdChbZV0pO1xuICBmb3IgKGEgPSBpLmxlbmd0aCAtIDE7IGEgPj0gMDsgKSB7XG4gICAgdmFyIGwgPSBpW2FdO1xuICAgIGlmICghKGVlKGwsIGUpICYmIE1lKGVbbF0sIHIxOFtsXSwgbywgdSkpKSByZXR1cm4gZmFsc2U7XG4gICAgYSAtPSAxO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIGNuID0geChmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBNZShlLCB0LCBbXSwgW10pO1xufSk7XG52YXIgYXQgPSBjbjtcbmZ1bmN0aW9uIFR0KHIxOCwgZSwgdCkge1xuICB2YXIgbiwgcztcbiAgaWYgKHR5cGVvZiByMTguaW5kZXhPZiA9PSBcImZ1bmN0aW9uXCIpIHN3aXRjaCAodHlwZW9mIGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoZSA9PT0gMCkge1xuICAgICAgICBmb3IgKG4gPSAxIC8gZTsgdCA8IHIxOC5sZW5ndGg7ICkge1xuICAgICAgICAgIGlmIChzID0gcjE4W3RdLCBzID09PSAwICYmIDEgLyBzID09PSBuKSByZXR1cm4gdDtcbiAgICAgICAgICB0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChlICE9PSBlKSB7XG4gICAgICAgIGZvciAoOyB0IDwgcjE4Lmxlbmd0aDsgKSB7XG4gICAgICAgICAgaWYgKHMgPSByMThbdF0sIHR5cGVvZiBzID09IFwibnVtYmVyXCIgJiYgcyAhPT0gcykgcmV0dXJuIHQ7XG4gICAgICAgICAgdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByMTguaW5kZXhPZihlLCB0KTtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gcjE4LmluZGV4T2YoZSwgdCk7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiByMTguaW5kZXhPZihlLCB0KTtcbiAgfVxuICBmb3IgKDsgdCA8IHIxOC5sZW5ndGg7ICkge1xuICAgIGlmIChhdChyMThbdF0sIGUpKSByZXR1cm4gdDtcbiAgICB0ICs9IDE7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gT3QocjE4LCBlKSB7XG4gIHJldHVybiBUdChlLCByMTgsIDApID49IDA7XG59XG5mdW5jdGlvbiBHKHIxOCwgZSkge1xuICBmb3IgKHZhciB0ID0gMCwgbiA9IGUubGVuZ3RoLCBzID0gQXJyYXkobik7IHQgPCBuOyApIHNbdF0gPSByMTgoZVt0XSksIHQgKz0gMTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBEZShyMTgpIHtcbiAgdmFyIGUgPSByMTgucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1tcXGJdL2csIFwiXFxcXGJcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFx2L2csIFwiXFxcXHZcIikucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIik7XG4gIHJldHVybiAnXCInICsgZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCInO1xufVxudmFyIEJlID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gKGUgPCAxMCA/IFwiMFwiIDogXCJcIikgKyBlO1xufTtcbnZhciBmbiA9IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyA9PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlLnRvSVNPU3RyaW5nKCk7XG59IDogZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZS5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgKyBCZShlLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICsgQmUoZS5nZXRVVENEYXRlKCkpICsgXCJUXCIgKyBCZShlLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgKyBCZShlLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArIEJlKGUuZ2V0VVRDU2Vjb25kcygpKSArIFwiLlwiICsgKGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxZTMpLnRvRml4ZWQoMykuc2xpY2UoMiwgNSkgKyBcIlpcIjtcbn07XG52YXIgc3IgPSBmbjtcbmZ1bmN0aW9uIEV0KHIxOCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFyMTguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEZlKHIxOCwgZSwgdCkge1xuICBmb3IgKHZhciBuID0gMCwgcyA9IHQubGVuZ3RoOyBuIDwgczsgKSBlID0gcjE4KGUsIHRbbl0pLCBuICs9IDE7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQXQocjE4LCBlKSB7XG4gIGZvciAodmFyIHQgPSAwLCBuID0gZS5sZW5ndGgsIHMgPSBbXTsgdCA8IG47ICkgcjE4KGVbdF0pICYmIChzW3MubGVuZ3RoXSA9IGVbdF0pLCB0ICs9IDE7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gQ3QocjE4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocjE4KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbnZhciBkbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByMTgoZSwgdCkge1xuICAgIHRoaXMueGYgPSB0LCB0aGlzLmYgPSBlO1xuICB9XG4gIHJldHVybiByMTgucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL2luaXRcIl0gPSBLLmluaXQsIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdID0gSy5yZXN1bHQsIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5mKHQpID8gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9zdGVwXCJdKGUsIHQpIDogZTtcbiAgfSwgcjE4O1xufSgpO1xuZnVuY3Rpb24gUnQocjE4KSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIG5ldyBkbihyMTgsIGUpO1xuICB9O1xufVxudmFyIGhuID0geChsZShbXCJmYW50YXN5LWxhbmQvZmlsdGVyXCIsIFwiZmlsdGVyXCJdLCBSdCwgZnVuY3Rpb24ocjE4LCBlKSB7XG4gIHJldHVybiBDdChlKSA/IEZlKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICByZXR1cm4gcjE4KGVbbl0pICYmICh0W25dID0gZVtuXSksIHQ7XG4gIH0sIHt9LCBGKGUpKSA6IEF0KHIxOCwgZSk7XG59KSk7XG52YXIgYXIgPSBobjtcbnZhciBwbiA9IHgoZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gYXIoRXQoZSksIHQpO1xufSk7XG52YXIgaXIgPSBwbjtcbmZ1bmN0aW9uIGl0KHIxOCwgZSkge1xuICB2YXIgdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgbyA9IGUuY29uY2F0KFtyMThdKTtcbiAgICByZXR1cm4gT3QoaSwgbykgPyBcIjxDaXJjdWxhcj5cIiA6IGl0KGksIG8pO1xuICB9LCBuID0gZnVuY3Rpb24oYSwgaSkge1xuICAgIHJldHVybiBHKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBEZShvKSArIFwiOiBcIiArIHQoYVtvXSk7XG4gICAgfSwgaS5zbGljZSgpLnNvcnQoKSk7XG4gIH07XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIxOCkpIHtcbiAgICBjYXNlIFwiW29iamVjdCBBcmd1bWVudHNdXCI6XG4gICAgICByZXR1cm4gXCIoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oXCIgKyBHKHQsIHIxOCkuam9pbihcIiwgXCIpICsgXCIpKVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IEFycmF5XVwiOlxuICAgICAgcmV0dXJuIFwiW1wiICsgRyh0LCByMTgpLmNvbmNhdChuKHIxOCwgaXIoZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gL15cXGQrJC8udGVzdChhKTtcbiAgICAgIH0sIEYocjE4KSkpKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICBjYXNlIFwiW29iamVjdCBCb29sZWFuXVwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiByMTggPT0gXCJvYmplY3RcIiA/IFwibmV3IEJvb2xlYW4oXCIgKyB0KHIxOC52YWx1ZU9mKCkpICsgXCIpXCIgOiByMTgudG9TdHJpbmcoKTtcbiAgICBjYXNlIFwiW29iamVjdCBEYXRlXVwiOlxuICAgICAgcmV0dXJuIFwibmV3IERhdGUoXCIgKyAoaXNOYU4ocjE4LnZhbHVlT2YoKSkgPyB0KE5hTikgOiBEZShzcihyMTgpKSkgKyBcIilcIjtcbiAgICBjYXNlIFwiW29iamVjdCBNYXBdXCI6XG4gICAgICByZXR1cm4gXCJuZXcgTWFwKFwiICsgdChBcnJheS5mcm9tKHIxOCkpICsgXCIpXCI7XG4gICAgY2FzZSBcIltvYmplY3QgTnVsbF1cIjpcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICBjYXNlIFwiW29iamVjdCBOdW1iZXJdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIHIxOCA9PSBcIm9iamVjdFwiID8gXCJuZXcgTnVtYmVyKFwiICsgdChyMTgudmFsdWVPZigpKSArIFwiKVwiIDogMSAvIHIxOCA9PT0gLTEgLyAwID8gXCItMFwiIDogcjE4LnRvU3RyaW5nKDEwKTtcbiAgICBjYXNlIFwiW29iamVjdCBTZXRdXCI6XG4gICAgICByZXR1cm4gXCJuZXcgU2V0KFwiICsgdChBcnJheS5mcm9tKHIxOCkuc29ydCgpKSArIFwiKVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIHJldHVybiB0eXBlb2YgcjE4ID09IFwib2JqZWN0XCIgPyBcIm5ldyBTdHJpbmcoXCIgKyB0KHIxOC52YWx1ZU9mKCkpICsgXCIpXCIgOiBEZShyMTgpO1xuICAgIGNhc2UgXCJbb2JqZWN0IFVuZGVmaW5lZF1cIjpcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHIxOC50b1N0cmluZyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHMgPSByMTgudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHMgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwie1wiICsgbihyMTgsIEYocjE4KSkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gIH1cbn1cbnZhciBtbiA9IEUoZnVuY3Rpb24oZSkge1xuICByZXR1cm4gaXQoZSwgW10pO1xufSk7XG52YXIganQgPSBtbjtcbnZhciB5biA9IHgoZnVuY3Rpb24oZSwgdCkge1xuICBpZiAoZSA9PT0gdCkgcmV0dXJuIHQ7XG4gIGZ1bmN0aW9uIG4odSwgbCkge1xuICAgIGlmICh1ID4gbCAhPSBsID4gdSkgcmV0dXJuIGwgPiB1ID8gbCA6IHU7XG4gIH1cbiAgdmFyIHMgPSBuKGUsIHQpO1xuICBpZiAocyAhPT0gdm9pZCAwKSByZXR1cm4gcztcbiAgdmFyIGEgPSBuKHR5cGVvZiBlLCB0eXBlb2YgdCk7XG4gIGlmIChhICE9PSB2b2lkIDApIHJldHVybiBhID09PSB0eXBlb2YgZSA/IGUgOiB0O1xuICB2YXIgaSA9IGp0KGUpLCBvID0gbihpLCBqdCh0KSk7XG4gIHJldHVybiBvICE9PSB2b2lkIDAgJiYgbyA9PT0gaSA/IGUgOiB0O1xufSk7XG52YXIgb3IgPSB5bjtcbnZhciBnbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByMTgoZSwgdCkge1xuICAgIHRoaXMueGYgPSB0LCB0aGlzLmYgPSBlO1xuICB9XG4gIHJldHVybiByMTgucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL2luaXRcIl0gPSBLLmluaXQsIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdID0gSy5yZXN1bHQsIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9zdGVwXCJdKGUsIHRoaXMuZih0KSk7XG4gIH0sIHIxODtcbn0oKTtcbnZhciBfbiA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gbmV3IGduKGUsIHQpO1xuICB9O1xufTtcbnZhciB1ciA9IF9uO1xudmFyIHZuID0geChsZShbXCJmYW50YXN5LWxhbmQvbWFwXCIsIFwibWFwXCJdLCB1ciwgZnVuY3Rpb24oZSwgdCkge1xuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkge1xuICAgIGNhc2UgXCJbb2JqZWN0IEZ1bmN0aW9uXVwiOlxuICAgICAgcmV0dXJuIHR0KHQubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzLCB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSBcIltvYmplY3QgT2JqZWN0XVwiOlxuICAgICAgcmV0dXJuIEZlKGZ1bmN0aW9uKG4sIHMpIHtcbiAgICAgICAgcmV0dXJuIG5bc10gPSBlKHRbc10pLCBuO1xuICAgICAgfSwge30sIEYodCkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRyhlLCB0KTtcbiAgfVxufSkpO1xudmFyIGxyID0gdm47XG52YXIgb3QgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPDwgMCA9PT0gZTtcbn07XG5mdW5jdGlvbiBVZShyMTgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyMTgpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufVxuZnVuY3Rpb24gJGUocjE4LCBlKSB7XG4gIHZhciB0ID0gcjE4IDwgMCA/IGUubGVuZ3RoICsgcjE4IDogcjE4O1xuICByZXR1cm4gVWUoZSkgPyBlLmNoYXJBdCh0KSA6IGVbdF07XG59XG52YXIgeG4gPSB4KGZ1bmN0aW9uKGUsIHQpIHtcbiAgaWYgKHQgIT0gbnVsbCkgcmV0dXJuIG90KGUpID8gJGUoZSwgdCkgOiB0W2VdO1xufSk7XG52YXIgdGUgPSB4bjtcbnZhciB3biA9IHgoZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gbHIodGUoZSksIHQpO1xufSk7XG52YXIgY3IgPSB3bjtcbnZhciBibiA9IEUoZnVuY3Rpb24oZSkge1xuICByZXR1cm4gT2UoZSkgPyB0cnVlIDogIWUgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIiB8fCBVZShlKSA/IGZhbHNlIDogZS5sZW5ndGggPT09IDAgPyB0cnVlIDogZS5sZW5ndGggPiAwID8gZS5oYXNPd25Qcm9wZXJ0eSgwKSAmJiBlLmhhc093blByb3BlcnR5KGUubGVuZ3RoIC0gMSkgOiBmYWxzZTtcbn0pO1xudmFyIGZyID0gYm47XG52YXIgZHIgPSB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcbmZ1bmN0aW9uIEl0KHIxOCwgZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24ocywgYSwgaSkge1xuICAgIGlmIChmcihpKSkgcmV0dXJuIHIxOChzLCBhLCBpKTtcbiAgICBpZiAoaSA9PSBudWxsKSByZXR1cm4gYTtcbiAgICBpZiAodHlwZW9mIGlbXCJmYW50YXN5LWxhbmQvcmVkdWNlXCJdID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGUocywgYSwgaSwgXCJmYW50YXN5LWxhbmQvcmVkdWNlXCIpO1xuICAgIGlmIChpW2RyXSAhPSBudWxsKSByZXR1cm4gdChzLCBhLCBpW2RyXSgpKTtcbiAgICBpZiAodHlwZW9mIGkubmV4dCA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0KHMsIGEsIGkpO1xuICAgIGlmICh0eXBlb2YgaS5yZWR1Y2UgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZShzLCBhLCBpLCBcInJlZHVjZVwiKTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGVcIik7XG4gIH07XG59XG5mdW5jdGlvbiBOdChyMTgsIGUsIHQpIHtcbiAgZm9yICh2YXIgbiA9IDAsIHMgPSB0Lmxlbmd0aDsgbiA8IHM7ICkge1xuICAgIGlmIChlID0gcjE4W1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oZSwgdFtuXSksIGUgJiYgZVtcIkBAdHJhbnNkdWNlci9yZWR1Y2VkXCJdKSB7XG4gICAgICBlID0gZVtcIkBAdHJhbnNkdWNlci92YWx1ZVwiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICs9IDE7XG4gIH1cbiAgcmV0dXJuIHIxOFtcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0oZSk7XG59XG52YXIgU24gPSB4KGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHEoZS5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmFwcGx5KHQsIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG52YXIgaHIgPSBTbjtcbmZ1bmN0aW9uIGtuKHIxOCwgZSwgdCkge1xuICBmb3IgKHZhciBuID0gdC5uZXh0KCk7ICFuLmRvbmU7ICkge1xuICAgIGlmIChlID0gcjE4W1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oZSwgbi52YWx1ZSksIGUgJiYgZVtcIkBAdHJhbnNkdWNlci9yZWR1Y2VkXCJdKSB7XG4gICAgICBlID0gZVtcIkBAdHJhbnNkdWNlci92YWx1ZVwiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuID0gdC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHIxOFtcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0oZSk7XG59XG5mdW5jdGlvbiBUbihyMTgsIGUsIHQsIG4pIHtcbiAgcmV0dXJuIHIxOFtcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0odFtuXShocihyMThbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSwgcjE4KSwgZSkpO1xufVxudmFyIE9uID0gSXQoTnQsIFRuLCBrbik7XG52YXIgcHIgPSBPbjtcbnZhciBFbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByMTgoZSkge1xuICAgIHRoaXMuZiA9IGU7XG4gIH1cbiAgcmV0dXJuIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXQgbm90IGltcGxlbWVudGVkIG9uIFhXcmFwXCIpO1xuICB9LCByMTgucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfSwgcjE4LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9zdGVwXCJdID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmYoZSwgdCk7XG4gIH0sIHIxODtcbn0oKTtcbmZ1bmN0aW9uIEx0KHIxOCkge1xuICByZXR1cm4gbmV3IEVuKHIxOCk7XG59XG52YXIgQW4gPSB1ZShmdW5jdGlvbihyMTgsIGUsIHQpIHtcbiAgcmV0dXJuIHByKHR5cGVvZiByMTggPT0gXCJmdW5jdGlvblwiID8gTHQocjE4KSA6IHIxOCwgZSwgdCk7XG59KTtcbnZhciB1dCA9IEFuO1xuZnVuY3Rpb24gUHQocjE4LCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5jYWxsKHRoaXMsIHIxOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFZlKHIxOCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmICh0ID09PSAwKSByZXR1cm4gZSgpO1xuICAgIHZhciBuID0gYXJndW1lbnRzW3QgLSAxXTtcbiAgICByZXR1cm4gT2UobikgfHwgdHlwZW9mIG5bcjE4XSAhPSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBuW3IxOF0uYXBwbHkobiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCB0IC0gMSkpO1xuICB9O1xufVxudmFyIENuID0gdWUoVmUoXCJzbGljZVwiLCBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuLCBlLCB0KTtcbn0pKTtcbnZhciBtciA9IENuO1xudmFyIFJuID0gRShWZShcInRhaWxcIiwgbXIoMSwgMSAvIDApKSk7XG52YXIgeXIgPSBSbjtcbmZ1bmN0aW9uIHFlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwicGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnRcIik7XG4gIHJldHVybiBxKGFyZ3VtZW50c1swXS5sZW5ndGgsIHV0KFB0LCBhcmd1bWVudHNbMF0sIHlyKGFyZ3VtZW50cykpKTtcbn1cbnZhciBqbiA9IHgoZnVuY3Rpb24oZSwgdCkge1xuICByZXR1cm4gdHQodXQob3IsIDAsIGNyKFwibGVuZ3RoXCIsIHQpKSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMsIHMgPSB0aGlzO1xuICAgIHJldHVybiBlLmFwcGx5KHMsIEcoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGEuYXBwbHkocywgbik7XG4gICAgfSwgdCkpO1xuICB9KTtcbn0pO1xudmFyIGdyID0gam47XG52YXIgSW4gPSB4KGZ1bmN0aW9uKGUsIHQpIHtcbiAgcmV0dXJuIHQgPT0gbnVsbCB8fCB0ICE9PSB0ID8gZSA6IHQ7XG59KTtcbnZhciBHZSA9IEluO1xudmFyIE5uID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHIxOChlLCB0KSB7XG4gICAgdGhpcy54ZiA9IHQsIHRoaXMuZiA9IGUsIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcjE4LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0gSy5pbml0LCByMTgucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5mb3VuZCB8fCAoZSA9IHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXShlLCB2b2lkIDApKSwgdGhpcy54ZltcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0oZSk7XG4gIH0sIHIxOC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5mKHQpICYmICh0aGlzLmZvdW5kID0gdHJ1ZSwgZSA9IGJ0KHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXShlLCB0KSkpLCBlO1xuICB9LCByMTg7XG59KCk7XG5mdW5jdGlvbiBadChyMTgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gbmV3IE5uKHIxOCwgZSk7XG4gIH07XG59XG52YXIgTG4gPSB4KGxlKFtcImZpbmRcIl0sIFp0LCBmdW5jdGlvbihlLCB0KSB7XG4gIGZvciAodmFyIG4gPSAwLCBzID0gdC5sZW5ndGg7IG4gPCBzOyApIHtcbiAgICBpZiAoZSh0W25dKSkgcmV0dXJuIHRbbl07XG4gICAgbiArPSAxO1xuICB9XG59KSk7XG52YXIgV3QgPSBMbjtcbnZhciBQbiA9IEUoZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZ3IoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIH0sIGUpO1xufSk7XG52YXIgenQgPSBQbjtcbmZ1bmN0aW9uIE10KHIxOCwgZSkge1xuICBmb3IgKHZhciB0ID0gZSwgbiA9IDA7IG4gPCByMTgubGVuZ3RoOyBuICs9IDEpIHtcbiAgICBpZiAodCA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHMgPSByMThbbl07XG4gICAgb3QocykgPyB0ID0gJGUocywgdCkgOiB0ID0gdFtzXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbnZhciBabiA9IHgoTXQpO1xudmFyIGx0ID0gWm47XG52YXIgV24gPSB1ZShmdW5jdGlvbihlLCB0LCBuKSB7XG4gIHJldHVybiBhdChlLCB0ZSh0LCBuKSk7XG59KTtcbnZhciBEdCA9IFduO1xudmFyIEggPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiSW52YWxpZFNjaGVkdWxlckxvY2F0aW9uXCI7XG59O1xudmFyIGN0ID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIlNjaGVkdWxlclRhZ05vdEZvdW5kXCI7XG59O1xudmFyIGZ0ID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIlRyYW5zYWN0aW9uTm90Rm91bmRcIjtcbn07XG5mdW5jdGlvbiBIZShyMTggPSBcIlwiKSB7XG4gIHJldHVybiByMTggPSByMTgudHJpbSgpLCByMTguZW5kc1dpdGgoXCIvXCIpID8gSGUocjE4LnNsaWNlKDAsIC0xKSkgOiByMTg7XG59XG52YXIgX3IgPSAocjE4LCB7IG1heFJldHJpZXM6IGUgPSAwLCBkZWxheTogdCA9IDMwMCB9KSA9PiB7XG4gIGxldCBuID0gKHMsIGEpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4ocjE4KS5jYXRjaCgoaSkgPT4ge1xuICAgIGlmIChzID49IGUpIHJldHVybiBQcm9taXNlLnJlamVjdChpKTtcbiAgICBsZXQgbyA9IHMgKyAxLCB1ID0gYSArIGE7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChsKSA9PiBzZXRUaW1lb3V0KGwsIGEpKS50aGVuKCgpID0+IG4obywgdSkpO1xuICB9KTtcbiAgcmV0dXJuIG4oMCwgdCk7XG59O1xudmFyIHZyID0gKHIxOCkgPT4ge1xuICBpZiAocjE4Lm9rKSByZXR1cm4gcjE4O1xuICB0aHJvdyByMTg7XG59O1xudmFyIHpuID0gXCJVcmxcIjtcbnZhciBNbiA9IFwiVGltZS1Uby1MaXZlXCI7XG52YXIgRG4gPSBcIlNjaGVkdWxlclwiO1xudmFyIEJ0ID0gKHIxOCkgPT4gcWUoR2UoW10pLCBXdChEdChyMTgsIFwibmFtZVwiKSksIEdlKHt9KSwgdGUoXCJ2YWx1ZVwiKSk7XG52YXIgeHIgPSAocjE4KSA9PiBxZSgoZSkgPT4ge1xuICBpZiAoIWUpIHRocm93IG5ldyBmdChyMTgpO1xuICByZXR1cm4gZTtcbn0sIHRlKFwidGFnc1wiKSwgR2UoW10pKTtcbmZ1bmN0aW9uIHdyKHsgZmV0Y2g6IHIxOCwgR1JBUEhRTF9VUkw6IGUsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IHQgPSAwLCBHUkFQSFFMX1JFVFJZX0JBQ0tPRkY6IG4gPSAzMDAgfSkge1xuICByZXR1cm4gYXN5bmMgKHsgcXVlcnk6IHMsIHZhcmlhYmxlczogYSB9KSA9PiBfcigoKSA9PiByMTgoZSwgeyBtZXRob2Q6IFwiUE9TVFwiLCBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcXVlcnk6IHMsIHZhcmlhYmxlczogYSB9KSB9KS50aGVuKHZyKS50aGVuKChpKSA9PiBpLmpzb24oKSksIHsgbWF4UmV0cmllczogdCwgZGVsYXk6IG4gfSk7XG59XG5mdW5jdGlvbiBicih7IGZldGNoOiByMTgsIEdSQVBIUUxfVVJMOiBlLCBHUkFQSFFMX01BWF9SRVRSSUVTOiB0LCBHUkFQSFFMX1JFVFJZX0JBQ0tPRkY6IG4gfSkge1xuICBsZXQgcyA9IHdyKHsgZmV0Y2g6IHIxOCwgR1JBUEhRTF9VUkw6IGUsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IHQsIEdSQVBIUUxfUkVUUllfQkFDS09GRjogbiB9KSwgYSA9IEZ0KHsgZmV0Y2g6IHIxOCwgR1JBUEhRTF9VUkw6IGUsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IHQsIEdSQVBIUUxfUkVUUllfQkFDS09GRjogbiB9KSwgaSA9IGBcbiAgICBxdWVyeSBHZXRUcmFuc2FjdGlvbnMgKCR0cmFuc2FjdGlvbklkczogW0lEIV0hKSB7XG4gICAgICB0cmFuc2FjdGlvbnMoaWRzOiAkdHJhbnNhY3Rpb25JZHMpIHtcbiAgICAgICAgZWRnZXMge1xuICAgICAgICAgIG5vZGUge1xuICAgICAgICAgICAgdGFncyB7XG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGA7XG4gIHJldHVybiBhc3luYyAobykgPT4gcyh7IHF1ZXJ5OiBpLCB2YXJpYWJsZXM6IHsgdHJhbnNhY3Rpb25JZHM6IFtvXSB9IH0pLnRoZW4obHQoW1wiZGF0YVwiLCBcInRyYW5zYWN0aW9uc1wiLCBcImVkZ2VzXCIsIFwiMFwiLCBcIm5vZGVcIl0pKS50aGVuKHhyKGBQcm9jZXNzICR7b30gd2FzIG5vdCBmb3VuZCBvbiBnYXRld2F5YCkpLnRoZW4oQnQoRG4pKS50aGVuKCh1KSA9PiB7XG4gICAgaWYgKCF1KSB0aHJvdyBuZXcgY3QoJ05vIFwiU2NoZWR1bGVyXCIgdGFnIGZvdW5kIG9uIHByb2Nlc3MnKTtcbiAgICByZXR1cm4gYSh1KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBGdCh7IGZldGNoOiByMTgsIEdSQVBIUUxfVVJMOiBlLCBHUkFQSFFMX01BWF9SRVRSSUVTOiB0LCBHUkFQSFFMX1JFVFJZX0JBQ0tPRkY6IG4gfSkge1xuICBsZXQgcyA9IHdyKHsgZmV0Y2g6IHIxOCwgR1JBUEhRTF9VUkw6IGUsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IHQsIEdSQVBIUUxfUkVUUllfQkFDS09GRjogbiB9KSwgYSA9IGBcbiAgICBxdWVyeSBHZXRTY2hlZHVsZXJMb2NhdGlvbiAoJG93bmVyOiBTdHJpbmchKSB7XG4gICAgICB0cmFuc2FjdGlvbnMgKFxuICAgICAgICBvd25lcnM6IFskb3duZXJdXG4gICAgICAgIHRhZ3M6IFtcbiAgICAgICAgICB7IG5hbWU6IFwiRGF0YS1Qcm90b2NvbFwiLCB2YWx1ZXM6IFtcImFvXCJdIH0sXG4gICAgICAgICAgeyBuYW1lOiBcIlR5cGVcIiwgdmFsdWVzOiBbXCJTY2hlZHVsZXItTG9jYXRpb25cIl0gfVxuICAgICAgICBdXG4gICAgICAgICMgT25seSBuZWVkIHRoZSBtb3N0IHJlY2VudCBTY2hlZHVsZXItTG9jYXRpb25cbiAgICAgICAgc29ydDogSEVJR0hUX0RFU0NcbiAgICAgICAgZmlyc3Q6IDFcbiAgICAgICkge1xuICAgICAgICBlZGdlcyB7XG4gICAgICAgICAgbm9kZSB7XG4gICAgICAgICAgICB0YWdzIHtcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgYDtcbiAgcmV0dXJuIGFzeW5jIChpKSA9PiBzKHsgcXVlcnk6IGEsIHZhcmlhYmxlczogeyBvd25lcjogaSB9IH0pLnRoZW4obHQoW1wiZGF0YVwiLCBcInRyYW5zYWN0aW9uc1wiLCBcImVkZ2VzXCIsIFwiMFwiLCBcIm5vZGVcIl0pKS50aGVuKHhyKGBDb3VsZCBub3QgZmluZCAnU2NoZWR1bGVyLUxvY2F0aW9uJyBvd25lciBieSB3YWxsZXQgJHtpfWApKS50aGVuKHp0KFtCdCh6biksIEJ0KE1uKV0pKS50aGVuKChbbywgdV0pID0+IHtcbiAgICBpZiAoIW8pIHRocm93IG5ldyBIKCdObyBcIlVybFwiIHRhZyBmb3VuZCBvbiBTY2hlZHVsZXItTG9jYXRpb24nKTtcbiAgICBpZiAoIXUpIHRocm93IG5ldyBIKCdObyBcIlRpbWUtVG8tTGl2ZVwiIHRhZyBmb3VuZCBvbiBTY2hlZHVsZXItTG9jYXRpb24nKTtcbiAgICByZXR1cm4geyB1cmw6IG8sIHR0bDogdSwgYWRkcmVzczogaSB9O1xuICB9KTtcbn1cbnZhciBFZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT0gXCJmdW5jdGlvblwiID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xudmFyIGtyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBVdCA9IHR5cGVvZiBwcm9jZXNzID09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyA/IHByb2Nlc3MgOiB7fTtcbnZhciBUciA9IChyMTgsIGUsIHQsIG4pID0+IHtcbiAgdHlwZW9mIFV0LmVtaXRXYXJuaW5nID09IFwiZnVuY3Rpb25cIiA/IFV0LmVtaXRXYXJuaW5nKHIxOCwgZSwgdCwgbikgOiBjb25zb2xlLmVycm9yKGBbJHt0fV0gJHtlfTogJHtyMTh9YCk7XG59O1xudmFyIGR0ID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXI7XG52YXIgU3IgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsO1xuaWYgKHR5cGVvZiBkdCA+IFwidVwiKSB7XG4gIFNyID0gY2xhc3Mge1xuICAgIG9uYWJvcnQ7XG4gICAgX29uYWJvcnQgPSBbXTtcbiAgICByZWFzb247XG4gICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIobiwgcykge1xuICAgICAgdGhpcy5fb25hYm9ydC5wdXNoKHMpO1xuICAgIH1cbiAgfSwgZHQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBlKCk7XG4gICAgfVxuICAgIHNpZ25hbCA9IG5ldyBTcigpO1xuICAgIGFib3J0KG4pIHtcbiAgICAgIGlmICghdGhpcy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSBuLCB0aGlzLnNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLnNpZ25hbC5fb25hYm9ydCkgcyhuKTtcbiAgICAgICAgdGhpcy5zaWduYWwub25hYm9ydD8uKG4pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgbGV0IHIxOCA9IFV0LmVudj8uTFJVX0NBQ0hFX0lHTk9SRV9BQ19XQVJOSU5HICE9PSBcIjFcIiwgZSA9ICgpID0+IHtcbiAgICByMTggJiYgKHIxOCA9IGZhbHNlLCBUcihcIkFib3J0Q29udHJvbGxlciBpcyBub3QgZGVmaW5lZC4gSWYgdXNpbmcgbHJ1LWNhY2hlIGluIG5vZGUgMTQsIGxvYWQgYW4gQWJvcnRDb250cm9sbGVyIHBvbHlmaWxsIGZyb20gdGhlIGBub2RlLWFib3J0LWNvbnRyb2xsZXJgIHBhY2thZ2UuIEEgbWluaW1hbCBwb2x5ZmlsbCBpcyBwcm92aWRlZCBmb3IgdXNlIGJ5IExSVUNhY2hlLmZldGNoKCksIGJ1dCBpdCBzaG91bGQgbm90IGJlIHJlbGllZCB1cG9uIGluIG90aGVyIGNvbnRleHRzIChlZywgcGFzc2luZyBpdCB0byBvdGhlciBBUElzIHRoYXQgdXNlIEFib3J0Q29udHJvbGxlci9BYm9ydFNpZ25hbCBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMpLiBZb3UgbWF5IGRpc2FibGUgdGhpcyB3aXRoIExSVV9DQUNIRV9JR05PUkVfQUNfV0FSTklORz0xIGluIHRoZSBlbnYuXCIsIFwiTk9fQUJPUlRfQ09OVFJPTExFUlwiLCBcIkVOT1RTVVBcIiwgZSkpO1xuICB9O1xufVxudmFyIEZuID0gKHIxOCkgPT4gIWtyLmhhcyhyMTgpO1xudmFyIEl1ID0gU3ltYm9sKFwidHlwZVwiKTtcbnZhciByZSA9IChyMTgpID0+IHIxOCAmJiByMTggPT09IE1hdGguZmxvb3IocjE4KSAmJiByMTggPiAwICYmIGlzRmluaXRlKHIxOCk7XG52YXIgT3IgPSAocjE4KSA9PiByZShyMTgpID8gcjE4IDw9IE1hdGgucG93KDIsIDgpID8gVWludDhBcnJheSA6IHIxOCA8PSBNYXRoLnBvdygyLCAxNikgPyBVaW50MTZBcnJheSA6IHIxOCA8PSBNYXRoLnBvdygyLCAzMikgPyBVaW50MzJBcnJheSA6IHIxOCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IEFlIDogbnVsbCA6IG51bGw7XG52YXIgQWUgPSBjbGFzcyBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLmZpbGwoMCk7XG4gIH1cbn07XG52YXIgJHQgPSBjbGFzcyByIHtcbiAgaGVhcDtcbiAgbGVuZ3RoO1xuICBzdGF0aWMgI3UgPSBmYWxzZTtcbiAgc3RhdGljIGNyZWF0ZShlKSB7XG4gICAgbGV0IHQgPSBPcihlKTtcbiAgICBpZiAoIXQpIHJldHVybiBbXTtcbiAgICByLiN1ID0gdHJ1ZTtcbiAgICBsZXQgbiA9IG5ldyByKGUsIHQpO1xuICAgIHJldHVybiByLiN1ID0gZmFsc2UsIG47XG4gIH1cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIGlmICghci4jdSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImluc3RhbnRpYXRlIFN0YWNrIHVzaW5nIFN0YWNrLmNyZWF0ZShuKVwiKTtcbiAgICB0aGlzLmhlYXAgPSBuZXcgdChlKSwgdGhpcy5sZW5ndGggPSAwO1xuICB9XG4gIHB1c2goZSkge1xuICAgIHRoaXMuaGVhcFt0aGlzLmxlbmd0aCsrXSA9IGU7XG4gIH1cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF07XG4gIH1cbn07XG52YXIgaHQgPSBjbGFzcyByMiB7XG4gICN1O1xuICAjZjtcbiAgI207XG4gICN5O1xuICAjQztcbiAgdHRsO1xuICB0dGxSZXNvbHV0aW9uO1xuICB0dGxBdXRvcHVyZ2U7XG4gIHVwZGF0ZUFnZU9uR2V0O1xuICB1cGRhdGVBZ2VPbkhhcztcbiAgYWxsb3dTdGFsZTtcbiAgbm9EaXNwb3NlT25TZXQ7XG4gIG5vVXBkYXRlVFRMO1xuICBtYXhFbnRyeVNpemU7XG4gIHNpemVDYWxjdWxhdGlvbjtcbiAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICBub0RlbGV0ZU9uU3RhbGVHZXQ7XG4gIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICBpZ25vcmVGZXRjaEFib3J0O1xuICAjcztcbiAgI2c7XG4gICNuO1xuICAjcjtcbiAgI2U7XG4gICNsO1xuICAjZDtcbiAgI287XG4gICNhO1xuICAjXztcbiAgI2k7XG4gICN2O1xuICAjeDtcbiAgI2g7XG4gICN3O1xuICAjVDtcbiAgI2M7XG4gIHN0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoZSkge1xuICAgIHJldHVybiB7IHN0YXJ0czogZS4jeCwgdHRsczogZS4jaCwgc2l6ZXM6IGUuI3YsIGtleU1hcDogZS4jbiwga2V5TGlzdDogZS4jciwgdmFsTGlzdDogZS4jZSwgbmV4dDogZS4jbCwgcHJldjogZS4jZCwgZ2V0IGhlYWQoKSB7XG4gICAgICByZXR1cm4gZS4jbztcbiAgICB9LCBnZXQgdGFpbCgpIHtcbiAgICAgIHJldHVybiBlLiNhO1xuICAgIH0sIGZyZWU6IGUuI18sIGlzQmFja2dyb3VuZEZldGNoOiAodCkgPT4gZS4jdCh0KSwgYmFja2dyb3VuZEZldGNoOiAodCwgbiwgcywgYSkgPT4gZS4jSSh0LCBuLCBzLCBhKSwgbW92ZVRvVGFpbDogKHQpID0+IGUuI0EodCksIGluZGV4ZXM6ICh0KSA9PiBlLiNiKHQpLCByaW5kZXhlczogKHQpID0+IGUuI1ModCksIGlzU3RhbGU6ICh0KSA9PiBlLiNwKHQpIH07XG4gIH1cbiAgZ2V0IG1heCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdTtcbiAgfVxuICBnZXQgbWF4U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZjtcbiAgfVxuICBnZXQgY2FsY3VsYXRlZFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2c7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3M7XG4gIH1cbiAgZ2V0IGZldGNoTWV0aG9kKCkge1xuICAgIHJldHVybiB0aGlzLiNDO1xuICB9XG4gIGdldCBkaXNwb3NlKCkge1xuICAgIHJldHVybiB0aGlzLiNtO1xuICB9XG4gIGdldCBkaXNwb3NlQWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3k7XG4gIH1cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGxldCB7IG1heDogdCA9IDAsIHR0bDogbiwgdHRsUmVzb2x1dGlvbjogcyA9IDEsIHR0bEF1dG9wdXJnZTogYSwgdXBkYXRlQWdlT25HZXQ6IGksIHVwZGF0ZUFnZU9uSGFzOiBvLCBhbGxvd1N0YWxlOiB1LCBkaXNwb3NlOiBsLCBkaXNwb3NlQWZ0ZXI6IGgsIG5vRGlzcG9zZU9uU2V0OiB2Miwgbm9VcGRhdGVUVEw6IFQzLCBtYXhTaXplOiBTID0gMCwgbWF4RW50cnlTaXplOiBCMiA9IDAsIHNpemVDYWxjdWxhdGlvbjogQSwgZmV0Y2hNZXRob2Q6IEwsIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjogTywgbm9EZWxldGVPblN0YWxlR2V0OiBJMiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb246IFYsIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ6IEMyLCBpZ25vcmVGZXRjaEFib3J0OiBXIH0gPSBlO1xuICAgIGlmICh0ICE9PSAwICYmICFyZSh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXJcIik7XG4gICAgbGV0IG9lID0gdCA/IE9yKHQpIDogQXJyYXk7XG4gICAgaWYgKCFvZSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtYXggdmFsdWU6IFwiICsgdCk7XG4gICAgaWYgKHRoaXMuI3UgPSB0LCB0aGlzLiNmID0gUywgdGhpcy5tYXhFbnRyeVNpemUgPSBCMiB8fCB0aGlzLiNmLCB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IEEsIHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICBpZiAoIXRoaXMuI2YgJiYgIXRoaXMubWF4RW50cnlTaXplKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplXCIpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzaXplQ2FsY3VsYXRpb24gc2V0IHRvIG5vbi1mdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKEwgIT09IHZvaWQgMCAmJiB0eXBlb2YgTCAhPSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkXCIpO1xuICAgIGlmICh0aGlzLiNDID0gTCwgdGhpcy4jVCA9ICEhTCwgdGhpcy4jbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuI3IgPSBuZXcgQXJyYXkodCkuZmlsbCh2b2lkIDApLCB0aGlzLiNlID0gbmV3IEFycmF5KHQpLmZpbGwodm9pZCAwKSwgdGhpcy4jbCA9IG5ldyBvZSh0KSwgdGhpcy4jZCA9IG5ldyBvZSh0KSwgdGhpcy4jbyA9IDAsIHRoaXMuI2EgPSAwLCB0aGlzLiNfID0gJHQuY3JlYXRlKHQpLCB0aGlzLiNzID0gMCwgdGhpcy4jZyA9IDAsIHR5cGVvZiBsID09IFwiZnVuY3Rpb25cIiAmJiAodGhpcy4jbSA9IGwpLCB0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyAodGhpcy4jeSA9IGgsIHRoaXMuI2kgPSBbXSkgOiAodGhpcy4jeSA9IHZvaWQgMCwgdGhpcy4jaSA9IHZvaWQgMCksIHRoaXMuI3cgPSAhIXRoaXMuI20sIHRoaXMuI2MgPSAhIXRoaXMuI3ksIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIXYyLCB0aGlzLm5vVXBkYXRlVFRMID0gISFUMywgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIU8sIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIVYsIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCA9ICEhQzIsIHRoaXMuaWdub3JlRmV0Y2hBYm9ydCA9ICEhVywgdGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLiNmICE9PSAwICYmICFyZSh0aGlzLiNmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkXCIpO1xuICAgICAgaWYgKCFyZSh0aGlzLm1heEVudHJ5U2l6ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkXCIpO1xuICAgICAgdGhpcy4jeigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbGxvd1N0YWxlID0gISF1LCB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCA9ICEhSTIsIHRoaXMudXBkYXRlQWdlT25HZXQgPSAhIWksIHRoaXMudXBkYXRlQWdlT25IYXMgPSAhIW8sIHRoaXMudHRsUmVzb2x1dGlvbiA9IHJlKHMpIHx8IHMgPT09IDAgPyBzIDogMSwgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIWEsIHRoaXMudHRsID0gbiB8fCAwLCB0aGlzLnR0bCkge1xuICAgICAgaWYgKCFyZSh0aGlzLnR0bCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkXCIpO1xuICAgICAgdGhpcy4jTigpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdSA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLiNmID09PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXQgbGVhc3Qgb25lIG9mIG1heCwgbWF4U2l6ZSwgb3IgdHRsIGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMuI3UgJiYgIXRoaXMuI2YpIHtcbiAgICAgIGxldCBRMiA9IFwiTFJVX0NBQ0hFX1VOQk9VTkRFRFwiO1xuICAgICAgRm4oUTIpICYmIChrci5hZGQoUTIpLCBUcihcIlRUTCBjYWNoaW5nIHdpdGhvdXQgdHRsQXV0b3B1cmdlLCBtYXgsIG9yIG1heFNpemUgY2FuIHJlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLlwiLCBcIlVuYm91bmRlZENhY2hlV2FybmluZ1wiLCBRMiwgcjIpKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVtYWluaW5nVFRMKGUpIHtcbiAgICByZXR1cm4gdGhpcy4jbi5oYXMoZSkgPyAxIC8gMCA6IDA7XG4gIH1cbiAgI04oKSB7XG4gICAgbGV0IGUgPSBuZXcgQWUodGhpcy4jdSksIHQgPSBuZXcgQWUodGhpcy4jdSk7XG4gICAgdGhpcy4jaCA9IGUsIHRoaXMuI3ggPSB0LCB0aGlzLiNMID0gKGEsIGksIG8gPSBFZS5ub3coKSkgPT4ge1xuICAgICAgaWYgKHRbYV0gPSBpICE9PSAwID8gbyA6IDAsIGVbYV0gPSBpLCBpICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgIGxldCB1ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jcChhKSAmJiB0aGlzLmRlbGV0ZSh0aGlzLiNyW2FdKTtcbiAgICAgICAgfSwgaSArIDEpO1xuICAgICAgICB1LnVucmVmICYmIHUudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLiNPID0gKGEpID0+IHtcbiAgICAgIHRbYV0gPSBlW2FdICE9PSAwID8gRWUubm93KCkgOiAwO1xuICAgIH0sIHRoaXMuI2sgPSAoYSwgaSkgPT4ge1xuICAgICAgaWYgKGVbaV0pIHtcbiAgICAgICAgbGV0IG8gPSBlW2ldLCB1ID0gdFtpXTtcbiAgICAgICAgaWYgKCFvIHx8ICF1KSByZXR1cm47XG4gICAgICAgIGEudHRsID0gbywgYS5zdGFydCA9IHUsIGEubm93ID0gbiB8fCBzKCk7XG4gICAgICAgIGxldCBsID0gYS5ub3cgLSB1O1xuICAgICAgICBhLnJlbWFpbmluZ1RUTCA9IG8gLSBsO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IG4gPSAwLCBzID0gKCkgPT4ge1xuICAgICAgbGV0IGEgPSBFZS5ub3coKTtcbiAgICAgIGlmICh0aGlzLnR0bFJlc29sdXRpb24gPiAwKSB7XG4gICAgICAgIG4gPSBhO1xuICAgICAgICBsZXQgaSA9IHNldFRpbWVvdXQoKCkgPT4gbiA9IDAsIHRoaXMudHRsUmVzb2x1dGlvbik7XG4gICAgICAgIGkudW5yZWYgJiYgaS51bnJlZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbiAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IChhKSA9PiB7XG4gICAgICBsZXQgaSA9IHRoaXMuI24uZ2V0KGEpO1xuICAgICAgaWYgKGkgPT09IHZvaWQgMCkgcmV0dXJuIDA7XG4gICAgICBsZXQgbyA9IGVbaV0sIHUgPSB0W2ldO1xuICAgICAgaWYgKCFvIHx8ICF1KSByZXR1cm4gMSAvIDA7XG4gICAgICBsZXQgbCA9IChuIHx8IHMoKSkgLSB1O1xuICAgICAgcmV0dXJuIG8gLSBsO1xuICAgIH0sIHRoaXMuI3AgPSAoYSkgPT4ge1xuICAgICAgbGV0IGkgPSB0W2FdLCBvID0gZVthXTtcbiAgICAgIHJldHVybiAhIW8gJiYgISFpICYmIChuIHx8IHMoKSkgLSBpID4gbztcbiAgICB9O1xuICB9XG4gICNPID0gKCkgPT4ge1xuICB9O1xuICAjayA9ICgpID0+IHtcbiAgfTtcbiAgI0wgPSAoKSA9PiB7XG4gIH07XG4gICNwID0gKCkgPT4gZmFsc2U7XG4gICN6KCkge1xuICAgIGxldCBlID0gbmV3IEFlKHRoaXMuI3UpO1xuICAgIHRoaXMuI2cgPSAwLCB0aGlzLiN2ID0gZSwgdGhpcy4jRSA9ICh0KSA9PiB7XG4gICAgICB0aGlzLiNnIC09IGVbdF0sIGVbdF0gPSAwO1xuICAgIH0sIHRoaXMuI1AgPSAodCwgbiwgcywgYSkgPT4ge1xuICAgICAgaWYgKHRoaXMuI3QobikpIHJldHVybiAwO1xuICAgICAgaWYgKCFyZShzKSkgaWYgKGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGlmIChzID0gYShuLCB0KSwgIXJlKHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlcilcIik7XG4gICAgICB9IGVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKS4gV2hlbiBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBpcyB1c2VkLCBzaXplQ2FsY3VsYXRpb24gb3Igc2l6ZSBtdXN0IGJlIHNldC5cIik7XG4gICAgICByZXR1cm4gcztcbiAgICB9LCB0aGlzLiNSID0gKHQsIG4sIHMpID0+IHtcbiAgICAgIGlmIChlW3RdID0gbiwgdGhpcy4jZikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuI2YgLSBlW3RdO1xuICAgICAgICBmb3IgKDsgdGhpcy4jZyA+IGE7ICkgdGhpcy4jaih0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2cgKz0gZVt0XSwgcyAmJiAocy5lbnRyeVNpemUgPSBuLCBzLnRvdGFsQ2FsY3VsYXRlZFNpemUgPSB0aGlzLiNnKTtcbiAgICB9O1xuICB9XG4gICNFID0gKGUpID0+IHtcbiAgfTtcbiAgI1IgPSAoZSwgdCwgbikgPT4ge1xuICB9O1xuICAjUCA9IChlLCB0LCBuLCBzKSA9PiB7XG4gICAgaWYgKG4gfHwgcykgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgb24gY2FjaGVcIik7XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gICojYih7IGFsbG93U3RhbGU6IGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuI3MpIGZvciAobGV0IHQgPSB0aGlzLiNhOyAhKCF0aGlzLiNaKHQpIHx8ICgoZSB8fCAhdGhpcy4jcCh0KSkgJiYgKHlpZWxkIHQpLCB0ID09PSB0aGlzLiNvKSk7ICkgdCA9IHRoaXMuI2RbdF07XG4gIH1cbiAgKiNTKHsgYWxsb3dTdGFsZTogZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy4jcykgZm9yIChsZXQgdCA9IHRoaXMuI287ICEoIXRoaXMuI1oodCkgfHwgKChlIHx8ICF0aGlzLiNwKHQpKSAmJiAoeWllbGQgdCksIHQgPT09IHRoaXMuI2EpKTsgKSB0ID0gdGhpcy4jbFt0XTtcbiAgfVxuICAjWihlKSB7XG4gICAgcmV0dXJuIGUgIT09IHZvaWQgMCAmJiB0aGlzLiNuLmdldCh0aGlzLiNyW2VdKSA9PT0gZTtcbiAgfVxuICAqZW50cmllcygpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMuI2IoKSkgdGhpcy4jZVtlXSAhPT0gdm9pZCAwICYmIHRoaXMuI3JbZV0gIT09IHZvaWQgMCAmJiAhdGhpcy4jdCh0aGlzLiNlW2VdKSAmJiAoeWllbGQgW3RoaXMuI3JbZV0sIHRoaXMuI2VbZV1dKTtcbiAgfVxuICAqcmVudHJpZXMoKSB7XG4gICAgZm9yIChsZXQgZSBvZiB0aGlzLiNTKCkpIHRoaXMuI2VbZV0gIT09IHZvaWQgMCAmJiB0aGlzLiNyW2VdICE9PSB2b2lkIDAgJiYgIXRoaXMuI3QodGhpcy4jZVtlXSkgJiYgKHlpZWxkIFt0aGlzLiNyW2VdLCB0aGlzLiNlW2VdXSk7XG4gIH1cbiAgKmtleXMoKSB7XG4gICAgZm9yIChsZXQgZSBvZiB0aGlzLiNiKCkpIHtcbiAgICAgIGxldCB0ID0gdGhpcy4jcltlXTtcbiAgICAgIHQgIT09IHZvaWQgMCAmJiAhdGhpcy4jdCh0aGlzLiNlW2VdKSAmJiAoeWllbGQgdCk7XG4gICAgfVxuICB9XG4gICpya2V5cygpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMuI1MoKSkge1xuICAgICAgbGV0IHQgPSB0aGlzLiNyW2VdO1xuICAgICAgdCAhPT0gdm9pZCAwICYmICF0aGlzLiN0KHRoaXMuI2VbZV0pICYmICh5aWVsZCB0KTtcbiAgICB9XG4gIH1cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMuI2IoKSkgdGhpcy4jZVtlXSAhPT0gdm9pZCAwICYmICF0aGlzLiN0KHRoaXMuI2VbZV0pICYmICh5aWVsZCB0aGlzLiNlW2VdKTtcbiAgfVxuICAqcnZhbHVlcygpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMuI1MoKSkgdGhpcy4jZVtlXSAhPT0gdm9pZCAwICYmICF0aGlzLiN0KHRoaXMuI2VbZV0pICYmICh5aWVsZCB0aGlzLiNlW2VdKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cbiAgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIkxSVUNhY2hlXCI7XG4gIGZpbmQoZSwgdCA9IHt9KSB7XG4gICAgZm9yIChsZXQgbiBvZiB0aGlzLiNiKCkpIHtcbiAgICAgIGxldCBzID0gdGhpcy4jZVtuXSwgYSA9IHRoaXMuI3QocykgPyBzLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogcztcbiAgICAgIGlmIChhICE9PSB2b2lkIDAgJiYgZShhLCB0aGlzLiNyW25dLCB0aGlzKSkgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuI3Jbbl0sIHQpO1xuICAgIH1cbiAgfVxuICBmb3JFYWNoKGUsIHQgPSB0aGlzKSB7XG4gICAgZm9yIChsZXQgbiBvZiB0aGlzLiNiKCkpIHtcbiAgICAgIGxldCBzID0gdGhpcy4jZVtuXSwgYSA9IHRoaXMuI3QocykgPyBzLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogcztcbiAgICAgIGEgIT09IHZvaWQgMCAmJiBlLmNhbGwodCwgYSwgdGhpcy4jcltuXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHJmb3JFYWNoKGUsIHQgPSB0aGlzKSB7XG4gICAgZm9yIChsZXQgbiBvZiB0aGlzLiNTKCkpIHtcbiAgICAgIGxldCBzID0gdGhpcy4jZVtuXSwgYSA9IHRoaXMuI3QocykgPyBzLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogcztcbiAgICAgIGEgIT09IHZvaWQgMCAmJiBlLmNhbGwodCwgYSwgdGhpcy4jcltuXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHB1cmdlU3RhbGUoKSB7XG4gICAgbGV0IGUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB0IG9mIHRoaXMuI1MoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB0aGlzLiNwKHQpICYmICh0aGlzLmRlbGV0ZSh0aGlzLiNyW3RdKSwgZSA9IHRydWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGluZm8oZSkge1xuICAgIGxldCB0ID0gdGhpcy4jbi5nZXQoZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgIGxldCBuID0gdGhpcy4jZVt0XSwgcyA9IHRoaXMuI3QobikgPyBuLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogbjtcbiAgICBpZiAocyA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgbGV0IGEgPSB7IHZhbHVlOiBzIH07XG4gICAgaWYgKHRoaXMuI2ggJiYgdGhpcy4jeCkge1xuICAgICAgbGV0IGkgPSB0aGlzLiNoW3RdLCBvID0gdGhpcy4jeFt0XTtcbiAgICAgIGlmIChpICYmIG8pIHtcbiAgICAgICAgbGV0IHUgPSBpIC0gKEVlLm5vdygpIC0gbyk7XG4gICAgICAgIGEudHRsID0gdSwgYS5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiN2ICYmIChhLnNpemUgPSB0aGlzLiN2W3RdKSwgYTtcbiAgfVxuICBkdW1wKCkge1xuICAgIGxldCBlID0gW107XG4gICAgZm9yIChsZXQgdCBvZiB0aGlzLiNiKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgbGV0IG4gPSB0aGlzLiNyW3RdLCBzID0gdGhpcy4jZVt0XSwgYSA9IHRoaXMuI3QocykgPyBzLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogcztcbiAgICAgIGlmIChhID09PSB2b2lkIDAgfHwgbiA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgIGxldCBpID0geyB2YWx1ZTogYSB9O1xuICAgICAgaWYgKHRoaXMuI2ggJiYgdGhpcy4jeCkge1xuICAgICAgICBpLnR0bCA9IHRoaXMuI2hbdF07XG4gICAgICAgIGxldCBvID0gRWUubm93KCkgLSB0aGlzLiN4W3RdO1xuICAgICAgICBpLnN0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC0gbyk7XG4gICAgICB9XG4gICAgICB0aGlzLiN2ICYmIChpLnNpemUgPSB0aGlzLiN2W3RdKSwgZS51bnNoaWZ0KFtuLCBpXSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGxvYWQoZSkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbdCwgbl0gb2YgZSkge1xuICAgICAgaWYgKG4uc3RhcnQpIHtcbiAgICAgICAgbGV0IHMgPSBEYXRlLm5vdygpIC0gbi5zdGFydDtcbiAgICAgICAgbi5zdGFydCA9IEVlLm5vdygpIC0gcztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KHQsIG4udmFsdWUsIG4pO1xuICAgIH1cbiAgfVxuICBzZXQoZSwgdCwgbiA9IHt9KSB7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuZGVsZXRlKGUpLCB0aGlzO1xuICAgIGxldCB7IHR0bDogcyA9IHRoaXMudHRsLCBzdGFydDogYSwgbm9EaXNwb3NlT25TZXQ6IGkgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplQ2FsY3VsYXRpb246IG8gPSB0aGlzLnNpemVDYWxjdWxhdGlvbiwgc3RhdHVzOiB1IH0gPSBuLCB7IG5vVXBkYXRlVFRMOiBsID0gdGhpcy5ub1VwZGF0ZVRUTCB9ID0gbiwgaCA9IHRoaXMuI1AoZSwgdCwgbi5zaXplIHx8IDAsIG8pO1xuICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAmJiBoID4gdGhpcy5tYXhFbnRyeVNpemUpIHJldHVybiB1ICYmICh1LnNldCA9IFwibWlzc1wiLCB1Lm1heEVudHJ5U2l6ZUV4Y2VlZGVkID0gdHJ1ZSksIHRoaXMuZGVsZXRlKGUpLCB0aGlzO1xuICAgIGxldCB2MiA9IHRoaXMuI3MgPT09IDAgPyB2b2lkIDAgOiB0aGlzLiNuLmdldChlKTtcbiAgICBpZiAodjIgPT09IHZvaWQgMCkgdjIgPSB0aGlzLiNzID09PSAwID8gdGhpcy4jYSA6IHRoaXMuI18ubGVuZ3RoICE9PSAwID8gdGhpcy4jXy5wb3AoKSA6IHRoaXMuI3MgPT09IHRoaXMuI3UgPyB0aGlzLiNqKGZhbHNlKSA6IHRoaXMuI3MsIHRoaXMuI3JbdjJdID0gZSwgdGhpcy4jZVt2Ml0gPSB0LCB0aGlzLiNuLnNldChlLCB2MiksIHRoaXMuI2xbdGhpcy4jYV0gPSB2MiwgdGhpcy4jZFt2Ml0gPSB0aGlzLiNhLCB0aGlzLiNhID0gdjIsIHRoaXMuI3MrKywgdGhpcy4jUih2MiwgaCwgdSksIHUgJiYgKHUuc2V0ID0gXCJhZGRcIiksIGwgPSBmYWxzZTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuI0EodjIpO1xuICAgICAgbGV0IFQzID0gdGhpcy4jZVt2Ml07XG4gICAgICBpZiAodCAhPT0gVDMpIHtcbiAgICAgICAgaWYgKHRoaXMuI1QgJiYgdGhpcy4jdChUMykpIHtcbiAgICAgICAgICBUMy5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJyZXBsYWNlZFwiKSk7XG4gICAgICAgICAgbGV0IHsgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IFMgfSA9IFQzO1xuICAgICAgICAgIFMgIT09IHZvaWQgMCAmJiAhaSAmJiAodGhpcy4jdyAmJiB0aGlzLiNtPy4oUywgZSwgXCJzZXRcIiksIHRoaXMuI2MgJiYgdGhpcy4jaT8ucHVzaChbUywgZSwgXCJzZXRcIl0pKTtcbiAgICAgICAgfSBlbHNlIGkgfHwgKHRoaXMuI3cgJiYgdGhpcy4jbT8uKFQzLCBlLCBcInNldFwiKSwgdGhpcy4jYyAmJiB0aGlzLiNpPy5wdXNoKFtUMywgZSwgXCJzZXRcIl0pKTtcbiAgICAgICAgaWYgKHRoaXMuI0UodjIpLCB0aGlzLiNSKHYyLCBoLCB1KSwgdGhpcy4jZVt2Ml0gPSB0LCB1KSB7XG4gICAgICAgICAgdS5zZXQgPSBcInJlcGxhY2VcIjtcbiAgICAgICAgICBsZXQgUyA9IFQzICYmIHRoaXMuI3QoVDMpID8gVDMuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiBUMztcbiAgICAgICAgICBTICE9PSB2b2lkIDAgJiYgKHUub2xkVmFsdWUgPSBTKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHUgJiYgKHUuc2V0ID0gXCJ1cGRhdGVcIik7XG4gICAgfVxuICAgIGlmIChzICE9PSAwICYmICF0aGlzLiNoICYmIHRoaXMuI04oKSwgdGhpcy4jaCAmJiAobCB8fCB0aGlzLiNMKHYyLCBzLCBhKSwgdSAmJiB0aGlzLiNrKHUsIHYyKSksICFpICYmIHRoaXMuI2MgJiYgdGhpcy4jaSkge1xuICAgICAgbGV0IFQzID0gdGhpcy4jaSwgUztcbiAgICAgIGZvciAoOyBTID0gVDM/LnNoaWZ0KCk7ICkgdGhpcy4jeT8uKC4uLlMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb3AoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyB0aGlzLiNzOyApIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLiNlW3RoaXMuI29dO1xuICAgICAgICBpZiAodGhpcy4jaih0cnVlKSwgdGhpcy4jdChlKSkge1xuICAgICAgICAgIGlmIChlLl9fc3RhbGVXaGlsZUZldGNoaW5nKSByZXR1cm4gZS5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgfSBlbHNlIGlmIChlICE9PSB2b2lkIDApIHJldHVybiBlO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy4jYyAmJiB0aGlzLiNpKSB7XG4gICAgICAgIGxldCBlID0gdGhpcy4jaSwgdDtcbiAgICAgICAgZm9yICg7IHQgPSBlPy5zaGlmdCgpOyApIHRoaXMuI3k/LiguLi50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2ooZSkge1xuICAgIGxldCB0ID0gdGhpcy4jbywgbiA9IHRoaXMuI3JbdF0sIHMgPSB0aGlzLiNlW3RdO1xuICAgIHJldHVybiB0aGlzLiNUICYmIHRoaXMuI3QocykgPyBzLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImV2aWN0ZWRcIikpIDogKHRoaXMuI3cgfHwgdGhpcy4jYykgJiYgKHRoaXMuI3cgJiYgdGhpcy4jbT8uKHMsIG4sIFwiZXZpY3RcIiksIHRoaXMuI2MgJiYgdGhpcy4jaT8ucHVzaChbcywgbiwgXCJldmljdFwiXSkpLCB0aGlzLiNFKHQpLCBlICYmICh0aGlzLiNyW3RdID0gdm9pZCAwLCB0aGlzLiNlW3RdID0gdm9pZCAwLCB0aGlzLiNfLnB1c2godCkpLCB0aGlzLiNzID09PSAxID8gKHRoaXMuI28gPSB0aGlzLiNhID0gMCwgdGhpcy4jXy5sZW5ndGggPSAwKSA6IHRoaXMuI28gPSB0aGlzLiNsW3RdLCB0aGlzLiNuLmRlbGV0ZShuKSwgdGhpcy4jcy0tLCB0O1xuICB9XG4gIGhhcyhlLCB0ID0ge30pIHtcbiAgICBsZXQgeyB1cGRhdGVBZ2VPbkhhczogbiA9IHRoaXMudXBkYXRlQWdlT25IYXMsIHN0YXR1czogcyB9ID0gdCwgYSA9IHRoaXMuI24uZ2V0KGUpO1xuICAgIGlmIChhICE9PSB2b2lkIDApIHtcbiAgICAgIGxldCBpID0gdGhpcy4jZVthXTtcbiAgICAgIGlmICh0aGlzLiN0KGkpICYmIGkuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHZvaWQgMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuI3AoYSkpIHMgJiYgKHMuaGFzID0gXCJzdGFsZVwiLCB0aGlzLiNrKHMsIGEpKTtcbiAgICAgIGVsc2UgcmV0dXJuIG4gJiYgdGhpcy4jTyhhKSwgcyAmJiAocy5oYXMgPSBcImhpdFwiLCB0aGlzLiNrKHMsIGEpKSwgdHJ1ZTtcbiAgICB9IGVsc2UgcyAmJiAocy5oYXMgPSBcIm1pc3NcIik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBlZWsoZSwgdCA9IHt9KSB7XG4gICAgbGV0IHsgYWxsb3dTdGFsZTogbiA9IHRoaXMuYWxsb3dTdGFsZSB9ID0gdCwgcyA9IHRoaXMuI24uZ2V0KGUpO1xuICAgIGlmIChzID09PSB2b2lkIDAgfHwgIW4gJiYgdGhpcy4jcChzKSkgcmV0dXJuO1xuICAgIGxldCBhID0gdGhpcy4jZVtzXTtcbiAgICByZXR1cm4gdGhpcy4jdChhKSA/IGEuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiBhO1xuICB9XG4gICNJKGUsIHQsIG4sIHMpIHtcbiAgICBsZXQgYSA9IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuI2VbdF07XG4gICAgaWYgKHRoaXMuI3QoYSkpIHJldHVybiBhO1xuICAgIGxldCBpID0gbmV3IGR0KCksIHsgc2lnbmFsOiBvIH0gPSBuO1xuICAgIG8/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBpLmFib3J0KG8ucmVhc29uKSwgeyBzaWduYWw6IGkuc2lnbmFsIH0pO1xuICAgIGxldCB1ID0geyBzaWduYWw6IGkuc2lnbmFsLCBvcHRpb25zOiBuLCBjb250ZXh0OiBzIH0sIGwgPSAoQSwgTCA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQgeyBhYm9ydGVkOiBPIH0gPSBpLnNpZ25hbCwgSTIgPSBuLmlnbm9yZUZldGNoQWJvcnQgJiYgQSAhPT0gdm9pZCAwO1xuICAgICAgaWYgKG4uc3RhdHVzICYmIChPICYmICFMID8gKG4uc3RhdHVzLmZldGNoQWJvcnRlZCA9IHRydWUsIG4uc3RhdHVzLmZldGNoRXJyb3IgPSBpLnNpZ25hbC5yZWFzb24sIEkyICYmIChuLnN0YXR1cy5mZXRjaEFib3J0SWdub3JlZCA9IHRydWUpKSA6IG4uc3RhdHVzLmZldGNoUmVzb2x2ZWQgPSB0cnVlKSwgTyAmJiAhSTIgJiYgIUwpIHJldHVybiB2MihpLnNpZ25hbC5yZWFzb24pO1xuICAgICAgbGV0IFYgPSBTO1xuICAgICAgcmV0dXJuIHRoaXMuI2VbdF0gPT09IFMgJiYgKEEgPT09IHZvaWQgMCA/IFYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPyB0aGlzLiNlW3RdID0gVi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHRoaXMuZGVsZXRlKGUpIDogKG4uc3RhdHVzICYmIChuLnN0YXR1cy5mZXRjaFVwZGF0ZWQgPSB0cnVlKSwgdGhpcy5zZXQoZSwgQSwgdS5vcHRpb25zKSkpLCBBO1xuICAgIH0sIGggPSAoQSkgPT4gKG4uc3RhdHVzICYmIChuLnN0YXR1cy5mZXRjaFJlamVjdGVkID0gdHJ1ZSwgbi5zdGF0dXMuZmV0Y2hFcnJvciA9IEEpLCB2MihBKSksIHYyID0gKEEpID0+IHtcbiAgICAgIGxldCB7IGFib3J0ZWQ6IEwgfSA9IGkuc2lnbmFsLCBPID0gTCAmJiBuLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIEkyID0gTyB8fCBuLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBWID0gSTIgfHwgbi5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sIEMyID0gUztcbiAgICAgIGlmICh0aGlzLiNlW3RdID09PSBTICYmICghViB8fCBDMi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdm9pZCAwID8gdGhpcy5kZWxldGUoZSkgOiBPIHx8ICh0aGlzLiNlW3RdID0gQzIuX19zdGFsZVdoaWxlRmV0Y2hpbmcpKSwgSTIpIHJldHVybiBuLnN0YXR1cyAmJiBDMi5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdm9pZCAwICYmIChuLnN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZSksIEMyLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgaWYgKEMyLl9fcmV0dXJuZWQgPT09IEMyKSB0aHJvdyBBO1xuICAgIH0sIFQzID0gKEEsIEwpID0+IHtcbiAgICAgIGxldCBPID0gdGhpcy4jQz8uKGUsIGEsIHUpO1xuICAgICAgTyAmJiBPIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBPLnRoZW4oKEkyKSA9PiBBKEkyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBJMiksIEwpLCBpLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAoIW4uaWdub3JlRmV0Y2hBYm9ydCB8fCBuLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpICYmIChBKHZvaWQgMCksIG4uYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCAmJiAoQSA9IChJMikgPT4gbChJMiwgdHJ1ZSkpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbi5zdGF0dXMgJiYgKG4uc3RhdHVzLmZldGNoRGlzcGF0Y2hlZCA9IHRydWUpO1xuICAgIGxldCBTID0gbmV3IFByb21pc2UoVDMpLnRoZW4obCwgaCksIEIyID0gT2JqZWN0LmFzc2lnbihTLCB7IF9fYWJvcnRDb250cm9sbGVyOiBpLCBfX3N0YWxlV2hpbGVGZXRjaGluZzogYSwgX19yZXR1cm5lZDogdm9pZCAwIH0pO1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyAodGhpcy5zZXQoZSwgQjIsIHsgLi4udS5vcHRpb25zLCBzdGF0dXM6IHZvaWQgMCB9KSwgdCA9IHRoaXMuI24uZ2V0KGUpKSA6IHRoaXMuI2VbdF0gPSBCMiwgQjI7XG4gIH1cbiAgI3QoZSkge1xuICAgIGlmICghdGhpcy4jVCkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ID0gZTtcbiAgICByZXR1cm4gISF0ICYmIHQgaW5zdGFuY2VvZiBQcm9taXNlICYmIHQuaGFzT3duUHJvcGVydHkoXCJfX3N0YWxlV2hpbGVGZXRjaGluZ1wiKSAmJiB0Ll9fYWJvcnRDb250cm9sbGVyIGluc3RhbmNlb2YgZHQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goZSwgdCA9IHt9KSB7XG4gICAgbGV0IHsgYWxsb3dTdGFsZTogbiA9IHRoaXMuYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQ6IHMgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LCBub0RlbGV0ZU9uU3RhbGVHZXQ6IGEgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCwgdHRsOiBpID0gdGhpcy50dGwsIG5vRGlzcG9zZU9uU2V0OiBvID0gdGhpcy5ub0Rpc3Bvc2VPblNldCwgc2l6ZTogdSA9IDAsIHNpemVDYWxjdWxhdGlvbjogbCA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBub1VwZGF0ZVRUTDogaCA9IHRoaXMubm9VcGRhdGVUVEwsIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjogdjIgPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb246IFQzID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiwgaWdub3JlRmV0Y2hBYm9ydDogUyA9IHRoaXMuaWdub3JlRmV0Y2hBYm9ydCwgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDogQjIgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGNvbnRleHQ6IEEsIGZvcmNlUmVmcmVzaDogTCA9IGZhbHNlLCBzdGF0dXM6IE8sIHNpZ25hbDogSTIgfSA9IHQ7XG4gICAgaWYgKCF0aGlzLiNUKSByZXR1cm4gTyAmJiAoTy5mZXRjaCA9IFwiZ2V0XCIpLCB0aGlzLmdldChlLCB7IGFsbG93U3RhbGU6IG4sIHVwZGF0ZUFnZU9uR2V0OiBzLCBub0RlbGV0ZU9uU3RhbGVHZXQ6IGEsIHN0YXR1czogTyB9KTtcbiAgICBsZXQgViA9IHsgYWxsb3dTdGFsZTogbiwgdXBkYXRlQWdlT25HZXQ6IHMsIG5vRGVsZXRlT25TdGFsZUdldDogYSwgdHRsOiBpLCBub0Rpc3Bvc2VPblNldDogbywgc2l6ZTogdSwgc2l6ZUNhbGN1bGF0aW9uOiBsLCBub1VwZGF0ZVRUTDogaCwgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uOiB2MiwgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb246IFQzLCBhbGxvd1N0YWxlT25GZXRjaEFib3J0OiBCMiwgaWdub3JlRmV0Y2hBYm9ydDogUywgc3RhdHVzOiBPLCBzaWduYWw6IEkyIH0sIEMyID0gdGhpcy4jbi5nZXQoZSk7XG4gICAgaWYgKEMyID09PSB2b2lkIDApIHtcbiAgICAgIE8gJiYgKE8uZmV0Y2ggPSBcIm1pc3NcIik7XG4gICAgICBsZXQgVyA9IHRoaXMuI0koZSwgQzIsIFYsIEEpO1xuICAgICAgcmV0dXJuIFcuX19yZXR1cm5lZCA9IFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBXID0gdGhpcy4jZVtDMl07XG4gICAgICBpZiAodGhpcy4jdChXKSkge1xuICAgICAgICBsZXQgSnQgPSBuICYmIFcuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIE8gJiYgKE8uZmV0Y2ggPSBcImluZmxpZ2h0XCIsIEp0ICYmIChPLnJldHVybmVkU3RhbGUgPSB0cnVlKSksIEp0ID8gVy5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IFcuX19yZXR1cm5lZCA9IFc7XG4gICAgICB9XG4gICAgICBsZXQgb2UgPSB0aGlzLiNwKEMyKTtcbiAgICAgIGlmICghTCAmJiAhb2UpIHJldHVybiBPICYmIChPLmZldGNoID0gXCJoaXRcIiksIHRoaXMuI0EoQzIpLCBzICYmIHRoaXMuI08oQzIpLCBPICYmIHRoaXMuI2soTywgQzIpLCBXO1xuICAgICAgbGV0IFEyID0gdGhpcy4jSShlLCBDMiwgViwgQSksIFl0MiA9IFEyLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB2b2lkIDAgJiYgbjtcbiAgICAgIHJldHVybiBPICYmIChPLmZldGNoID0gb2UgPyBcInN0YWxlXCIgOiBcInJlZnJlc2hcIiwgWXQyICYmIG9lICYmIChPLnJldHVybmVkU3RhbGUgPSB0cnVlKSksIFl0MiA/IFEyLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogUTIuX19yZXR1cm5lZCA9IFEyO1xuICAgIH1cbiAgfVxuICBnZXQoZSwgdCA9IHt9KSB7XG4gICAgbGV0IHsgYWxsb3dTdGFsZTogbiA9IHRoaXMuYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQ6IHMgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LCBub0RlbGV0ZU9uU3RhbGVHZXQ6IGEgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCwgc3RhdHVzOiBpIH0gPSB0LCBvID0gdGhpcy4jbi5nZXQoZSk7XG4gICAgaWYgKG8gIT09IHZvaWQgMCkge1xuICAgICAgbGV0IHUgPSB0aGlzLiNlW29dLCBsID0gdGhpcy4jdCh1KTtcbiAgICAgIHJldHVybiBpICYmIHRoaXMuI2soaSwgbyksIHRoaXMuI3AobykgPyAoaSAmJiAoaS5nZXQgPSBcInN0YWxlXCIpLCBsID8gKGkgJiYgbiAmJiB1Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB2b2lkIDAgJiYgKGkucmV0dXJuZWRTdGFsZSA9IHRydWUpLCBuID8gdS5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHZvaWQgMCkgOiAoYSB8fCB0aGlzLmRlbGV0ZShlKSwgaSAmJiBuICYmIChpLnJldHVybmVkU3RhbGUgPSB0cnVlKSwgbiA/IHUgOiB2b2lkIDApKSA6IChpICYmIChpLmdldCA9IFwiaGl0XCIpLCBsID8gdS5fX3N0YWxlV2hpbGVGZXRjaGluZyA6ICh0aGlzLiNBKG8pLCBzICYmIHRoaXMuI08obyksIHUpKTtcbiAgICB9IGVsc2UgaSAmJiAoaS5nZXQgPSBcIm1pc3NcIik7XG4gIH1cbiAgI1coZSwgdCkge1xuICAgIHRoaXMuI2RbdF0gPSBlLCB0aGlzLiNsW2VdID0gdDtcbiAgfVxuICAjQShlKSB7XG4gICAgZSAhPT0gdGhpcy4jYSAmJiAoZSA9PT0gdGhpcy4jbyA/IHRoaXMuI28gPSB0aGlzLiNsW2VdIDogdGhpcy4jVyh0aGlzLiNkW2VdLCB0aGlzLiNsW2VdKSwgdGhpcy4jVyh0aGlzLiNhLCBlKSwgdGhpcy4jYSA9IGUpO1xuICB9XG4gIGRlbGV0ZShlKSB7XG4gICAgbGV0IHQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jcyAhPT0gMCkge1xuICAgICAgbGV0IG4gPSB0aGlzLiNuLmdldChlKTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIGlmICh0ID0gdHJ1ZSwgdGhpcy4jcyA9PT0gMSkgdGhpcy5jbGVhcigpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuI0Uobik7XG4gICAgICAgIGxldCBzID0gdGhpcy4jZVtuXTtcbiAgICAgICAgaWYgKHRoaXMuI3QocykgPyBzLl9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImRlbGV0ZWRcIikpIDogKHRoaXMuI3cgfHwgdGhpcy4jYykgJiYgKHRoaXMuI3cgJiYgdGhpcy4jbT8uKHMsIGUsIFwiZGVsZXRlXCIpLCB0aGlzLiNjICYmIHRoaXMuI2k/LnB1c2goW3MsIGUsIFwiZGVsZXRlXCJdKSksIHRoaXMuI24uZGVsZXRlKGUpLCB0aGlzLiNyW25dID0gdm9pZCAwLCB0aGlzLiNlW25dID0gdm9pZCAwLCBuID09PSB0aGlzLiNhKSB0aGlzLiNhID0gdGhpcy4jZFtuXTtcbiAgICAgICAgZWxzZSBpZiAobiA9PT0gdGhpcy4jbykgdGhpcy4jbyA9IHRoaXMuI2xbbl07XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBhID0gdGhpcy4jZFtuXTtcbiAgICAgICAgICB0aGlzLiNsW2FdID0gdGhpcy4jbFtuXTtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMuI2xbbl07XG4gICAgICAgICAgdGhpcy4jZFtpXSA9IHRoaXMuI2Rbbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcy0tLCB0aGlzLiNfLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNjICYmIHRoaXMuI2k/Lmxlbmd0aCkge1xuICAgICAgbGV0IG4gPSB0aGlzLiNpLCBzO1xuICAgICAgZm9yICg7IHMgPSBuPy5zaGlmdCgpOyApIHRoaXMuI3k/LiguLi5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgZSBvZiB0aGlzLiNTKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgbGV0IHQgPSB0aGlzLiNlW2VdO1xuICAgICAgaWYgKHRoaXMuI3QodCkpIHQuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKFwiZGVsZXRlZFwiKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLiNyW2VdO1xuICAgICAgICB0aGlzLiN3ICYmIHRoaXMuI20/Lih0LCBuLCBcImRlbGV0ZVwiKSwgdGhpcy4jYyAmJiB0aGlzLiNpPy5wdXNoKFt0LCBuLCBcImRlbGV0ZVwiXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNuLmNsZWFyKCksIHRoaXMuI2UuZmlsbCh2b2lkIDApLCB0aGlzLiNyLmZpbGwodm9pZCAwKSwgdGhpcy4jaCAmJiB0aGlzLiN4ICYmICh0aGlzLiNoLmZpbGwoMCksIHRoaXMuI3guZmlsbCgwKSksIHRoaXMuI3YgJiYgdGhpcy4jdi5maWxsKDApLCB0aGlzLiNvID0gMCwgdGhpcy4jYSA9IDAsIHRoaXMuI18ubGVuZ3RoID0gMCwgdGhpcy4jZyA9IDAsIHRoaXMuI3MgPSAwLCB0aGlzLiNjICYmIHRoaXMuI2kpIHtcbiAgICAgIGxldCBlID0gdGhpcy4jaSwgdDtcbiAgICAgIGZvciAoOyB0ID0gZT8uc2hpZnQoKTsgKSB0aGlzLiN5Py4oLi4udCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gRXIoeyBzaXplOiByMTggfSkge1xuICByZXR1cm4gbmV3IGh0KHsgbWF4OiByMTgsIG1heFNpemU6IDVlNiwgc2l6ZUNhbGN1bGF0aW9uOiAodCkgPT4gSlNPTi5zdHJpbmdpZnkodCkubGVuZ3RoLCBhbGxvd1N0YWxlOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gQXIoeyBjYWNoZTogcjE4IH0pIHtcbiAgcmV0dXJuIGFzeW5jIChlKSA9PiB7XG4gICAgaWYgKHIxOC5tYXgpIHJldHVybiByMTguZ2V0KGUpO1xuICB9O1xufVxuZnVuY3Rpb24gQ3IoeyBjYWNoZTogcjE4IH0pIHtcbiAgcmV0dXJuIGFzeW5jIChlLCB7IHVybDogdCwgYWRkcmVzczogbiB9LCBzKSA9PiB7XG4gICAgaWYgKHIxOC5tYXgpIHJldHVybiByMTguc2V0KGUsIHsgdXJsOiB0LCBhZGRyZXNzOiBuIH0sIHsgdHRsOiBzIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gUnIoeyBjYWNoZTogcjE4IH0pIHtcbiAgcmV0dXJuIGFzeW5jIChlKSA9PiB7XG4gICAgaWYgKHIxOC5tYXgpIHJldHVybiByMTguZ2V0KGUpO1xuICB9O1xufVxuZnVuY3Rpb24ganIoeyBjYWNoZTogcjE4IH0pIHtcbiAgcmV0dXJuIGFzeW5jIChlLCB0LCBuKSA9PiB7XG4gICAgaWYgKHIxOC5tYXgpIHJldHVybiByMTguc2V0KGUsIHsgdXJsOiB0LCBhZGRyZXNzOiBlLCB0dGw6IG4gfSwgeyB0dGw6IG4gfSk7XG4gIH07XG59XG5mdW5jdGlvbiBJcih7IGZldGNoOiByMTggfSkge1xuICByZXR1cm4gYXN5bmMgKGUsIHQpID0+IHtcbiAgICBsZXQgbiA9IGF3YWl0IHIxOChgJHtlfT9wcm9jZXNzLWlkPSR7dH1gLCB7IG1ldGhvZDogXCJHRVRcIiwgcmVkaXJlY3Q6IFwibWFudWFsXCIgfSk7XG4gICAgcmV0dXJuIFszMDEsIDMwMiwgMzA3LCAzMDhdLmluY2x1ZGVzKG4uc3RhdHVzKSA/IG5ldyBVUkwobi5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpKS5vcmlnaW4gOiBlO1xuICB9O1xufVxudmFyIHc7XG4oZnVuY3Rpb24ocjE4KSB7XG4gIHIxOC5hc3NlcnRFcXVhbCA9IChzKSA9PiBzO1xuICBmdW5jdGlvbiBlKHMpIHtcbiAgfVxuICByMTguYXNzZXJ0SXMgPSBlO1xuICBmdW5jdGlvbiB0KHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICByMTguYXNzZXJ0TmV2ZXIgPSB0LCByMTguYXJyYXlUb0VudW0gPSAocykgPT4ge1xuICAgIGxldCBhID0ge307XG4gICAgZm9yIChsZXQgaSBvZiBzKSBhW2ldID0gaTtcbiAgICByZXR1cm4gYTtcbiAgfSwgcjE4LmdldFZhbGlkRW51bVZhbHVlcyA9IChzKSA9PiB7XG4gICAgbGV0IGEgPSByMTgub2JqZWN0S2V5cyhzKS5maWx0ZXIoKG8pID0+IHR5cGVvZiBzW3Nbb11dICE9IFwibnVtYmVyXCIpLCBpID0ge307XG4gICAgZm9yIChsZXQgbyBvZiBhKSBpW29dID0gc1tvXTtcbiAgICByZXR1cm4gcjE4Lm9iamVjdFZhbHVlcyhpKTtcbiAgfSwgcjE4Lm9iamVjdFZhbHVlcyA9IChzKSA9PiByMTgub2JqZWN0S2V5cyhzKS5tYXAoZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiBzW2FdO1xuICB9KSwgcjE4Lm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT0gXCJmdW5jdGlvblwiID8gKHMpID0+IE9iamVjdC5rZXlzKHMpIDogKHMpID0+IHtcbiAgICBsZXQgYSA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gcykgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIGkpICYmIGEucHVzaChpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwgcjE4LmZpbmQgPSAocywgYSkgPT4ge1xuICAgIGZvciAobGV0IGkgb2YgcykgaWYgKGEoaSkpIHJldHVybiBpO1xuICB9LCByMTguaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT0gXCJmdW5jdGlvblwiID8gKHMpID0+IE51bWJlci5pc0ludGVnZXIocykgOiAocykgPT4gdHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShzKSAmJiBNYXRoLmZsb29yKHMpID09PSBzO1xuICBmdW5jdGlvbiBuKHMsIGEgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIHMubWFwKChpKSA9PiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gYCcke2l9J2AgOiBpKS5qb2luKGEpO1xuICB9XG4gIHIxOC5qb2luVmFsdWVzID0gbiwgcjE4Lmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChzLCBhKSA9PiB0eXBlb2YgYSA9PSBcImJpZ2ludFwiID8gYS50b1N0cmluZygpIDogYTtcbn0pKHcgfHwgKHcgPSB7fSkpO1xudmFyIHF0O1xuKGZ1bmN0aW9uKHIxOCkge1xuICByMTgubWVyZ2VTaGFwZXMgPSAoZSwgdCkgPT4gKHsgLi4uZSwgLi4udCB9KTtcbn0pKHF0IHx8IChxdCA9IHt9KSk7XG52YXIgZCA9IHcuYXJyYXlUb0VudW0oW1wic3RyaW5nXCIsIFwibmFuXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImZsb2F0XCIsIFwiYm9vbGVhblwiLCBcImRhdGVcIiwgXCJiaWdpbnRcIiwgXCJzeW1ib2xcIiwgXCJmdW5jdGlvblwiLCBcInVuZGVmaW5lZFwiLCBcIm51bGxcIiwgXCJhcnJheVwiLCBcIm9iamVjdFwiLCBcInVua25vd25cIiwgXCJwcm9taXNlXCIsIFwidm9pZFwiLCBcIm5ldmVyXCIsIFwibWFwXCIsIFwic2V0XCJdKTtcbnZhciBuZSA9IChyMTgpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgcjE4KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIGQudW5kZWZpbmVkO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBkLnN0cmluZztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gaXNOYU4ocjE4KSA/IGQubmFuIDogZC5udW1iZXI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBkLmJvb2xlYW47XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gZC5mdW5jdGlvbjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gZC5iaWdpbnQ7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIGQuc3ltYm9sO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHIxOCkgPyBkLmFycmF5IDogcjE4ID09PSBudWxsID8gZC5udWxsIDogcjE4LnRoZW4gJiYgdHlwZW9mIHIxOC50aGVuID09IFwiZnVuY3Rpb25cIiAmJiByMTguY2F0Y2ggJiYgdHlwZW9mIHIxOC5jYXRjaCA9PSBcImZ1bmN0aW9uXCIgPyBkLnByb21pc2UgOiB0eXBlb2YgTWFwIDwgXCJ1XCIgJiYgcjE4IGluc3RhbmNlb2YgTWFwID8gZC5tYXAgOiB0eXBlb2YgU2V0IDwgXCJ1XCIgJiYgcjE4IGluc3RhbmNlb2YgU2V0ID8gZC5zZXQgOiB0eXBlb2YgRGF0ZSA8IFwidVwiICYmIHIxOCBpbnN0YW5jZW9mIERhdGUgPyBkLmRhdGUgOiBkLm9iamVjdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGQudW5rbm93bjtcbiAgfVxufTtcbnZhciBjID0gdy5hcnJheVRvRW51bShbXCJpbnZhbGlkX3R5cGVcIiwgXCJpbnZhbGlkX2xpdGVyYWxcIiwgXCJjdXN0b21cIiwgXCJpbnZhbGlkX3VuaW9uXCIsIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsIFwidW5yZWNvZ25pemVkX2tleXNcIiwgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLCBcImludmFsaWRfcmV0dXJuX3R5cGVcIiwgXCJpbnZhbGlkX2RhdGVcIiwgXCJpbnZhbGlkX3N0cmluZ1wiLCBcInRvb19zbWFsbFwiLCBcInRvb19iaWdcIiwgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLCBcIm5vdF9tdWx0aXBsZV9vZlwiLCBcIm5vdF9maW5pdGVcIl0pO1xudmFyIFZuID0gKHIxOCkgPT4gSlNPTi5zdHJpbmdpZnkocjE4LCBudWxsLCAyKS5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xudmFyIFAgPSBjbGFzcyByMyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMuaXNzdWVzID0gW10sIHRoaXMuYWRkSXNzdWUgPSAobikgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIG5dO1xuICAgIH0sIHRoaXMuYWRkSXNzdWVzID0gKG4gPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLm5dO1xuICAgIH07XG4gICAgbGV0IHQgPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgdCkgOiB0aGlzLl9fcHJvdG9fXyA9IHQsIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIiwgdGhpcy5pc3N1ZXMgPSBlO1xuICB9XG4gIGdldCBlcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICB9XG4gIGZvcm1hdChlKSB7XG4gICAgbGV0IHQgPSBlIHx8IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBhLm1lc3NhZ2U7XG4gICAgfSwgbiA9IHsgX2Vycm9yczogW10gfSwgcyA9IChhKSA9PiB7XG4gICAgICBmb3IgKGxldCBpIG9mIGEuaXNzdWVzKSBpZiAoaS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikgaS51bmlvbkVycm9ycy5tYXAocyk7XG4gICAgICBlbHNlIGlmIChpLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSBzKGkucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgIGVsc2UgaWYgKGkuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSBzKGkuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgZWxzZSBpZiAoaS5wYXRoLmxlbmd0aCA9PT0gMCkgbi5fZXJyb3JzLnB1c2godChpKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG8gPSBuLCB1ID0gMDtcbiAgICAgICAgZm9yICg7IHUgPCBpLnBhdGgubGVuZ3RoOyApIHtcbiAgICAgICAgICBsZXQgbCA9IGkucGF0aFt1XTtcbiAgICAgICAgICB1ID09PSBpLnBhdGgubGVuZ3RoIC0gMSA/IChvW2xdID0gb1tsXSB8fCB7IF9lcnJvcnM6IFtdIH0sIG9bbF0uX2Vycm9ycy5wdXNoKHQoaSkpKSA6IG9bbF0gPSBvW2xdIHx8IHsgX2Vycm9yczogW10gfSwgbyA9IG9bbF0sIHUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHModGhpcyksIG47XG4gIH1cbiAgc3RhdGljIGFzc2VydChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIHIzKSkgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHtlfWApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB3Lmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKGUgPSAodCkgPT4gdC5tZXNzYWdlKSB7XG4gICAgbGV0IHQgPSB7fSwgbiA9IFtdO1xuICAgIGZvciAobGV0IHMgb2YgdGhpcy5pc3N1ZXMpIHMucGF0aC5sZW5ndGggPiAwID8gKHRbcy5wYXRoWzBdXSA9IHRbcy5wYXRoWzBdXSB8fCBbXSwgdFtzLnBhdGhbMF1dLnB1c2goZShzKSkpIDogbi5wdXNoKGUocykpO1xuICAgIHJldHVybiB7IGZvcm1FcnJvcnM6IG4sIGZpZWxkRXJyb3JzOiB0IH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59O1xuUC5jcmVhdGUgPSAocjE4KSA9PiBuZXcgUChyMTgpO1xudmFyIGplID0gKHIxOCwgZSkgPT4ge1xuICBsZXQgdDtcbiAgc3dpdGNoIChyMTguY29kZSkge1xuICAgIGNhc2UgYy5pbnZhbGlkX3R5cGU6XG4gICAgICByMTgucmVjZWl2ZWQgPT09IGQudW5kZWZpbmVkID8gdCA9IFwiUmVxdWlyZWRcIiA6IHQgPSBgRXhwZWN0ZWQgJHtyMTguZXhwZWN0ZWR9LCByZWNlaXZlZCAke3IxOC5yZWNlaXZlZH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBjLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgIHQgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KHIxOC5leHBlY3RlZCwgdy5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICB0ID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3cuam9pblZhbHVlcyhyMTgua2V5cywgXCIsIFwiKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBjLmludmFsaWRfdW5pb246XG4gICAgICB0ID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgdCA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dy5qb2luVmFsdWVzKHIxOC5vcHRpb25zKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBjLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgIHQgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3cuam9pblZhbHVlcyhyMTgub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtyMTgucmVjZWl2ZWR9J2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICB0ID0gXCJJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBjLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICB0ID0gXCJJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMuaW52YWxpZF9kYXRlOlxuICAgICAgdCA9IFwiSW52YWxpZCBkYXRlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMuaW52YWxpZF9zdHJpbmc6XG4gICAgICB0eXBlb2YgcjE4LnZhbGlkYXRpb24gPT0gXCJvYmplY3RcIiA/IFwiaW5jbHVkZXNcIiBpbiByMTgudmFsaWRhdGlvbiA/ICh0ID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7cjE4LnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgLCB0eXBlb2YgcjE4LnZhbGlkYXRpb24ucG9zaXRpb24gPT0gXCJudW1iZXJcIiAmJiAodCA9IGAke3R9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtyMTgudmFsaWRhdGlvbi5wb3NpdGlvbn1gKSkgOiBcInN0YXJ0c1dpdGhcIiBpbiByMTgudmFsaWRhdGlvbiA/IHQgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtyMTgudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYCA6IFwiZW5kc1dpdGhcIiBpbiByMTgudmFsaWRhdGlvbiA/IHQgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7cjE4LnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgIDogdy5hc3NlcnROZXZlcihyMTgudmFsaWRhdGlvbikgOiByMTgudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiID8gdCA9IGBJbnZhbGlkICR7cjE4LnZhbGlkYXRpb259YCA6IHQgPSBcIkludmFsaWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYy50b29fc21hbGw6XG4gICAgICByMTgudHlwZSA9PT0gXCJhcnJheVwiID8gdCA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtyMTguZXhhY3QgPyBcImV4YWN0bHlcIiA6IHIxOC5pbmNsdXNpdmUgPyBcImF0IGxlYXN0XCIgOiBcIm1vcmUgdGhhblwifSAke3IxOC5taW5pbXVtfSBlbGVtZW50KHMpYCA6IHIxOC50eXBlID09PSBcInN0cmluZ1wiID8gdCA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7cjE4LmV4YWN0ID8gXCJleGFjdGx5XCIgOiByMTguaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJvdmVyXCJ9ICR7cjE4Lm1pbmltdW19IGNoYXJhY3RlcihzKWAgOiByMTgudHlwZSA9PT0gXCJudW1iZXJcIiA/IHQgPSBgTnVtYmVyIG11c3QgYmUgJHtyMTguZXhhY3QgPyBcImV4YWN0bHkgZXF1YWwgdG8gXCIgOiByMTguaW5jbHVzaXZlID8gXCJncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gXCIgOiBcImdyZWF0ZXIgdGhhbiBcIn0ke3IxOC5taW5pbXVtfWAgOiByMTgudHlwZSA9PT0gXCJkYXRlXCIgPyB0ID0gYERhdGUgbXVzdCBiZSAke3IxOC5leGFjdCA/IFwiZXhhY3RseSBlcXVhbCB0byBcIiA6IHIxOC5pbmNsdXNpdmUgPyBcImdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcIiA6IFwiZ3JlYXRlciB0aGFuIFwifSR7bmV3IERhdGUoTnVtYmVyKHIxOC5taW5pbXVtKSl9YCA6IHQgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYy50b29fYmlnOlxuICAgICAgcjE4LnR5cGUgPT09IFwiYXJyYXlcIiA/IHQgPSBgQXJyYXkgbXVzdCBjb250YWluICR7cjE4LmV4YWN0ID8gXCJleGFjdGx5XCIgOiByMTguaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcImxlc3MgdGhhblwifSAke3IxOC5tYXhpbXVtfSBlbGVtZW50KHMpYCA6IHIxOC50eXBlID09PSBcInN0cmluZ1wiID8gdCA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7cjE4LmV4YWN0ID8gXCJleGFjdGx5XCIgOiByMTguaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcInVuZGVyXCJ9ICR7cjE4Lm1heGltdW19IGNoYXJhY3RlcihzKWAgOiByMTgudHlwZSA9PT0gXCJudW1iZXJcIiA/IHQgPSBgTnVtYmVyIG11c3QgYmUgJHtyMTguZXhhY3QgPyBcImV4YWN0bHlcIiA6IHIxOC5pbmNsdXNpdmUgPyBcImxlc3MgdGhhbiBvciBlcXVhbCB0b1wiIDogXCJsZXNzIHRoYW5cIn0gJHtyMTgubWF4aW11bX1gIDogcjE4LnR5cGUgPT09IFwiYmlnaW50XCIgPyB0ID0gYEJpZ0ludCBtdXN0IGJlICR7cjE4LmV4YWN0ID8gXCJleGFjdGx5XCIgOiByMTguaW5jbHVzaXZlID8gXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwibGVzcyB0aGFuXCJ9ICR7cjE4Lm1heGltdW19YCA6IHIxOC50eXBlID09PSBcImRhdGVcIiA/IHQgPSBgRGF0ZSBtdXN0IGJlICR7cjE4LmV4YWN0ID8gXCJleGFjdGx5XCIgOiByMTguaW5jbHVzaXZlID8gXCJzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwic21hbGxlciB0aGFuXCJ9ICR7bmV3IERhdGUoTnVtYmVyKHIxOC5tYXhpbXVtKSl9YCA6IHQgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYy5jdXN0b206XG4gICAgICB0ID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICB0ID0gXCJJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGMubm90X211bHRpcGxlX29mOlxuICAgICAgdCA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7cjE4Lm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYy5ub3RfZmluaXRlOlxuICAgICAgdCA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdCA9IGUuZGVmYXVsdEVycm9yLCB3LmFzc2VydE5ldmVyKHIxOCk7XG4gIH1cbiAgcmV0dXJuIHsgbWVzc2FnZTogdCB9O1xufTtcbnZhciBQciA9IGplO1xuZnVuY3Rpb24gcW4ocjE4KSB7XG4gIFByID0gcjE4O1xufVxuZnVuY3Rpb24gcHQoKSB7XG4gIHJldHVybiBQcjtcbn1cbnZhciBtdCA9IChyMTgpID0+IHtcbiAgbGV0IHsgZGF0YTogZSwgcGF0aDogdCwgZXJyb3JNYXBzOiBuLCBpc3N1ZURhdGE6IHMgfSA9IHIxOCwgYSA9IFsuLi50LCAuLi5zLnBhdGggfHwgW11dLCBpID0geyAuLi5zLCBwYXRoOiBhIH07XG4gIGlmIChzLm1lc3NhZ2UgIT09IHZvaWQgMCkgcmV0dXJuIHsgLi4ucywgcGF0aDogYSwgbWVzc2FnZTogcy5tZXNzYWdlIH07XG4gIGxldCBvID0gXCJcIiwgdSA9IG4uZmlsdGVyKChsKSA9PiAhIWwpLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBmb3IgKGxldCBsIG9mIHUpIG8gPSBsKGksIHsgZGF0YTogZSwgZGVmYXVsdEVycm9yOiBvIH0pLm1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLnMsIHBhdGg6IGEsIG1lc3NhZ2U6IG8gfTtcbn07XG52YXIgR24gPSBbXTtcbmZ1bmN0aW9uIGYocjE4LCBlKSB7XG4gIGxldCB0ID0gcHQoKSwgbiA9IG10KHsgaXNzdWVEYXRhOiBlLCBkYXRhOiByMTguZGF0YSwgcGF0aDogcjE4LnBhdGgsIGVycm9yTWFwczogW3IxOC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCByMTguc2NoZW1hRXJyb3JNYXAsIHQsIHQgPT09IGplID8gdm9pZCAwIDogamVdLmZpbHRlcigocykgPT4gISFzKSB9KTtcbiAgcjE4LmNvbW1vbi5pc3N1ZXMucHVzaChuKTtcbn1cbnZhciBSID0gY2xhc3MgcjQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICB9XG4gIGRpcnR5KCkge1xuICAgIHRoaXMudmFsdWUgPT09IFwidmFsaWRcIiAmJiAodGhpcy52YWx1ZSA9IFwiZGlydHlcIik7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIgJiYgKHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIik7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoZSwgdCkge1xuICAgIGxldCBuID0gW107XG4gICAgZm9yIChsZXQgcyBvZiB0KSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgIHMuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgZS5kaXJ0eSgpLCBuLnB1c2gocy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogZS52YWx1ZSwgdmFsdWU6IG4gfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhlLCB0KSB7XG4gICAgbGV0IG4gPSBbXTtcbiAgICBmb3IgKGxldCBzIG9mIHQpIHtcbiAgICAgIGxldCBhID0gYXdhaXQgcy5rZXksIGkgPSBhd2FpdCBzLnZhbHVlO1xuICAgICAgbi5wdXNoKHsga2V5OiBhLCB2YWx1ZTogaSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHI0Lm1lcmdlT2JqZWN0U3luYyhlLCBuKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKGUsIHQpIHtcbiAgICBsZXQgbiA9IHt9O1xuICAgIGZvciAobGV0IHMgb2YgdCkge1xuICAgICAgbGV0IHsga2V5OiBhLCB2YWx1ZTogaSB9ID0gcztcbiAgICAgIGlmIChhLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgaS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgIGEuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgZS5kaXJ0eSgpLCBpLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIGUuZGlydHkoKSwgYS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIGkudmFsdWUgPCBcInVcIiB8fCBzLmFsd2F5c1NldCkgJiYgKG5bYS52YWx1ZV0gPSBpLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBlLnZhbHVlLCB2YWx1ZTogbiB9O1xuICB9XG59O1xudmFyIHkgPSBPYmplY3QuZnJlZXplKHsgc3RhdHVzOiBcImFib3J0ZWRcIiB9KTtcbnZhciBSZSA9IChyMTgpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZTogcjE4IH0pO1xudmFyIGogPSAocjE4KSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IHIxOCB9KTtcbnZhciBHdCA9IChyMTgpID0+IHIxOC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xudmFyIEh0ID0gKHIxOCkgPT4gcjE4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xudmFyIEplID0gKHIxOCkgPT4gcjE4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xudmFyIHl0ID0gKHIxOCkgPT4gdHlwZW9mIFByb21pc2UgPCBcInVcIiAmJiByMTggaW5zdGFuY2VvZiBQcm9taXNlO1xuZnVuY3Rpb24gZ3QocjE4LCBlLCB0LCBuKSB7XG4gIGlmICh0ID09PSBcImFcIiAmJiAhbikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IHIxOCAhPT0gZSB8fCAhbiA6ICFlLmhhcyhyMTgpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gdCA9PT0gXCJtXCIgPyBuIDogdCA9PT0gXCJhXCIgPyBuLmNhbGwocjE4KSA6IG4gPyBuLnZhbHVlIDogZS5nZXQocjE4KTtcbn1cbmZ1bmN0aW9uIFpyKHIxOCwgZSwgdCwgbiwgcykge1xuICBpZiAobiA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChuID09PSBcImFcIiAmJiAhcykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IHIxOCAhPT0gZSB8fCAhcyA6ICFlLmhhcyhyMTgpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBuID09PSBcImFcIiA/IHMuY2FsbChyMTgsIHQpIDogcyA/IHMudmFsdWUgPSB0IDogZS5zZXQocjE4LCB0KSwgdDtcbn1cbnZhciBwO1xuKGZ1bmN0aW9uKHIxOCkge1xuICByMTguZXJyVG9PYmogPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogZSB9IDogZSB8fCB7fSwgcjE4LnRvU3RyaW5nID0gKGUpID0+IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZT8ubWVzc2FnZTtcbn0pKHAgfHwgKHAgPSB7fSkpO1xudmFyIFhlO1xudmFyIFllO1xudmFyIE0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG4sIHMpIHtcbiAgICB0aGlzLl9jYWNoZWRQYXRoID0gW10sIHRoaXMucGFyZW50ID0gZSwgdGhpcy5kYXRhID0gdCwgdGhpcy5fcGF0aCA9IG4sIHRoaXMuX2tleSA9IHM7XG4gIH1cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoIHx8ICh0aGlzLl9rZXkgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpIDogdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSkpLCB0aGlzLl9jYWNoZWRQYXRoO1xuICB9XG59O1xudmFyIE5yID0gKHIxOCwgZSkgPT4ge1xuICBpZiAoSmUoZSkpIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGUudmFsdWUgfTtcbiAgaWYgKCFyMTguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZ2V0IGVycm9yKCkge1xuICAgIGlmICh0aGlzLl9lcnJvcikgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgIGxldCB0ID0gbmV3IFAocjE4LmNvbW1vbi5pc3N1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9lcnJvciA9IHQsIHRoaXMuX2Vycm9yO1xuICB9IH07XG59O1xuZnVuY3Rpb24gZyhyMTgpIHtcbiAgaWYgKCFyMTgpIHJldHVybiB7fTtcbiAgbGV0IHsgZXJyb3JNYXA6IGUsIGludmFsaWRfdHlwZV9lcnJvcjogdCwgcmVxdWlyZWRfZXJyb3I6IG4sIGRlc2NyaXB0aW9uOiBzIH0gPSByMTg7XG4gIGlmIChlICYmICh0IHx8IG4pKSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gIHJldHVybiBlID8geyBlcnJvck1hcDogZSwgZGVzY3JpcHRpb246IHMgfSA6IHsgZXJyb3JNYXA6IChpLCBvKSA9PiB7XG4gICAgdmFyIHUsIGw7XG4gICAgbGV0IHsgbWVzc2FnZTogaCB9ID0gcjE4O1xuICAgIHJldHVybiBpLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIgPyB7IG1lc3NhZ2U6IGggPz8gby5kZWZhdWx0RXJyb3IgfSA6IHR5cGVvZiBvLmRhdGEgPiBcInVcIiA/IHsgbWVzc2FnZTogKHUgPSBoID8/IG4pICE9PSBudWxsICYmIHUgIT09IHZvaWQgMCA/IHUgOiBvLmRlZmF1bHRFcnJvciB9IDogaS5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiID8geyBtZXNzYWdlOiBvLmRlZmF1bHRFcnJvciB9IDogeyBtZXNzYWdlOiAobCA9IGggPz8gdCkgIT09IG51bGwgJiYgbCAhPT0gdm9pZCAwID8gbCA6IG8uZGVmYXVsdEVycm9yIH07XG4gIH0sIGRlc2NyaXB0aW9uOiBzIH07XG59XG52YXIgXyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYywgdGhpcy5fZGVmID0gZSwgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKSwgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpLCB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKSwgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKSwgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpLCB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyksIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpLCB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpLCB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpLCB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKSwgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKSwgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyksIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyksIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKSwgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpLCB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpLCB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKSwgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKSwgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKSwgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyksIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyksIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpLCB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgfVxuICBfZ2V0VHlwZShlKSB7XG4gICAgcmV0dXJuIG5lKGUuZGF0YSk7XG4gIH1cbiAgX2dldE9yUmV0dXJuQ3R4KGUsIHQpIHtcbiAgICByZXR1cm4gdCB8fCB7IGNvbW1vbjogZS5wYXJlbnQuY29tbW9uLCBkYXRhOiBlLmRhdGEsIHBhcnNlZFR5cGU6IG5lKGUuZGF0YSksIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsIHBhdGg6IGUucGF0aCwgcGFyZW50OiBlLnBhcmVudCB9O1xuICB9XG4gIF9wcm9jZXNzSW5wdXRQYXJhbXMoZSkge1xuICAgIHJldHVybiB7IHN0YXR1czogbmV3IFIoKSwgY3R4OiB7IGNvbW1vbjogZS5wYXJlbnQuY29tbW9uLCBkYXRhOiBlLmRhdGEsIHBhcnNlZFR5cGU6IG5lKGUuZGF0YSksIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsIHBhdGg6IGUucGF0aCwgcGFyZW50OiBlLnBhcmVudCB9IH07XG4gIH1cbiAgX3BhcnNlU3luYyhlKSB7XG4gICAgbGV0IHQgPSB0aGlzLl9wYXJzZShlKTtcbiAgICBpZiAoeXQodCkpIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9wYXJzZUFzeW5jKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMuX3BhcnNlKGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodCk7XG4gIH1cbiAgcGFyc2UoZSwgdCkge1xuICAgIGxldCBuID0gdGhpcy5zYWZlUGFyc2UoZSwgdCk7XG4gICAgaWYgKG4uc3VjY2VzcykgcmV0dXJuIG4uZGF0YTtcbiAgICB0aHJvdyBuLmVycm9yO1xuICB9XG4gIHNhZmVQYXJzZShlLCB0KSB7XG4gICAgdmFyIG47XG4gICAgbGV0IHMgPSB7IGNvbW1vbjogeyBpc3N1ZXM6IFtdLCBhc3luYzogKG4gPSB0Py5hc3luYykgIT09IG51bGwgJiYgbiAhPT0gdm9pZCAwID8gbiA6IGZhbHNlLCBjb250ZXh0dWFsRXJyb3JNYXA6IHQ/LmVycm9yTWFwIH0sIHBhdGg6IHQ/LnBhdGggfHwgW10sIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsIHBhcmVudDogbnVsbCwgZGF0YTogZSwgcGFyc2VkVHlwZTogbmUoZSkgfSwgYSA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGE6IGUsIHBhdGg6IHMucGF0aCwgcGFyZW50OiBzIH0pO1xuICAgIHJldHVybiBOcihzLCBhKTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGUsIHQpIHtcbiAgICBsZXQgbiA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZSwgdCk7XG4gICAgaWYgKG4uc3VjY2VzcykgcmV0dXJuIG4uZGF0YTtcbiAgICB0aHJvdyBuLmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGUsIHQpIHtcbiAgICBsZXQgbiA9IHsgY29tbW9uOiB7IGlzc3VlczogW10sIGNvbnRleHR1YWxFcnJvck1hcDogdD8uZXJyb3JNYXAsIGFzeW5jOiB0cnVlIH0sIHBhdGg6IHQ/LnBhdGggfHwgW10sIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsIHBhcmVudDogbnVsbCwgZGF0YTogZSwgcGFyc2VkVHlwZTogbmUoZSkgfSwgcyA9IHRoaXMuX3BhcnNlKHsgZGF0YTogZSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSksIGEgPSBhd2FpdCAoeXQocykgPyBzIDogUHJvbWlzZS5yZXNvbHZlKHMpKTtcbiAgICByZXR1cm4gTnIobiwgYSk7XG4gIH1cbiAgcmVmaW5lKGUsIHQpIHtcbiAgICBsZXQgbiA9IChzKSA9PiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0ID4gXCJ1XCIgPyB7IG1lc3NhZ2U6IHQgfSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQocykgOiB0O1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KChzLCBhKSA9PiB7XG4gICAgICBsZXQgaSA9IGUocyksIG8gPSAoKSA9PiBhLmFkZElzc3VlKHsgY29kZTogYy5jdXN0b20sIC4uLm4ocykgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIFByb21pc2UgPCBcInVcIiAmJiBpIGluc3RhbmNlb2YgUHJvbWlzZSA/IGkudGhlbigodSkgPT4gdSA/IHRydWUgOiAobygpLCBmYWxzZSkpIDogaSA/IHRydWUgOiAobygpLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKG4sIHMpID0+IGUobikgPyB0cnVlIDogKHMuYWRkSXNzdWUodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChuLCBzKSA6IHQpLCBmYWxzZSkpO1xuICB9XG4gIF9yZWZpbmVtZW50KGUpIHtcbiAgICByZXR1cm4gbmV3IFooeyBzY2hlbWE6IHRoaXMsIHR5cGVOYW1lOiBtLlpvZEVmZmVjdHMsIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudDogZSB9IH0pO1xuICB9XG4gIHN1cGVyUmVmaW5lKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChlKTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gei5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4gJC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gSi5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBwcm9taXNlKCkge1xuICAgIHJldHVybiBpZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihlKSB7XG4gICAgcmV0dXJuIHllLmNyZWF0ZShbdGhpcywgZV0sIHRoaXMuX2RlZik7XG4gIH1cbiAgYW5kKGUpIHtcbiAgICByZXR1cm4gZ2UuY3JlYXRlKHRoaXMsIGUsIHRoaXMuX2RlZik7XG4gIH1cbiAgdHJhbnNmb3JtKGUpIHtcbiAgICByZXR1cm4gbmV3IFooeyAuLi5nKHRoaXMuX2RlZiksIHNjaGVtYTogdGhpcywgdHlwZU5hbWU6IG0uWm9kRWZmZWN0cywgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybTogZSB9IH0pO1xuICB9XG4gIGRlZmF1bHQoZSkge1xuICAgIGxldCB0ID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6ICgpID0+IGU7XG4gICAgcmV0dXJuIG5ldyBiZSh7IC4uLmcodGhpcy5fZGVmKSwgaW5uZXJUeXBlOiB0aGlzLCBkZWZhdWx0VmFsdWU6IHQsIHR5cGVOYW1lOiBtLlpvZERlZmF1bHQgfSk7XG4gIH1cbiAgYnJhbmQoKSB7XG4gICAgcmV0dXJuIG5ldyBRZSh7IHR5cGVOYW1lOiBtLlpvZEJyYW5kZWQsIHR5cGU6IHRoaXMsIC4uLmcodGhpcy5fZGVmKSB9KTtcbiAgfVxuICBjYXRjaChlKSB7XG4gICAgbGV0IHQgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogKCkgPT4gZTtcbiAgICByZXR1cm4gbmV3IFNlKHsgLi4uZyh0aGlzLl9kZWYpLCBpbm5lclR5cGU6IHRoaXMsIGNhdGNoVmFsdWU6IHQsIHR5cGVOYW1lOiBtLlpvZENhdGNoIH0pO1xuICB9XG4gIGRlc2NyaWJlKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyB0KHsgLi4udGhpcy5fZGVmLCBkZXNjcmlwdGlvbjogZSB9KTtcbiAgfVxuICBwaXBlKGUpIHtcbiAgICByZXR1cm4gS2UuY3JlYXRlKHRoaXMsIGUpO1xuICB9XG4gIHJlYWRvbmx5KCkge1xuICAgIHJldHVybiBrZS5jcmVhdGUodGhpcyk7XG4gIH1cbiAgaXNPcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2Uodm9pZCAwKS5zdWNjZXNzO1xuICB9XG4gIGlzTnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gIH1cbn07XG52YXIgSG4gPSAvXmNbXlxccy1dezgsfSQvaTtcbnZhciBYbiA9IC9eWzAtOWEtel0rJC87XG52YXIgWW4gPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kLztcbnZhciBKbiA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xudmFyIFFuID0gL15bYS16MC05Xy1dezIxfSQvaTtcbnZhciBLbiA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG52YXIgZXMgPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xudmFyIHRzID0gXCJeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJFwiO1xudmFyIFZ0O1xudmFyIHJzID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbnZhciBucyA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xudmFyIHNzID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIFdyID0gXCIoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlcIjtcbnZhciBhcyA9IG5ldyBSZWdFeHAoYF4ke1dyfSRgKTtcbmZ1bmN0aW9uIHpyKHIxOCkge1xuICBsZXQgZSA9IFwiKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFwiO1xuICByZXR1cm4gcjE4LnByZWNpc2lvbiA/IGUgPSBgJHtlfVxcXFwuXFxcXGR7JHtyMTgucHJlY2lzaW9ufX1gIDogcjE4LnByZWNpc2lvbiA9PSBudWxsICYmIChlID0gYCR7ZX0oXFxcXC5cXFxcZCspP2ApLCBlO1xufVxuZnVuY3Rpb24gaXMocjE4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHt6cihyMTgpfSRgKTtcbn1cbmZ1bmN0aW9uIE1yKHIxOCkge1xuICBsZXQgZSA9IGAke1dyfVQke3pyKHIxOCl9YCwgdCA9IFtdO1xuICByZXR1cm4gdC5wdXNoKHIxOC5sb2NhbCA/IFwiWj9cIiA6IFwiWlwiKSwgcjE4Lm9mZnNldCAmJiB0LnB1c2goXCIoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlcIiksIGUgPSBgJHtlfSgke3Quam9pbihcInxcIil9KWAsIG5ldyBSZWdFeHAoYF4ke2V9JGApO1xufVxuZnVuY3Rpb24gb3MocjE4LCBlKSB7XG4gIHJldHVybiAhISgoZSA9PT0gXCJ2NFwiIHx8ICFlKSAmJiBycy50ZXN0KHIxOCkgfHwgKGUgPT09IFwidjZcIiB8fCAhZSkgJiYgbnMudGVzdChyMTgpKTtcbn1cbnZhciBzZSA9IGNsYXNzIHI1IGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGUuZGF0YSA9IFN0cmluZyhlLmRhdGEpKSwgdGhpcy5fZ2V0VHlwZShlKSAhPT0gZC5zdHJpbmcpIHtcbiAgICAgIGxldCBhID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gZihhLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5zdHJpbmcsIHJlY2VpdmVkOiBhLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgfVxuICAgIGxldCBuID0gbmV3IFIoKSwgcztcbiAgICBmb3IgKGxldCBhIG9mIHRoaXMuX2RlZi5jaGVja3MpIGlmIChhLmtpbmQgPT09IFwibWluXCIpIGUuZGF0YS5sZW5ndGggPCBhLnZhbHVlICYmIChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyBjb2RlOiBjLnRvb19zbWFsbCwgbWluaW11bTogYS52YWx1ZSwgdHlwZTogXCJzdHJpbmdcIiwgaW5jbHVzaXZlOiB0cnVlLCBleGFjdDogZmFsc2UsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKTtcbiAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwibWF4XCIpIGUuZGF0YS5sZW5ndGggPiBhLnZhbHVlICYmIChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyBjb2RlOiBjLnRvb19iaWcsIG1heGltdW06IGEudmFsdWUsIHR5cGU6IFwic3RyaW5nXCIsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IGZhbHNlLCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSk7XG4gICAgZWxzZSBpZiAoYS5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBsZXQgaSA9IGUuZGF0YS5sZW5ndGggPiBhLnZhbHVlLCBvID0gZS5kYXRhLmxlbmd0aCA8IGEudmFsdWU7XG4gICAgICAoaSB8fCBvKSAmJiAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBpID8gZihzLCB7IGNvZGU6IGMudG9vX2JpZywgbWF4aW11bTogYS52YWx1ZSwgdHlwZTogXCJzdHJpbmdcIiwgaW5jbHVzaXZlOiB0cnVlLCBleGFjdDogdHJ1ZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pIDogbyAmJiBmKHMsIHsgY29kZTogYy50b29fc21hbGwsIG1pbmltdW06IGEudmFsdWUsIHR5cGU6IFwic3RyaW5nXCIsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IHRydWUsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKTtcbiAgICB9IGVsc2UgaWYgKGEua2luZCA9PT0gXCJlbWFpbFwiKSBlcy50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgZihzLCB7IHZhbGlkYXRpb246IFwiZW1haWxcIiwgY29kZTogYy5pbnZhbGlkX3N0cmluZywgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpO1xuICAgIGVsc2UgaWYgKGEua2luZCA9PT0gXCJlbW9qaVwiKSBWdCB8fCAoVnQgPSBuZXcgUmVnRXhwKHRzLCBcInVcIikpLCBWdC50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgZihzLCB7IHZhbGlkYXRpb246IFwiZW1vamlcIiwgY29kZTogYy5pbnZhbGlkX3N0cmluZywgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpO1xuICAgIGVsc2UgaWYgKGEua2luZCA9PT0gXCJ1dWlkXCIpIEpuLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJ1dWlkXCIsIGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKTtcbiAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwibmFub2lkXCIpIFFuLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJuYW5vaWRcIiwgY29kZTogYy5pbnZhbGlkX3N0cmluZywgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpO1xuICAgIGVsc2UgaWYgKGEua2luZCA9PT0gXCJjdWlkXCIpIEhuLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJjdWlkXCIsIGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKTtcbiAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwiY3VpZDJcIikgWG4udGVzdChlLmRhdGEpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyB2YWxpZGF0aW9uOiBcImN1aWQyXCIsIGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKTtcbiAgICBlbHNlIGlmIChhLmtpbmQgPT09IFwidWxpZFwiKSBZbi50ZXN0KGUuZGF0YSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgZihzLCB7IHZhbGlkYXRpb246IFwidWxpZFwiLCBjb2RlOiBjLmludmFsaWRfc3RyaW5nLCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSk7XG4gICAgZWxzZSBpZiAoYS5raW5kID09PSBcInVybFwiKSB0cnkge1xuICAgICAgbmV3IFVSTChlLmRhdGEpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJ1cmxcIiwgY29kZTogYy5pbnZhbGlkX3N0cmluZywgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCk7XG4gICAgfVxuICAgIGVsc2UgYS5raW5kID09PSBcInJlZ2V4XCIgPyAoYS5yZWdleC5sYXN0SW5kZXggPSAwLCBhLnJlZ2V4LnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJyZWdleFwiLCBjb2RlOiBjLmludmFsaWRfc3RyaW5nLCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSkpIDogYS5raW5kID09PSBcInRyaW1cIiA/IGUuZGF0YSA9IGUuZGF0YS50cmltKCkgOiBhLmtpbmQgPT09IFwiaW5jbHVkZXNcIiA/IGUuZGF0YS5pbmNsdWRlcyhhLnZhbHVlLCBhLnBvc2l0aW9uKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgY29kZTogYy5pbnZhbGlkX3N0cmluZywgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogYS52YWx1ZSwgcG9zaXRpb246IGEucG9zaXRpb24gfSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcInRvTG93ZXJDYXNlXCIgPyBlLmRhdGEgPSBlLmRhdGEudG9Mb3dlckNhc2UoKSA6IGEua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiID8gZS5kYXRhID0gZS5kYXRhLnRvVXBwZXJDYXNlKCkgOiBhLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiID8gZS5kYXRhLnN0YXJ0c1dpdGgoYS52YWx1ZSkgfHwgKHMgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBzKSwgZihzLCB7IGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogYS52YWx1ZSB9LCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiZW5kc1dpdGhcIiA/IGUuZGF0YS5lbmRzV2l0aChhLnZhbHVlKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgY29kZTogYy5pbnZhbGlkX3N0cmluZywgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogYS52YWx1ZSB9LCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiZGF0ZXRpbWVcIiA/IE1yKGEpLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgY29kZTogYy5pbnZhbGlkX3N0cmluZywgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwiZGF0ZVwiID8gYXMudGVzdChlLmRhdGEpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyBjb2RlOiBjLmludmFsaWRfc3RyaW5nLCB2YWxpZGF0aW9uOiBcImRhdGVcIiwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpIDogYS5raW5kID09PSBcInRpbWVcIiA/IGlzKGEpLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgY29kZTogYy5pbnZhbGlkX3N0cmluZywgdmFsaWRhdGlvbjogXCJ0aW1lXCIsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJkdXJhdGlvblwiID8gS24udGVzdChlLmRhdGEpIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsIGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJpcFwiID8gb3MoZS5kYXRhLCBhLnZlcnNpb24pIHx8IChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyB2YWxpZGF0aW9uOiBcImlwXCIsIGNvZGU6IGMuaW52YWxpZF9zdHJpbmcsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgbi5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJiYXNlNjRcIiA/IHNzLnRlc3QoZS5kYXRhKSB8fCAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgdmFsaWRhdGlvbjogXCJiYXNlNjRcIiwgY29kZTogYy5pbnZhbGlkX3N0cmluZywgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBuLmRpcnR5KCkpIDogdy5hc3NlcnROZXZlcihhKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IG4udmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBfcmVnZXgoZSwgdCwgbikge1xuICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKHMpID0+IGUudGVzdChzKSwgeyB2YWxpZGF0aW9uOiB0LCBjb2RlOiBjLmludmFsaWRfc3RyaW5nLCAuLi5wLmVyclRvT2JqKG4pIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyByNSh7IC4uLnRoaXMuX2RlZiwgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgZV0gfSk7XG4gIH1cbiAgZW1haWwoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICB1cmwoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLnAuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgZW1vamkoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICB1dWlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICBuYW5vaWQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLnAuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY3VpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLnAuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY3VpZDIoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICB1bGlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICBiYXNlNjQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLnAuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgaXAoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICBkYXRldGltZShlKSB7XG4gICAgdmFyIHQsIG47XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZXRpbWVcIiwgcHJlY2lzaW9uOiBudWxsLCBvZmZzZXQ6IGZhbHNlLCBsb2NhbDogZmFsc2UsIG1lc3NhZ2U6IGUgfSkgOiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZXRpbWVcIiwgcHJlY2lzaW9uOiB0eXBlb2YgZT8ucHJlY2lzaW9uID4gXCJ1XCIgPyBudWxsIDogZT8ucHJlY2lzaW9uLCBvZmZzZXQ6ICh0ID0gZT8ub2Zmc2V0KSAhPT0gbnVsbCAmJiB0ICE9PSB2b2lkIDAgPyB0IDogZmFsc2UsIGxvY2FsOiAobiA9IGU/LmxvY2FsKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogZmFsc2UsIC4uLnAuZXJyVG9PYmooZT8ubWVzc2FnZSkgfSk7XG4gIH1cbiAgZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2U6IGUgfSk7XG4gIH1cbiAgdGltZShlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidGltZVwiLCBwcmVjaXNpb246IG51bGwsIG1lc3NhZ2U6IGUgfSkgOiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidGltZVwiLCBwcmVjaXNpb246IHR5cGVvZiBlPy5wcmVjaXNpb24gPiBcInVcIiA/IG51bGwgOiBlPy5wcmVjaXNpb24sIC4uLnAuZXJyVG9PYmooZT8ubWVzc2FnZSkgfSk7XG4gIH1cbiAgZHVyYXRpb24oZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4ucC5lcnJUb09iaihlKSB9KTtcbiAgfVxuICByZWdleChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJyZWdleFwiLCByZWdleDogZSwgLi4ucC5lcnJUb09iaih0KSB9KTtcbiAgfVxuICBpbmNsdWRlcyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpbmNsdWRlc1wiLCB2YWx1ZTogZSwgcG9zaXRpb246IHQ/LnBvc2l0aW9uLCAuLi5wLmVyclRvT2JqKHQ/Lm1lc3NhZ2UpIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwic3RhcnRzV2l0aFwiLCB2YWx1ZTogZSwgLi4ucC5lcnJUb09iaih0KSB9KTtcbiAgfVxuICBlbmRzV2l0aChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbmRzV2l0aFwiLCB2YWx1ZTogZSwgLi4ucC5lcnJUb09iaih0KSB9KTtcbiAgfVxuICBtaW4oZSwgdCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibWluXCIsIHZhbHVlOiBlLCAuLi5wLmVyclRvT2JqKHQpIH0pO1xuICB9XG4gIG1heChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtYXhcIiwgdmFsdWU6IGUsIC4uLnAuZXJyVG9PYmoodCkgfSk7XG4gIH1cbiAgbGVuZ3RoKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImxlbmd0aFwiLCB2YWx1ZTogZSwgLi4ucC5lcnJUb09iaih0KSB9KTtcbiAgfVxuICBub25lbXB0eShlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIHAuZXJyVG9PYmooZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyByNSh7IC4uLnRoaXMuX2RlZiwgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IHI1KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IHI1KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgfVxuICBnZXQgaXNEYXRlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImRhdGVcIik7XG4gIH1cbiAgZ2V0IGlzVGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICB9XG4gIGdldCBpc0VtYWlsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImVtYWlsXCIpO1xuICB9XG4gIGdldCBpc1VSTCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZW1vamlcIik7XG4gIH1cbiAgZ2V0IGlzVVVJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1dWlkXCIpO1xuICB9XG4gIGdldCBpc05BTk9JRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJjdWlkXCIpO1xuICB9XG4gIGdldCBpc0NVSUQyKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImN1aWQyXCIpO1xuICB9XG4gIGdldCBpc1VMSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJpcFwiKTtcbiAgfVxuICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICB9XG4gIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAobGV0IHQgb2YgdGhpcy5fZGVmLmNoZWNrcykgdC5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHQudmFsdWUgPiBlKSAmJiAoZSA9IHQudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAobGV0IHQgb2YgdGhpcy5fZGVmLmNoZWNrcykgdC5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHQudmFsdWUgPCBlKSAmJiAoZSA9IHQudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59O1xuc2UuY3JlYXRlID0gKHIxOCkgPT4ge1xuICB2YXIgZTtcbiAgcmV0dXJuIG5ldyBzZSh7IGNoZWNrczogW10sIHR5cGVOYW1lOiBtLlpvZFN0cmluZywgY29lcmNlOiAoZSA9IHIxOD8uY29lcmNlKSAhPT0gbnVsbCAmJiBlICE9PSB2b2lkIDAgPyBlIDogZmFsc2UsIC4uLmcocjE4KSB9KTtcbn07XG5mdW5jdGlvbiB1cyhyMTgsIGUpIHtcbiAgbGV0IHQgPSAocjE4LnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgbiA9IChlLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgcyA9IHQgPiBuID8gdCA6IG4sIGEgPSBwYXJzZUludChyMTgudG9GaXhlZChzKS5yZXBsYWNlKFwiLlwiLCBcIlwiKSksIGkgPSBwYXJzZUludChlLnRvRml4ZWQocykucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gYSAlIGkgLyBNYXRoLnBvdygxMCwgcyk7XG59XG52YXIgY2UgPSBjbGFzcyByNiBleHRlbmRzIF8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm1pbiA9IHRoaXMuZ3RlLCB0aGlzLm1heCA9IHRoaXMubHRlLCB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gTnVtYmVyKGUuZGF0YSkpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBkLm51bWJlcikge1xuICAgICAgbGV0IGEgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBmKGEsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLm51bWJlciwgcmVjZWl2ZWQ6IGEucGFyc2VkVHlwZSB9KSwgeTtcbiAgICB9XG4gICAgbGV0IG4sIHMgPSBuZXcgUigpO1xuICAgIGZvciAobGV0IGEgb2YgdGhpcy5fZGVmLmNoZWNrcykgYS5raW5kID09PSBcImludFwiID8gdy5pc0ludGVnZXIoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBmKG4sIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBcImludGVnZXJcIiwgcmVjZWl2ZWQ6IFwiZmxvYXRcIiwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm1pblwiID8gKGEuaW5jbHVzaXZlID8gZS5kYXRhIDwgYS52YWx1ZSA6IGUuZGF0YSA8PSBhLnZhbHVlKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBmKG4sIHsgY29kZTogYy50b29fc21hbGwsIG1pbmltdW06IGEudmFsdWUsIHR5cGU6IFwibnVtYmVyXCIsIGluY2x1c2l2ZTogYS5pbmNsdXNpdmUsIGV4YWN0OiBmYWxzZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm1heFwiID8gKGEuaW5jbHVzaXZlID8gZS5kYXRhID4gYS52YWx1ZSA6IGUuZGF0YSA+PSBhLnZhbHVlKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBmKG4sIHsgY29kZTogYy50b29fYmlnLCBtYXhpbXVtOiBhLnZhbHVlLCB0eXBlOiBcIm51bWJlclwiLCBpbmNsdXNpdmU6IGEuaW5jbHVzaXZlLCBleGFjdDogZmFsc2UsIG1lc3NhZ2U6IGEubWVzc2FnZSB9KSwgcy5kaXJ0eSgpKSA6IGEua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgPyB1cyhlLmRhdGEsIGEudmFsdWUpICE9PSAwICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGYobiwgeyBjb2RlOiBjLm5vdF9tdWx0aXBsZV9vZiwgbXVsdGlwbGVPZjogYS52YWx1ZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcImZpbml0ZVwiID8gTnVtYmVyLmlzRmluaXRlKGUuZGF0YSkgfHwgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgZihuLCB7IGNvZGU6IGMubm90X2Zpbml0ZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogdy5hc3NlcnROZXZlcihhKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IHMudmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBndGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsIHRydWUsIHAudG9TdHJpbmcodCkpO1xuICB9XG4gIGd0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCBlLCBmYWxzZSwgcC50b1N0cmluZyh0KSk7XG4gIH1cbiAgbHRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCB0cnVlLCBwLnRvU3RyaW5nKHQpKTtcbiAgfVxuICBsdChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgZSwgZmFsc2UsIHAudG9TdHJpbmcodCkpO1xuICB9XG4gIHNldExpbWl0KGUsIHQsIG4sIHMpIHtcbiAgICByZXR1cm4gbmV3IHI2KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IGUsIHZhbHVlOiB0LCBpbmNsdXNpdmU6IG4sIG1lc3NhZ2U6IHAudG9TdHJpbmcocykgfV0gfSk7XG4gIH1cbiAgX2FkZENoZWNrKGUpIHtcbiAgICByZXR1cm4gbmV3IHI2KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXSB9KTtcbiAgfVxuICBpbnQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaW50XCIsIG1lc3NhZ2U6IHAudG9TdHJpbmcoZSkgfSk7XG4gIH1cbiAgcG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibWluXCIsIHZhbHVlOiAwLCBpbmNsdXNpdmU6IGZhbHNlLCBtZXNzYWdlOiBwLnRvU3RyaW5nKGUpIH0pO1xuICB9XG4gIG5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm1heFwiLCB2YWx1ZTogMCwgaW5jbHVzaXZlOiBmYWxzZSwgbWVzc2FnZTogcC50b1N0cmluZyhlKSB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtYXhcIiwgdmFsdWU6IDAsIGluY2x1c2l2ZTogdHJ1ZSwgbWVzc2FnZTogcC50b1N0cmluZyhlKSB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtaW5cIiwgdmFsdWU6IDAsIGluY2x1c2l2ZTogdHJ1ZSwgbWVzc2FnZTogcC50b1N0cmluZyhlKSB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm11bHRpcGxlT2ZcIiwgdmFsdWU6IGUsIG1lc3NhZ2U6IHAudG9TdHJpbmcodCkgfSk7XG4gIH1cbiAgZmluaXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImZpbml0ZVwiLCBtZXNzYWdlOiBwLnRvU3RyaW5nKGUpIH0pO1xuICB9XG4gIHNhZmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibWluXCIsIGluY2x1c2l2ZTogdHJ1ZSwgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBtZXNzYWdlOiBwLnRvU3RyaW5nKGUpIH0pLl9hZGRDaGVjayh7IGtpbmQ6IFwibWF4XCIsIGluY2x1c2l2ZTogdHJ1ZSwgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBtZXNzYWdlOiBwLnRvU3RyaW5nKGUpIH0pO1xuICB9XG4gIGdldCBtaW5WYWx1ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChsZXQgdCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB0LmtpbmQgPT09IFwibWluXCIgJiYgKGUgPT09IG51bGwgfHwgdC52YWx1ZSA+IGUpICYmIChlID0gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IG1heFZhbHVlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGxldCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpIHQua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlIDwgZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgaXNJbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiaW50XCIgfHwgZS5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB3LmlzSW50ZWdlcihlLnZhbHVlKSk7XG4gIH1cbiAgZ2V0IGlzRmluaXRlKCkge1xuICAgIGxldCBlID0gbnVsbCwgdCA9IG51bGw7XG4gICAgZm9yIChsZXQgbiBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAobi5raW5kID09PSBcImZpbml0ZVwiIHx8IG4ua2luZCA9PT0gXCJpbnRcIiB8fCBuLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIG4ua2luZCA9PT0gXCJtaW5cIiA/ICh0ID09PSBudWxsIHx8IG4udmFsdWUgPiB0KSAmJiAodCA9IG4udmFsdWUpIDogbi5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IG4udmFsdWUgPCBlKSAmJiAoZSA9IG4udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHQpICYmIE51bWJlci5pc0Zpbml0ZShlKTtcbiAgfVxufTtcbmNlLmNyZWF0ZSA9IChyMTgpID0+IG5ldyBjZSh7IGNoZWNrczogW10sIHR5cGVOYW1lOiBtLlpvZE51bWJlciwgY29lcmNlOiByMTg/LmNvZXJjZSB8fCBmYWxzZSwgLi4uZyhyMTgpIH0pO1xudmFyIGZlID0gY2xhc3MgcjcgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5taW4gPSB0aGlzLmd0ZSwgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChlLmRhdGEgPSBCaWdJbnQoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IGQuYmlnaW50KSB7XG4gICAgICBsZXQgYSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGYoYSwgeyBjb2RlOiBjLmludmFsaWRfdHlwZSwgZXhwZWN0ZWQ6IGQuYmlnaW50LCByZWNlaXZlZDogYS5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIH1cbiAgICBsZXQgbiwgcyA9IG5ldyBSKCk7XG4gICAgZm9yIChsZXQgYSBvZiB0aGlzLl9kZWYuY2hlY2tzKSBhLmtpbmQgPT09IFwibWluXCIgPyAoYS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBhLnZhbHVlIDogZS5kYXRhIDw9IGEudmFsdWUpICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGYobiwgeyBjb2RlOiBjLnRvb19zbWFsbCwgdHlwZTogXCJiaWdpbnRcIiwgbWluaW11bTogYS52YWx1ZSwgaW5jbHVzaXZlOiBhLmluY2x1c2l2ZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogYS5raW5kID09PSBcIm1heFwiID8gKGEuaW5jbHVzaXZlID8gZS5kYXRhID4gYS52YWx1ZSA6IGUuZGF0YSA+PSBhLnZhbHVlKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBmKG4sIHsgY29kZTogYy50b29fYmlnLCB0eXBlOiBcImJpZ2ludFwiLCBtYXhpbXVtOiBhLnZhbHVlLCBpbmNsdXNpdmU6IGEuaW5jbHVzaXZlLCBtZXNzYWdlOiBhLm1lc3NhZ2UgfSksIHMuZGlydHkoKSkgOiBhLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiID8gZS5kYXRhICUgYS52YWx1ZSAhPT0gQmlnSW50KDApICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGYobiwgeyBjb2RlOiBjLm5vdF9tdWx0aXBsZV9vZiwgbXVsdGlwbGVPZjogYS52YWx1ZSwgbWVzc2FnZTogYS5tZXNzYWdlIH0pLCBzLmRpcnR5KCkpIDogdy5hc3NlcnROZXZlcihhKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IHMudmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBndGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsIHRydWUsIHAudG9TdHJpbmcodCkpO1xuICB9XG4gIGd0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCBlLCBmYWxzZSwgcC50b1N0cmluZyh0KSk7XG4gIH1cbiAgbHRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCB0cnVlLCBwLnRvU3RyaW5nKHQpKTtcbiAgfVxuICBsdChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgZSwgZmFsc2UsIHAudG9TdHJpbmcodCkpO1xuICB9XG4gIHNldExpbWl0KGUsIHQsIG4sIHMpIHtcbiAgICByZXR1cm4gbmV3IHI3KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IGUsIHZhbHVlOiB0LCBpbmNsdXNpdmU6IG4sIG1lc3NhZ2U6IHAudG9TdHJpbmcocykgfV0gfSk7XG4gIH1cbiAgX2FkZENoZWNrKGUpIHtcbiAgICByZXR1cm4gbmV3IHI3KHsgLi4udGhpcy5fZGVmLCBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXSB9KTtcbiAgfVxuICBwb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtaW5cIiwgdmFsdWU6IEJpZ0ludCgwKSwgaW5jbHVzaXZlOiBmYWxzZSwgbWVzc2FnZTogcC50b1N0cmluZyhlKSB9KTtcbiAgfVxuICBuZWdhdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtYXhcIiwgdmFsdWU6IEJpZ0ludCgwKSwgaW5jbHVzaXZlOiBmYWxzZSwgbWVzc2FnZTogcC50b1N0cmluZyhlKSB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtYXhcIiwgdmFsdWU6IEJpZ0ludCgwKSwgaW5jbHVzaXZlOiB0cnVlLCBtZXNzYWdlOiBwLnRvU3RyaW5nKGUpIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm1pblwiLCB2YWx1ZTogQmlnSW50KDApLCBpbmNsdXNpdmU6IHRydWUsIG1lc3NhZ2U6IHAudG9TdHJpbmcoZSkgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtdWx0aXBsZU9mXCIsIHZhbHVlOiBlLCBtZXNzYWdlOiBwLnRvU3RyaW5nKHQpIH0pO1xuICB9XG4gIGdldCBtaW5WYWx1ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChsZXQgdCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB0LmtpbmQgPT09IFwibWluXCIgJiYgKGUgPT09IG51bGwgfHwgdC52YWx1ZSA+IGUpICYmIChlID0gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IG1heFZhbHVlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGxldCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpIHQua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlIDwgZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxufTtcbmZlLmNyZWF0ZSA9IChyMTgpID0+IHtcbiAgdmFyIGU7XG4gIHJldHVybiBuZXcgZmUoeyBjaGVja3M6IFtdLCB0eXBlTmFtZTogbS5ab2RCaWdJbnQsIGNvZXJjZTogKGUgPSByMTg/LmNvZXJjZSkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6IGZhbHNlLCAuLi5nKHIxOCkgfSk7XG59O1xudmFyIGRlID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gISFlLmRhdGEpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBkLmJvb2xlYW4pIHtcbiAgICAgIGxldCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gZihuLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5ib29sZWFuLCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIH1cbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG59O1xuZGUuY3JlYXRlID0gKHIxOCkgPT4gbmV3IGRlKHsgdHlwZU5hbWU6IG0uWm9kQm9vbGVhbiwgY29lcmNlOiByMTg/LmNvZXJjZSB8fCBmYWxzZSwgLi4uZyhyMTgpIH0pO1xudmFyIGhlID0gY2xhc3MgcjggZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gbmV3IERhdGUoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IGQuZGF0ZSkge1xuICAgICAgbGV0IGEgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBmKGEsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLmRhdGUsIHJlY2VpdmVkOiBhLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgfVxuICAgIGlmIChpc05hTihlLmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgbGV0IGEgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBmKGEsIHsgY29kZTogYy5pbnZhbGlkX2RhdGUgfSksIHk7XG4gICAgfVxuICAgIGxldCBuID0gbmV3IFIoKSwgcztcbiAgICBmb3IgKGxldCBhIG9mIHRoaXMuX2RlZi5jaGVja3MpIGEua2luZCA9PT0gXCJtaW5cIiA/IGUuZGF0YS5nZXRUaW1lKCkgPCBhLnZhbHVlICYmIChzID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgcyksIGYocywgeyBjb2RlOiBjLnRvb19zbWFsbCwgbWVzc2FnZTogYS5tZXNzYWdlLCBpbmNsdXNpdmU6IHRydWUsIGV4YWN0OiBmYWxzZSwgbWluaW11bTogYS52YWx1ZSwgdHlwZTogXCJkYXRlXCIgfSksIG4uZGlydHkoKSkgOiBhLmtpbmQgPT09IFwibWF4XCIgPyBlLmRhdGEuZ2V0VGltZSgpID4gYS52YWx1ZSAmJiAocyA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHMpLCBmKHMsIHsgY29kZTogYy50b29fYmlnLCBtZXNzYWdlOiBhLm1lc3NhZ2UsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IGZhbHNlLCBtYXhpbXVtOiBhLnZhbHVlLCB0eXBlOiBcImRhdGVcIiB9KSwgbi5kaXJ0eSgpKSA6IHcuYXNzZXJ0TmV2ZXIoYSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBuLnZhbHVlLCB2YWx1ZTogbmV3IERhdGUoZS5kYXRhLmdldFRpbWUoKSkgfTtcbiAgfVxuICBfYWRkQ2hlY2soZSkge1xuICAgIHJldHVybiBuZXcgcjgoeyAuLi50aGlzLl9kZWYsIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGVdIH0pO1xuICB9XG4gIG1pbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtaW5cIiwgdmFsdWU6IGUuZ2V0VGltZSgpLCBtZXNzYWdlOiBwLnRvU3RyaW5nKHQpIH0pO1xuICB9XG4gIG1heChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJtYXhcIiwgdmFsdWU6IGUuZ2V0VGltZSgpLCBtZXNzYWdlOiBwLnRvU3RyaW5nKHQpIH0pO1xuICB9XG4gIGdldCBtaW5EYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGxldCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpIHQua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlID4gZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG4gIGdldCBtYXhEYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGxldCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpIHQua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlIDwgZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG59O1xuaGUuY3JlYXRlID0gKHIxOCkgPT4gbmV3IGhlKHsgY2hlY2tzOiBbXSwgY29lcmNlOiByMTg/LmNvZXJjZSB8fCBmYWxzZSwgdHlwZU5hbWU6IG0uWm9kRGF0ZSwgLi4uZyhyMTgpIH0pO1xudmFyIEllID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gZC5zeW1ib2wpIHtcbiAgICAgIGxldCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gZihuLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5zeW1ib2wsIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgfVxuICAgIHJldHVybiBqKGUuZGF0YSk7XG4gIH1cbn07XG5JZS5jcmVhdGUgPSAocjE4KSA9PiBuZXcgSWUoeyB0eXBlTmFtZTogbS5ab2RTeW1ib2wsIC4uLmcocjE4KSB9KTtcbnZhciBwZSA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IGQudW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGYobiwgeyBjb2RlOiBjLmludmFsaWRfdHlwZSwgZXhwZWN0ZWQ6IGQudW5kZWZpbmVkLCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIH1cbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG59O1xucGUuY3JlYXRlID0gKHIxOCkgPT4gbmV3IHBlKHsgdHlwZU5hbWU6IG0uWm9kVW5kZWZpbmVkLCAuLi5nKHIxOCkgfSk7XG52YXIgbWUgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBkLm51bGwpIHtcbiAgICAgIGxldCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gZihuLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5udWxsLCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIH1cbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG59O1xubWUuY3JlYXRlID0gKHIxOCkgPT4gbmV3IG1lKHsgdHlwZU5hbWU6IG0uWm9kTnVsbCwgLi4uZyhyMTgpIH0pO1xudmFyIGFlID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIHJldHVybiBqKGUuZGF0YSk7XG4gIH1cbn07XG5hZS5jcmVhdGUgPSAocjE4KSA9PiBuZXcgYWUoeyB0eXBlTmFtZTogbS5ab2RBbnksIC4uLmcocjE4KSB9KTtcbnZhciBZID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG59O1xuWS5jcmVhdGUgPSAocjE4KSA9PiBuZXcgWSh7IHR5cGVOYW1lOiBtLlpvZFVua25vd24sIC4uLmcocjE4KSB9KTtcbnZhciBEID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIHJldHVybiBmKHQsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLm5ldmVyLCByZWNlaXZlZDogdC5wYXJzZWRUeXBlIH0pLCB5O1xuICB9XG59O1xuRC5jcmVhdGUgPSAocjE4KSA9PiBuZXcgRCh7IHR5cGVOYW1lOiBtLlpvZE5ldmVyLCAuLi5nKHIxOCkgfSk7XG52YXIgTmUgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBkLnVuZGVmaW5lZCkge1xuICAgICAgbGV0IG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBmKG4sIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLnZvaWQsIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgfVxuICAgIHJldHVybiBqKGUuZGF0YSk7XG4gIH1cbn07XG5OZS5jcmVhdGUgPSAocjE4KSA9PiBuZXcgTmUoeyB0eXBlTmFtZTogbS5ab2RWb2lkLCAuLi5nKHIxOCkgfSk7XG52YXIgSiA9IGNsYXNzIHI5IGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHsgY3R4OiB0LCBzdGF0dXM6IG4gfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgcyA9IHRoaXMuX2RlZjtcbiAgICBpZiAodC5wYXJzZWRUeXBlICE9PSBkLmFycmF5KSByZXR1cm4gZih0LCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5hcnJheSwgcmVjZWl2ZWQ6IHQucGFyc2VkVHlwZSB9KSwgeTtcbiAgICBpZiAocy5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgbGV0IGkgPSB0LmRhdGEubGVuZ3RoID4gcy5leGFjdExlbmd0aC52YWx1ZSwgbyA9IHQuZGF0YS5sZW5ndGggPCBzLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgKGkgfHwgbykgJiYgKGYodCwgeyBjb2RlOiBpID8gYy50b29fYmlnIDogYy50b29fc21hbGwsIG1pbmltdW06IG8gPyBzLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLCBtYXhpbXVtOiBpID8gcy5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCwgdHlwZTogXCJhcnJheVwiLCBpbmNsdXNpdmU6IHRydWUsIGV4YWN0OiB0cnVlLCBtZXNzYWdlOiBzLmV4YWN0TGVuZ3RoLm1lc3NhZ2UgfSksIG4uZGlydHkoKSk7XG4gICAgfVxuICAgIGlmIChzLm1pbkxlbmd0aCAhPT0gbnVsbCAmJiB0LmRhdGEubGVuZ3RoIDwgcy5taW5MZW5ndGgudmFsdWUgJiYgKGYodCwgeyBjb2RlOiBjLnRvb19zbWFsbCwgbWluaW11bTogcy5taW5MZW5ndGgudmFsdWUsIHR5cGU6IFwiYXJyYXlcIiwgaW5jbHVzaXZlOiB0cnVlLCBleGFjdDogZmFsc2UsIG1lc3NhZ2U6IHMubWluTGVuZ3RoLm1lc3NhZ2UgfSksIG4uZGlydHkoKSksIHMubWF4TGVuZ3RoICE9PSBudWxsICYmIHQuZGF0YS5sZW5ndGggPiBzLm1heExlbmd0aC52YWx1ZSAmJiAoZih0LCB7IGNvZGU6IGMudG9vX2JpZywgbWF4aW11bTogcy5tYXhMZW5ndGgudmFsdWUsIHR5cGU6IFwiYXJyYXlcIiwgaW5jbHVzaXZlOiB0cnVlLCBleGFjdDogZmFsc2UsIG1lc3NhZ2U6IHMubWF4TGVuZ3RoLm1lc3NhZ2UgfSksIG4uZGlydHkoKSksIHQuY29tbW9uLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLnQuZGF0YV0ubWFwKChpLCBvKSA9PiBzLnR5cGUuX3BhcnNlQXN5bmMobmV3IE0odCwgaSwgdC5wYXRoLCBvKSkpKS50aGVuKChpKSA9PiBSLm1lcmdlQXJyYXkobiwgaSkpO1xuICAgIGxldCBhID0gWy4uLnQuZGF0YV0ubWFwKChpLCBvKSA9PiBzLnR5cGUuX3BhcnNlU3luYyhuZXcgTSh0LCBpLCB0LnBhdGgsIG8pKSk7XG4gICAgcmV0dXJuIFIubWVyZ2VBcnJheShuLCBhKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IHI5KHsgLi4udGhpcy5fZGVmLCBtaW5MZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHAudG9TdHJpbmcodCkgfSB9KTtcbiAgfVxuICBtYXgoZSwgdCkge1xuICAgIHJldHVybiBuZXcgcjkoeyAuLi50aGlzLl9kZWYsIG1heExlbmd0aDogeyB2YWx1ZTogZSwgbWVzc2FnZTogcC50b1N0cmluZyh0KSB9IH0pO1xuICB9XG4gIGxlbmd0aChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyByOSh7IC4uLnRoaXMuX2RlZiwgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHAudG9TdHJpbmcodCkgfSB9KTtcbiAgfVxuICBub25lbXB0eShlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIGUpO1xuICB9XG59O1xuSi5jcmVhdGUgPSAocjE4LCBlKSA9PiBuZXcgSih7IHR5cGU6IHIxOCwgbWluTGVuZ3RoOiBudWxsLCBtYXhMZW5ndGg6IG51bGwsIGV4YWN0TGVuZ3RoOiBudWxsLCB0eXBlTmFtZTogbS5ab2RBcnJheSwgLi4uZyhlKSB9KTtcbmZ1bmN0aW9uIENlKHIxOCkge1xuICBpZiAocjE4IGluc3RhbmNlb2YgTikge1xuICAgIGxldCBlID0ge307XG4gICAgZm9yIChsZXQgdCBpbiByMTguc2hhcGUpIHtcbiAgICAgIGxldCBuID0gcjE4LnNoYXBlW3RdO1xuICAgICAgZVt0XSA9IHouY3JlYXRlKENlKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOKHsgLi4ucjE4Ll9kZWYsIHNoYXBlOiAoKSA9PiBlIH0pO1xuICB9IGVsc2UgcmV0dXJuIHIxOCBpbnN0YW5jZW9mIEogPyBuZXcgSih7IC4uLnIxOC5fZGVmLCB0eXBlOiBDZShyMTguZWxlbWVudCkgfSkgOiByMTggaW5zdGFuY2VvZiB6ID8gei5jcmVhdGUoQ2UocjE4LnVud3JhcCgpKSkgOiByMTggaW5zdGFuY2VvZiAkID8gJC5jcmVhdGUoQ2UocjE4LnVud3JhcCgpKSkgOiByMTggaW5zdGFuY2VvZiBVID8gVS5jcmVhdGUocjE4Lml0ZW1zLm1hcCgoZSkgPT4gQ2UoZSkpKSA6IHIxODtcbn1cbnZhciBOID0gY2xhc3MgcjEwIGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX2NhY2hlZCA9IG51bGwsIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaCwgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gIH1cbiAgX2dldENhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKSByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIGxldCBlID0gdGhpcy5fZGVmLnNoYXBlKCksIHQgPSB3Lm9iamVjdEtleXMoZSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGU6IGUsIGtleXM6IHQgfTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGUpICE9PSBkLm9iamVjdCkge1xuICAgICAgbGV0IGwgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBmKGwsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLm9iamVjdCwgcmVjZWl2ZWQ6IGwucGFyc2VkVHlwZSB9KSwgeTtcbiAgICB9XG4gICAgbGV0IHsgc3RhdHVzOiBuLCBjdHg6IHMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgeyBzaGFwZTogYSwga2V5czogaSB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCksIG8gPSBbXTtcbiAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBEICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkgZm9yIChsZXQgbCBpbiBzLmRhdGEpIGkuaW5jbHVkZXMobCkgfHwgby5wdXNoKGwpO1xuICAgIGxldCB1ID0gW107XG4gICAgZm9yIChsZXQgbCBvZiBpKSB7XG4gICAgICBsZXQgaCA9IGFbbF0sIHYyID0gcy5kYXRhW2xdO1xuICAgICAgdS5wdXNoKHsga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogbCB9LCB2YWx1ZTogaC5fcGFyc2UobmV3IE0ocywgdjIsIHMucGF0aCwgbCkpLCBhbHdheXNTZXQ6IGwgaW4gcy5kYXRhIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgRCkge1xuICAgICAgbGV0IGwgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAobCA9PT0gXCJwYXNzdGhyb3VnaFwiKSBmb3IgKGxldCBoIG9mIG8pIHUucHVzaCh7IGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGggfSwgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBzLmRhdGFbaF0gfSB9KTtcbiAgICAgIGVsc2UgaWYgKGwgPT09IFwic3RyaWN0XCIpIG8ubGVuZ3RoID4gMCAmJiAoZihzLCB7IGNvZGU6IGMudW5yZWNvZ25pemVkX2tleXMsIGtleXM6IG8gfSksIG4uZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChsICE9PSBcInN0cmlwXCIpIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgZm9yIChsZXQgaCBvZiBvKSB7XG4gICAgICAgIGxldCB2MiA9IHMuZGF0YVtoXTtcbiAgICAgICAgdS5wdXNoKHsga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaCB9LCB2YWx1ZTogbC5fcGFyc2UobmV3IE0ocywgdjIsIHMucGF0aCwgaCkpLCBhbHdheXNTZXQ6IGggaW4gcy5kYXRhIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcy5jb21tb24uYXN5bmMgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBsID0gW107XG4gICAgICBmb3IgKGxldCBoIG9mIHUpIHtcbiAgICAgICAgbGV0IHYyID0gYXdhaXQgaC5rZXksIFQzID0gYXdhaXQgaC52YWx1ZTtcbiAgICAgICAgbC5wdXNoKHsga2V5OiB2MiwgdmFsdWU6IFQzLCBhbHdheXNTZXQ6IGguYWx3YXlzU2V0IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGw7XG4gICAgfSkudGhlbigobCkgPT4gUi5tZXJnZU9iamVjdFN5bmMobiwgbCkpIDogUi5tZXJnZU9iamVjdFN5bmMobiwgdSk7XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QoZSkge1xuICAgIHJldHVybiBwLmVyclRvT2JqLCBuZXcgcjEwKHsgLi4udGhpcy5fZGVmLCB1bmtub3duS2V5czogXCJzdHJpY3RcIiwgLi4uZSAhPT0gdm9pZCAwID8geyBlcnJvck1hcDogKHQsIG4pID0+IHtcbiAgICAgIHZhciBzLCBhLCBpLCBvO1xuICAgICAgbGV0IHUgPSAoaSA9IChhID0gKHMgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhLmNhbGwocywgdCwgbikubWVzc2FnZSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IG4uZGVmYXVsdEVycm9yO1xuICAgICAgcmV0dXJuIHQuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiID8geyBtZXNzYWdlOiAobyA9IHAuZXJyVG9PYmooZSkubWVzc2FnZSkgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IHUgfSA6IHsgbWVzc2FnZTogdSB9O1xuICAgIH0gfSA6IHt9IH0pO1xuICB9XG4gIHN0cmlwKCkge1xuICAgIHJldHVybiBuZXcgcjEwKHsgLi4udGhpcy5fZGVmLCB1bmtub3duS2V5czogXCJzdHJpcFwiIH0pO1xuICB9XG4gIHBhc3N0aHJvdWdoKCkge1xuICAgIHJldHVybiBuZXcgcjEwKHsgLi4udGhpcy5fZGVmLCB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiIH0pO1xuICB9XG4gIGV4dGVuZChlKSB7XG4gICAgcmV0dXJuIG5ldyByMTAoeyAuLi50aGlzLl9kZWYsIHNoYXBlOiAoKSA9PiAoeyAuLi50aGlzLl9kZWYuc2hhcGUoKSwgLi4uZSB9KSB9KTtcbiAgfVxuICBtZXJnZShlKSB7XG4gICAgcmV0dXJuIG5ldyByMTAoeyB1bmtub3duS2V5czogZS5fZGVmLnVua25vd25LZXlzLCBjYXRjaGFsbDogZS5fZGVmLmNhdGNoYWxsLCBzaGFwZTogKCkgPT4gKHsgLi4udGhpcy5fZGVmLnNoYXBlKCksIC4uLmUuX2RlZi5zaGFwZSgpIH0pLCB0eXBlTmFtZTogbS5ab2RPYmplY3QgfSk7XG4gIH1cbiAgc2V0S2V5KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2VdOiB0IH0pO1xuICB9XG4gIGNhdGNoYWxsKGUpIHtcbiAgICByZXR1cm4gbmV3IHIxMCh7IC4uLnRoaXMuX2RlZiwgY2F0Y2hhbGw6IGUgfSk7XG4gIH1cbiAgcGljayhlKSB7XG4gICAgbGV0IHQgPSB7fTtcbiAgICByZXR1cm4gdy5vYmplY3RLZXlzKGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGVbbl0gJiYgdGhpcy5zaGFwZVtuXSAmJiAodFtuXSA9IHRoaXMuc2hhcGVbbl0pO1xuICAgIH0pLCBuZXcgcjEwKHsgLi4udGhpcy5fZGVmLCBzaGFwZTogKCkgPT4gdCB9KTtcbiAgfVxuICBvbWl0KGUpIHtcbiAgICBsZXQgdCA9IHt9O1xuICAgIHJldHVybiB3Lm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgZVtuXSB8fCAodFtuXSA9IHRoaXMuc2hhcGVbbl0pO1xuICAgIH0pLCBuZXcgcjEwKHsgLi4udGhpcy5fZGVmLCBzaGFwZTogKCkgPT4gdCB9KTtcbiAgfVxuICBkZWVwUGFydGlhbCgpIHtcbiAgICByZXR1cm4gQ2UodGhpcyk7XG4gIH1cbiAgcGFydGlhbChlKSB7XG4gICAgbGV0IHQgPSB7fTtcbiAgICByZXR1cm4gdy5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGxldCBzID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgIGUgJiYgIWVbbl0gPyB0W25dID0gcyA6IHRbbl0gPSBzLm9wdGlvbmFsKCk7XG4gICAgfSksIG5ldyByMTAoeyAuLi50aGlzLl9kZWYsIHNoYXBlOiAoKSA9PiB0IH0pO1xuICB9XG4gIHJlcXVpcmVkKGUpIHtcbiAgICBsZXQgdCA9IHt9O1xuICAgIHJldHVybiB3Lm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaWYgKGUgJiYgIWVbbl0pIHRbbl0gPSB0aGlzLnNoYXBlW25dO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5zaGFwZVtuXTtcbiAgICAgICAgZm9yICg7IGEgaW5zdGFuY2VvZiB6OyApIGEgPSBhLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICB0W25dID0gYTtcbiAgICAgIH1cbiAgICB9KSwgbmV3IHIxMCh7IC4uLnRoaXMuX2RlZiwgc2hhcGU6ICgpID0+IHQgfSk7XG4gIH1cbiAga2V5b2YoKSB7XG4gICAgcmV0dXJuIERyKHcub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gIH1cbn07XG5OLmNyZWF0ZSA9IChyMTgsIGUpID0+IG5ldyBOKHsgc2hhcGU6ICgpID0+IHIxOCwgdW5rbm93bktleXM6IFwic3RyaXBcIiwgY2F0Y2hhbGw6IEQuY3JlYXRlKCksIHR5cGVOYW1lOiBtLlpvZE9iamVjdCwgLi4uZyhlKSB9KTtcbk4uc3RyaWN0Q3JlYXRlID0gKHIxOCwgZSkgPT4gbmV3IE4oeyBzaGFwZTogKCkgPT4gcjE4LCB1bmtub3duS2V5czogXCJzdHJpY3RcIiwgY2F0Y2hhbGw6IEQuY3JlYXRlKCksIHR5cGVOYW1lOiBtLlpvZE9iamVjdCwgLi4uZyhlKSB9KTtcbk4ubGF6eWNyZWF0ZSA9IChyMTgsIGUpID0+IG5ldyBOKHsgc2hhcGU6IHIxOCwgdW5rbm93bktleXM6IFwic3RyaXBcIiwgY2F0Y2hhbGw6IEQuY3JlYXRlKCksIHR5cGVOYW1lOiBtLlpvZE9iamVjdCwgLi4uZyhlKSB9KTtcbnZhciB5ZSA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHsgY3R4OiB0IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG4gPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBzKGEpIHtcbiAgICAgIGZvciAobGV0IG8gb2YgYSkgaWYgKG8ucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSByZXR1cm4gby5yZXN1bHQ7XG4gICAgICBmb3IgKGxldCBvIG9mIGEpIGlmIChvLnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikgcmV0dXJuIHQuY29tbW9uLmlzc3Vlcy5wdXNoKC4uLm8uY3R4LmNvbW1vbi5pc3N1ZXMpLCBvLnJlc3VsdDtcbiAgICAgIGxldCBpID0gYS5tYXAoKG8pID0+IG5ldyBQKG8uY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgIHJldHVybiBmKHQsIHsgY29kZTogYy5pbnZhbGlkX3VuaW9uLCB1bmlvbkVycm9yczogaSB9KSwgeTtcbiAgICB9XG4gICAgaWYgKHQuY29tbW9uLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5hbGwobi5tYXAoYXN5bmMgKGEpID0+IHtcbiAgICAgIGxldCBpID0geyAuLi50LCBjb21tb246IHsgLi4udC5jb21tb24sIGlzc3VlczogW10gfSwgcGFyZW50OiBudWxsIH07XG4gICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGEuX3BhcnNlQXN5bmMoeyBkYXRhOiB0LmRhdGEsIHBhdGg6IHQucGF0aCwgcGFyZW50OiBpIH0pLCBjdHg6IGkgfTtcbiAgICB9KSkudGhlbihzKTtcbiAgICB7XG4gICAgICBsZXQgYSwgaSA9IFtdO1xuICAgICAgZm9yIChsZXQgdSBvZiBuKSB7XG4gICAgICAgIGxldCBsID0geyAuLi50LCBjb21tb246IHsgLi4udC5jb21tb24sIGlzc3VlczogW10gfSwgcGFyZW50OiBudWxsIH0sIGggPSB1Ll9wYXJzZVN5bmMoeyBkYXRhOiB0LmRhdGEsIHBhdGg6IHQucGF0aCwgcGFyZW50OiBsIH0pO1xuICAgICAgICBpZiAoaC5zdGF0dXMgPT09IFwidmFsaWRcIikgcmV0dXJuIGg7XG4gICAgICAgIGguc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWEgJiYgKGEgPSB7IHJlc3VsdDogaCwgY3R4OiBsIH0pLCBsLmNvbW1vbi5pc3N1ZXMubGVuZ3RoICYmIGkucHVzaChsLmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGEpIHJldHVybiB0LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5hLmN0eC5jb21tb24uaXNzdWVzKSwgYS5yZXN1bHQ7XG4gICAgICBsZXQgbyA9IGkubWFwKCh1KSA9PiBuZXcgUCh1KSk7XG4gICAgICByZXR1cm4gZih0LCB7IGNvZGU6IGMuaW52YWxpZF91bmlvbiwgdW5pb25FcnJvcnM6IG8gfSksIHk7XG4gICAgfVxuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgfVxufTtcbnllLmNyZWF0ZSA9IChyMTgsIGUpID0+IG5ldyB5ZSh7IG9wdGlvbnM6IHIxOCwgdHlwZU5hbWU6IG0uWm9kVW5pb24sIC4uLmcoZSkgfSk7XG52YXIgWCA9IChyMTgpID0+IHIxOCBpbnN0YW5jZW9mIF9lID8gWChyMTguc2NoZW1hKSA6IHIxOCBpbnN0YW5jZW9mIFogPyBYKHIxOC5pbm5lclR5cGUoKSkgOiByMTggaW5zdGFuY2VvZiB2ZSA/IFtyMTgudmFsdWVdIDogcjE4IGluc3RhbmNlb2YgeGUgPyByMTgub3B0aW9ucyA6IHIxOCBpbnN0YW5jZW9mIHdlID8gdy5vYmplY3RWYWx1ZXMocjE4LmVudW0pIDogcjE4IGluc3RhbmNlb2YgYmUgPyBYKHIxOC5fZGVmLmlubmVyVHlwZSkgOiByMTggaW5zdGFuY2VvZiBwZSA/IFt2b2lkIDBdIDogcjE4IGluc3RhbmNlb2YgbWUgPyBbbnVsbF0gOiByMTggaW5zdGFuY2VvZiB6ID8gW3ZvaWQgMCwgLi4uWChyMTgudW53cmFwKCkpXSA6IHIxOCBpbnN0YW5jZW9mICQgPyBbbnVsbCwgLi4uWChyMTgudW53cmFwKCkpXSA6IHIxOCBpbnN0YW5jZW9mIFFlIHx8IHIxOCBpbnN0YW5jZW9mIGtlID8gWChyMTgudW53cmFwKCkpIDogcjE4IGluc3RhbmNlb2YgU2UgPyBYKHIxOC5fZGVmLmlubmVyVHlwZSkgOiBbXTtcbnZhciBfdCA9IGNsYXNzIHIxMSBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmICh0LnBhcnNlZFR5cGUgIT09IGQub2JqZWN0KSByZXR1cm4gZih0LCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5vYmplY3QsIHJlY2VpdmVkOiB0LnBhcnNlZFR5cGUgfSksIHk7XG4gICAgbGV0IG4gPSB0aGlzLmRpc2NyaW1pbmF0b3IsIHMgPSB0LmRhdGFbbl0sIGEgPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KHMpO1xuICAgIHJldHVybiBhID8gdC5jb21tb24uYXN5bmMgPyBhLl9wYXJzZUFzeW5jKHsgZGF0YTogdC5kYXRhLCBwYXRoOiB0LnBhdGgsIHBhcmVudDogdCB9KSA6IGEuX3BhcnNlU3luYyh7IGRhdGE6IHQuZGF0YSwgcGF0aDogdC5wYXRoLCBwYXJlbnQ6IHQgfSkgOiAoZih0LCB7IGNvZGU6IGMuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLCBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLCBwYXRoOiBbbl0gfSksIHkpO1xuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSwgdCwgbikge1xuICAgIGxldCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBhIG9mIHQpIHtcbiAgICAgIGxldCBpID0gWChhLnNoYXBlW2VdKTtcbiAgICAgIGlmICghaS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgQSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciBrZXkgXFxgJHtlfVxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XG4gICAgICBmb3IgKGxldCBvIG9mIGkpIHtcbiAgICAgICAgaWYgKHMuaGFzKG8pKSB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZSl9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcobyl9YCk7XG4gICAgICAgIHMuc2V0KG8sIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IHIxMSh7IHR5cGVOYW1lOiBtLlpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgZGlzY3JpbWluYXRvcjogZSwgb3B0aW9uczogdCwgb3B0aW9uc01hcDogcywgLi4uZyhuKSB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIFh0KHIxOCwgZSkge1xuICBsZXQgdCA9IG5lKHIxOCksIG4gPSBuZShlKTtcbiAgaWYgKHIxOCA9PT0gZSkgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IHIxOCB9O1xuICBpZiAodCA9PT0gZC5vYmplY3QgJiYgbiA9PT0gZC5vYmplY3QpIHtcbiAgICBsZXQgcyA9IHcub2JqZWN0S2V5cyhlKSwgYSA9IHcub2JqZWN0S2V5cyhyMTgpLmZpbHRlcigobykgPT4gcy5pbmRleE9mKG8pICE9PSAtMSksIGkgPSB7IC4uLnIxOCwgLi4uZSB9O1xuICAgIGZvciAobGV0IG8gb2YgYSkge1xuICAgICAgbGV0IHUgPSBYdChyMThbb10sIGVbb10pO1xuICAgICAgaWYgKCF1LnZhbGlkKSByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIGlbb10gPSB1LmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBpIH07XG4gIH0gZWxzZSBpZiAodCA9PT0gZC5hcnJheSAmJiBuID09PSBkLmFycmF5KSB7XG4gICAgaWYgKHIxOC5sZW5ndGggIT09IGUubGVuZ3RoKSByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICBsZXQgcyA9IFtdO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgcjE4Lmxlbmd0aDsgYSsrKSB7XG4gICAgICBsZXQgaSA9IHIxOFthXSwgbyA9IGVbYV0sIHUgPSBYdChpLCBvKTtcbiAgICAgIGlmICghdS52YWxpZCkgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICBzLnB1c2godS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IHMgfTtcbiAgfSBlbHNlIHJldHVybiB0ID09PSBkLmRhdGUgJiYgbiA9PT0gZC5kYXRlICYmICtyMTggPT0gK2UgPyB7IHZhbGlkOiB0cnVlLCBkYXRhOiByMTggfSA6IHsgdmFsaWQ6IGZhbHNlIH07XG59XG52YXIgZ2UgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IHN0YXR1czogdCwgY3R4OiBuIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIHMgPSAoYSwgaSkgPT4ge1xuICAgICAgaWYgKEd0KGEpIHx8IEd0KGkpKSByZXR1cm4geTtcbiAgICAgIGxldCBvID0gWHQoYS52YWx1ZSwgaS52YWx1ZSk7XG4gICAgICByZXR1cm4gby52YWxpZCA/ICgoSHQoYSkgfHwgSHQoaSkpICYmIHQuZGlydHkoKSwgeyBzdGF0dXM6IHQudmFsdWUsIHZhbHVlOiBvLmRhdGEgfSkgOiAoZihuLCB7IGNvZGU6IGMuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMgfSksIHkpO1xuICAgIH07XG4gICAgcmV0dXJuIG4uY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoW3RoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KV0pLnRoZW4oKFthLCBpXSkgPT4gcyhhLCBpKSkgOiBzKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoeyBkYXRhOiBuLmRhdGEsIHBhdGg6IG4ucGF0aCwgcGFyZW50OiBuIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSkpO1xuICB9XG59O1xuZ2UuY3JlYXRlID0gKHIxOCwgZSwgdCkgPT4gbmV3IGdlKHsgbGVmdDogcjE4LCByaWdodDogZSwgdHlwZU5hbWU6IG0uWm9kSW50ZXJzZWN0aW9uLCAuLi5nKHQpIH0pO1xudmFyIFUgPSBjbGFzcyByMTIgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgeyBzdGF0dXM6IHQsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGQuYXJyYXkpIHJldHVybiBmKG4sIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLmFycmF5LCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIGlmIChuLmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGYobiwgeyBjb2RlOiBjLnRvb19zbWFsbCwgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCwgaW5jbHVzaXZlOiB0cnVlLCBleGFjdDogZmFsc2UsIHR5cGU6IFwiYXJyYXlcIiB9KSwgeTtcbiAgICAhdGhpcy5fZGVmLnJlc3QgJiYgbi5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGggJiYgKGYobiwgeyBjb2RlOiBjLnRvb19iaWcsIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IGZhbHNlLCB0eXBlOiBcImFycmF5XCIgfSksIHQuZGlydHkoKSk7XG4gICAgbGV0IGEgPSBbLi4ubi5kYXRhXS5tYXAoKGksIG8pID0+IHtcbiAgICAgIGxldCB1ID0gdGhpcy5fZGVmLml0ZW1zW29dIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgcmV0dXJuIHUgPyB1Ll9wYXJzZShuZXcgTShuLCBpLCBuLnBhdGgsIG8pKSA6IG51bGw7XG4gICAgfSkuZmlsdGVyKChpKSA9PiAhIWkpO1xuICAgIHJldHVybiBuLmNvbW1vbi5hc3luYyA/IFByb21pc2UuYWxsKGEpLnRoZW4oKGkpID0+IFIubWVyZ2VBcnJheSh0LCBpKSkgOiBSLm1lcmdlQXJyYXkodCwgYSk7XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChlKSB7XG4gICAgcmV0dXJuIG5ldyByMTIoeyAuLi50aGlzLl9kZWYsIHJlc3Q6IGUgfSk7XG4gIH1cbn07XG5VLmNyZWF0ZSA9IChyMTgsIGUpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHIxOCkpIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICByZXR1cm4gbmV3IFUoeyBpdGVtczogcjE4LCB0eXBlTmFtZTogbS5ab2RUdXBsZSwgcmVzdDogbnVsbCwgLi4uZyhlKSB9KTtcbn07XG52YXIgdnQgPSBjbGFzcyByMTMgZXh0ZW5kcyBfIHtcbiAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gIH1cbiAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHsgc3RhdHVzOiB0LCBjdHg6IG4gfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBpZiAobi5wYXJzZWRUeXBlICE9PSBkLm9iamVjdCkgcmV0dXJuIGYobiwgeyBjb2RlOiBjLmludmFsaWRfdHlwZSwgZXhwZWN0ZWQ6IGQub2JqZWN0LCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIGxldCBzID0gW10sIGEgPSB0aGlzLl9kZWYua2V5VHlwZSwgaSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZm9yIChsZXQgbyBpbiBuLmRhdGEpIHMucHVzaCh7IGtleTogYS5fcGFyc2UobmV3IE0obiwgbywgbi5wYXRoLCBvKSksIHZhbHVlOiBpLl9wYXJzZShuZXcgTShuLCBuLmRhdGFbb10sIG4ucGF0aCwgbykpLCBhbHdheXNTZXQ6IG8gaW4gbi5kYXRhIH0pO1xuICAgIHJldHVybiBuLmNvbW1vbi5hc3luYyA/IFIubWVyZ2VPYmplY3RBc3luYyh0LCBzKSA6IFIubWVyZ2VPYmplY3RTeW5jKHQsIHMpO1xuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSwgdCwgbikge1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgXyA/IG5ldyByMTMoeyBrZXlUeXBlOiBlLCB2YWx1ZVR5cGU6IHQsIHR5cGVOYW1lOiBtLlpvZFJlY29yZCwgLi4uZyhuKSB9KSA6IG5ldyByMTMoeyBrZXlUeXBlOiBzZS5jcmVhdGUoKSwgdmFsdWVUeXBlOiBlLCB0eXBlTmFtZTogbS5ab2RSZWNvcmQsIC4uLmcodCkgfSk7XG4gIH1cbn07XG52YXIgTGUgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgeyBzdGF0dXM6IHQsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGQubWFwKSByZXR1cm4gZihuLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5tYXAsIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgbGV0IHMgPSB0aGlzLl9kZWYua2V5VHlwZSwgYSA9IHRoaXMuX2RlZi52YWx1ZVR5cGUsIGkgPSBbLi4ubi5kYXRhLmVudHJpZXMoKV0ubWFwKChbbywgdV0sIGwpID0+ICh7IGtleTogcy5fcGFyc2UobmV3IE0obiwgbywgbi5wYXRoLCBbbCwgXCJrZXlcIl0pKSwgdmFsdWU6IGEuX3BhcnNlKG5ldyBNKG4sIHUsIG4ucGF0aCwgW2wsIFwidmFsdWVcIl0pKSB9KSk7XG4gICAgaWYgKG4uY29tbW9uLmFzeW5jKSB7XG4gICAgICBsZXQgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IHUgb2YgaSkge1xuICAgICAgICAgIGxldCBsID0gYXdhaXQgdS5rZXksIGggPSBhd2FpdCB1LnZhbHVlO1xuICAgICAgICAgIGlmIChsLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgaC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgICAgICAobC5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCBoLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSAmJiB0LmRpcnR5KCksIG8uc2V0KGwudmFsdWUsIGgudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IG8gfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCB1IG9mIGkpIHtcbiAgICAgICAgbGV0IGwgPSB1LmtleSwgaCA9IHUudmFsdWU7XG4gICAgICAgIGlmIChsLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgaC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgICAgKGwuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgaC5zdGF0dXMgPT09IFwiZGlydHlcIikgJiYgdC5kaXJ0eSgpLCBvLnNldChsLnZhbHVlLCBoLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IG8gfTtcbiAgICB9XG4gIH1cbn07XG5MZS5jcmVhdGUgPSAocjE4LCBlLCB0KSA9PiBuZXcgTGUoeyB2YWx1ZVR5cGU6IGUsIGtleVR5cGU6IHIxOCwgdHlwZU5hbWU6IG0uWm9kTWFwLCAuLi5nKHQpIH0pO1xudmFyIFBlID0gY2xhc3MgcjE0IGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHsgc3RhdHVzOiB0LCBjdHg6IG4gfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBpZiAobi5wYXJzZWRUeXBlICE9PSBkLnNldCkgcmV0dXJuIGYobiwgeyBjb2RlOiBjLmludmFsaWRfdHlwZSwgZXhwZWN0ZWQ6IGQuc2V0LCByZWNlaXZlZDogbi5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIGxldCBzID0gdGhpcy5fZGVmO1xuICAgIHMubWluU2l6ZSAhPT0gbnVsbCAmJiBuLmRhdGEuc2l6ZSA8IHMubWluU2l6ZS52YWx1ZSAmJiAoZihuLCB7IGNvZGU6IGMudG9vX3NtYWxsLCBtaW5pbXVtOiBzLm1pblNpemUudmFsdWUsIHR5cGU6IFwic2V0XCIsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IGZhbHNlLCBtZXNzYWdlOiBzLm1pblNpemUubWVzc2FnZSB9KSwgdC5kaXJ0eSgpKSwgcy5tYXhTaXplICE9PSBudWxsICYmIG4uZGF0YS5zaXplID4gcy5tYXhTaXplLnZhbHVlICYmIChmKG4sIHsgY29kZTogYy50b29fYmlnLCBtYXhpbXVtOiBzLm1heFNpemUudmFsdWUsIHR5cGU6IFwic2V0XCIsIGluY2x1c2l2ZTogdHJ1ZSwgZXhhY3Q6IGZhbHNlLCBtZXNzYWdlOiBzLm1heFNpemUubWVzc2FnZSB9KSwgdC5kaXJ0eSgpKTtcbiAgICBsZXQgYSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZnVuY3Rpb24gaSh1KSB7XG4gICAgICBsZXQgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGxldCBoIG9mIHUpIHtcbiAgICAgICAgaWYgKGguc3RhdHVzID09PSBcImFib3J0ZWRcIikgcmV0dXJuIHk7XG4gICAgICAgIGguc3RhdHVzID09PSBcImRpcnR5XCIgJiYgdC5kaXJ0eSgpLCBsLmFkZChoLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IGwgfTtcbiAgICB9XG4gICAgbGV0IG8gPSBbLi4ubi5kYXRhLnZhbHVlcygpXS5tYXAoKHUsIGwpID0+IGEuX3BhcnNlKG5ldyBNKG4sIHUsIG4ucGF0aCwgbCkpKTtcbiAgICByZXR1cm4gbi5jb21tb24uYXN5bmMgPyBQcm9taXNlLmFsbChvKS50aGVuKCh1KSA9PiBpKHUpKSA6IGkobyk7XG4gIH1cbiAgbWluKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IHIxNCh7IC4uLnRoaXMuX2RlZiwgbWluU2l6ZTogeyB2YWx1ZTogZSwgbWVzc2FnZTogcC50b1N0cmluZyh0KSB9IH0pO1xuICB9XG4gIG1heChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyByMTQoeyAuLi50aGlzLl9kZWYsIG1heFNpemU6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IHAudG9TdHJpbmcodCkgfSB9KTtcbiAgfVxuICBzaXplKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oZSwgdCkubWF4KGUsIHQpO1xuICB9XG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZSk7XG4gIH1cbn07XG5QZS5jcmVhdGUgPSAocjE4LCBlKSA9PiBuZXcgUGUoeyB2YWx1ZVR5cGU6IHIxOCwgbWluU2l6ZTogbnVsbCwgbWF4U2l6ZTogbnVsbCwgdHlwZU5hbWU6IG0uWm9kU2V0LCAuLi5nKGUpIH0pO1xudmFyIHh0ID0gY2xhc3MgcjE1IGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmICh0LnBhcnNlZFR5cGUgIT09IGQuZnVuY3Rpb24pIHJldHVybiBmKHQsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLmZ1bmN0aW9uLCByZWNlaXZlZDogdC5wYXJzZWRUeXBlIH0pLCB5O1xuICAgIGZ1bmN0aW9uIG4obywgdSkge1xuICAgICAgcmV0dXJuIG10KHsgZGF0YTogbywgcGF0aDogdC5wYXRoLCBlcnJvck1hcHM6IFt0LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIHQuc2NoZW1hRXJyb3JNYXAsIHB0KCksIGplXS5maWx0ZXIoKGwpID0+ICEhbCksIGlzc3VlRGF0YTogeyBjb2RlOiBjLmludmFsaWRfYXJndW1lbnRzLCBhcmd1bWVudHNFcnJvcjogdSB9IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKG8sIHUpIHtcbiAgICAgIHJldHVybiBtdCh7IGRhdGE6IG8sIHBhdGg6IHQucGF0aCwgZXJyb3JNYXBzOiBbdC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCB0LnNjaGVtYUVycm9yTWFwLCBwdCgpLCBqZV0uZmlsdGVyKChsKSA9PiAhIWwpLCBpc3N1ZURhdGE6IHsgY29kZTogYy5pbnZhbGlkX3JldHVybl90eXBlLCByZXR1cm5UeXBlRXJyb3I6IHUgfSB9KTtcbiAgICB9XG4gICAgbGV0IGEgPSB7IGVycm9yTWFwOiB0LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfSwgaSA9IHQuZGF0YTtcbiAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBpZSkge1xuICAgICAgbGV0IG8gPSB0aGlzO1xuICAgICAgcmV0dXJuIGooYXN5bmMgZnVuY3Rpb24oLi4udSkge1xuICAgICAgICBsZXQgbCA9IG5ldyBQKFtdKSwgaCA9IGF3YWl0IG8uX2RlZi5hcmdzLnBhcnNlQXN5bmModSwgYSkuY2F0Y2goKFMpID0+IHtcbiAgICAgICAgICB0aHJvdyBsLmFkZElzc3VlKG4odSwgUykpLCBsO1xuICAgICAgICB9KSwgdjIgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGksIHRoaXMsIGgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgby5fZGVmLnJldHVybnMuX2RlZi50eXBlLnBhcnNlQXN5bmModjIsIGEpLmNhdGNoKChTKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbC5hZGRJc3N1ZShzKHYyLCBTKSksIGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvID0gdGhpcztcbiAgICAgIHJldHVybiBqKGZ1bmN0aW9uKC4uLnUpIHtcbiAgICAgICAgbGV0IGwgPSBvLl9kZWYuYXJncy5zYWZlUGFyc2UodSwgYSk7XG4gICAgICAgIGlmICghbC5zdWNjZXNzKSB0aHJvdyBuZXcgUChbbih1LCBsLmVycm9yKV0pO1xuICAgICAgICBsZXQgaCA9IFJlZmxlY3QuYXBwbHkoaSwgdGhpcywgbC5kYXRhKSwgdjIgPSBvLl9kZWYucmV0dXJucy5zYWZlUGFyc2UoaCwgYSk7XG4gICAgICAgIGlmICghdjIuc3VjY2VzcykgdGhyb3cgbmV3IFAoW3MoaCwgdjIuZXJyb3IpXSk7XG4gICAgICAgIHJldHVybiB2Mi5kYXRhO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICB9XG4gIHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICB9XG4gIGFyZ3MoLi4uZSkge1xuICAgIHJldHVybiBuZXcgcjE1KHsgLi4udGhpcy5fZGVmLCBhcmdzOiBVLmNyZWF0ZShlKS5yZXN0KFkuY3JlYXRlKCkpIH0pO1xuICB9XG4gIHJldHVybnMoZSkge1xuICAgIHJldHVybiBuZXcgcjE1KHsgLi4udGhpcy5fZGVmLCByZXR1cm5zOiBlIH0pO1xuICB9XG4gIGltcGxlbWVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoZSk7XG4gIH1cbiAgc3RyaWN0SW1wbGVtZW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZShlKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHQsIG4pIHtcbiAgICByZXR1cm4gbmV3IHIxNSh7IGFyZ3M6IGUgfHwgVS5jcmVhdGUoW10pLnJlc3QoWS5jcmVhdGUoKSksIHJldHVybnM6IHQgfHwgWS5jcmVhdGUoKSwgdHlwZU5hbWU6IG0uWm9kRnVuY3Rpb24sIC4uLmcobikgfSk7XG4gIH1cbn07XG52YXIgX2UgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgeyBjdHg6IHQgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpLl9wYXJzZSh7IGRhdGE6IHQuZGF0YSwgcGF0aDogdC5wYXRoLCBwYXJlbnQ6IHQgfSk7XG4gIH1cbn07XG5fZS5jcmVhdGUgPSAocjE4LCBlKSA9PiBuZXcgX2UoeyBnZXR0ZXI6IHIxOCwgdHlwZU5hbWU6IG0uWm9kTGF6eSwgLi4uZyhlKSB9KTtcbnZhciB2ZSA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKGUuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XG4gICAgICBsZXQgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGYodCwgeyByZWNlaXZlZDogdC5kYXRhLCBjb2RlOiBjLmludmFsaWRfbGl0ZXJhbCwgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSB9KSwgeTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgfVxufTtcbnZlLmNyZWF0ZSA9IChyMTgsIGUpID0+IG5ldyB2ZSh7IHZhbHVlOiByMTgsIHR5cGVOYW1lOiBtLlpvZExpdGVyYWwsIC4uLmcoZSkgfSk7XG5mdW5jdGlvbiBEcihyMTgsIGUpIHtcbiAgcmV0dXJuIG5ldyB4ZSh7IHZhbHVlczogcjE4LCB0eXBlTmFtZTogbS5ab2RFbnVtLCAuLi5nKGUpIH0pO1xufVxudmFyIHhlID0gY2xhc3MgcjE2IGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIFhlLnNldCh0aGlzLCB2b2lkIDApO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlLmRhdGEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgbGV0IHQgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgbiA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gZih0LCB7IGV4cGVjdGVkOiB3LmpvaW5WYWx1ZXMobiksIHJlY2VpdmVkOiB0LnBhcnNlZFR5cGUsIGNvZGU6IGMuaW52YWxpZF90eXBlIH0pLCB5O1xuICAgIH1cbiAgICBpZiAoZ3QodGhpcywgWGUsIFwiZlwiKSB8fCBacih0aGlzLCBYZSwgbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKSwgXCJmXCIpLCAhZ3QodGhpcywgWGUsIFwiZlwiKS5oYXMoZS5kYXRhKSkge1xuICAgICAgbGV0IHQgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgbiA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gZih0LCB7IHJlY2VpdmVkOiB0LmRhdGEsIGNvZGU6IGMuaW52YWxpZF9lbnVtX3ZhbHVlLCBvcHRpb25zOiBuIH0pLCB5O1xuICAgIH1cbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGxldCBlID0ge307XG4gICAgZm9yIChsZXQgdCBvZiB0aGlzLl9kZWYudmFsdWVzKSBlW3RdID0gdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgVmFsdWVzKCkge1xuICAgIGxldCBlID0ge307XG4gICAgZm9yIChsZXQgdCBvZiB0aGlzLl9kZWYudmFsdWVzKSBlW3RdID0gdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgRW51bSgpIHtcbiAgICBsZXQgZSA9IHt9O1xuICAgIGZvciAobGV0IHQgb2YgdGhpcy5fZGVmLnZhbHVlcykgZVt0XSA9IHQ7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZXh0cmFjdChlLCB0ID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIHIxNi5jcmVhdGUoZSwgeyAuLi50aGlzLl9kZWYsIC4uLnQgfSk7XG4gIH1cbiAgZXhjbHVkZShlLCB0ID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIHIxNi5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigobikgPT4gIWUuaW5jbHVkZXMobikpLCB7IC4uLnRoaXMuX2RlZiwgLi4udCB9KTtcbiAgfVxufTtcblhlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG54ZS5jcmVhdGUgPSBEcjtcbnZhciB3ZSA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIFllLnNldCh0aGlzLCB2b2lkIDApO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHQgPSB3LmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSwgbiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIGlmIChuLnBhcnNlZFR5cGUgIT09IGQuc3RyaW5nICYmIG4ucGFyc2VkVHlwZSAhPT0gZC5udW1iZXIpIHtcbiAgICAgIGxldCBzID0gdy5vYmplY3RWYWx1ZXModCk7XG4gICAgICByZXR1cm4gZihuLCB7IGV4cGVjdGVkOiB3LmpvaW5WYWx1ZXMocyksIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGUsIGNvZGU6IGMuaW52YWxpZF90eXBlIH0pLCB5O1xuICAgIH1cbiAgICBpZiAoZ3QodGhpcywgWWUsIFwiZlwiKSB8fCBacih0aGlzLCBZZSwgbmV3IFNldCh3LmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKSwgIWd0KHRoaXMsIFllLCBcImZcIikuaGFzKGUuZGF0YSkpIHtcbiAgICAgIGxldCBzID0gdy5vYmplY3RWYWx1ZXModCk7XG4gICAgICByZXR1cm4gZihuLCB7IHJlY2VpdmVkOiBuLmRhdGEsIGNvZGU6IGMuaW52YWxpZF9lbnVtX3ZhbHVlLCBvcHRpb25zOiBzIH0pLCB5O1xuICAgIH1cbiAgICByZXR1cm4gaihlLmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuWWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbndlLmNyZWF0ZSA9IChyMTgsIGUpID0+IG5ldyB3ZSh7IHZhbHVlczogcjE4LCB0eXBlTmFtZTogbS5ab2ROYXRpdmVFbnVtLCAuLi5nKGUpIH0pO1xudmFyIGllID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmICh0LnBhcnNlZFR5cGUgIT09IGQucHJvbWlzZSAmJiB0LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHJldHVybiBmKHQsIHsgY29kZTogYy5pbnZhbGlkX3R5cGUsIGV4cGVjdGVkOiBkLnByb21pc2UsIHJlY2VpdmVkOiB0LnBhcnNlZFR5cGUgfSksIHk7XG4gICAgbGV0IG4gPSB0LnBhcnNlZFR5cGUgPT09IGQucHJvbWlzZSA/IHQuZGF0YSA6IFByb21pc2UucmVzb2x2ZSh0LmRhdGEpO1xuICAgIHJldHVybiBqKG4udGhlbigocykgPT4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhzLCB7IHBhdGg6IHQucGF0aCwgZXJyb3JNYXA6IHQuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9KSkpO1xuICB9XG59O1xuaWUuY3JlYXRlID0gKHIxOCwgZSkgPT4gbmV3IGllKHsgdHlwZTogcjE4LCB0eXBlTmFtZTogbS5ab2RQcm9taXNlLCAuLi5nKGUpIH0pO1xudmFyIFogPSBjbGFzcyBleHRlbmRzIF8ge1xuICBpbm5lclR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgc291cmNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBtLlpvZEVmZmVjdHMgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKSA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgeyBzdGF0dXM6IHQsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBzID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsLCBhID0geyBhZGRJc3N1ZTogKGkpID0+IHtcbiAgICAgIGYobiwgaSksIGkuZmF0YWwgPyB0LmFib3J0KCkgOiB0LmRpcnR5KCk7XG4gICAgfSwgZ2V0IHBhdGgoKSB7XG4gICAgICByZXR1cm4gbi5wYXRoO1xuICAgIH0gfTtcbiAgICBpZiAoYS5hZGRJc3N1ZSA9IGEuYWRkSXNzdWUuYmluZChhKSwgcy50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgbGV0IGkgPSBzLnRyYW5zZm9ybShuLmRhdGEsIGEpO1xuICAgICAgaWYgKG4uY29tbW9uLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkpLnRoZW4oYXN5bmMgKG8pID0+IHtcbiAgICAgICAgaWYgKHQudmFsdWUgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgICAgbGV0IHUgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogbywgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgICAgIHJldHVybiB1LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyB5IDogdS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB0LnZhbHVlID09PSBcImRpcnR5XCIgPyBSZSh1LnZhbHVlKSA6IHU7XG4gICAgICB9KTtcbiAgICAgIHtcbiAgICAgICAgaWYgKHQudmFsdWUgPT09IFwiYWJvcnRlZFwiKSByZXR1cm4geTtcbiAgICAgICAgbGV0IG8gPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoeyBkYXRhOiBpLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KTtcbiAgICAgICAgcmV0dXJuIG8uc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IHkgOiBvLnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHQudmFsdWUgPT09IFwiZGlydHlcIiA/IFJlKG8udmFsdWUpIDogbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGxldCBpID0gKG8pID0+IHtcbiAgICAgICAgbGV0IHUgPSBzLnJlZmluZW1lbnQobywgYSk7XG4gICAgICAgIGlmIChuLmNvbW1vbi5hc3luYykgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1KTtcbiAgICAgICAgaWYgKHUgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9O1xuICAgICAgaWYgKG4uY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBsZXQgbyA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgICAgIHJldHVybiBvLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyB5IDogKG8uc3RhdHVzID09PSBcImRpcnR5XCIgJiYgdC5kaXJ0eSgpLCBpKG8udmFsdWUpLCB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IG8udmFsdWUgfSk7XG4gICAgICB9IGVsc2UgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBuLmRhdGEsIHBhdGg6IG4ucGF0aCwgcGFyZW50OiBuIH0pLnRoZW4oKG8pID0+IG8uc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IHkgOiAoby5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiB0LmRpcnR5KCksIGkoby52YWx1ZSkudGhlbigoKSA9PiAoeyBzdGF0dXM6IHQudmFsdWUsIHZhbHVlOiBvLnZhbHVlIH0pKSkpO1xuICAgIH1cbiAgICBpZiAocy50eXBlID09PSBcInRyYW5zZm9ybVwiKSBpZiAobi5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgICBpZiAoIUplKGkpKSByZXR1cm4gaTtcbiAgICAgIGxldCBvID0gcy50cmFuc2Zvcm0oaS52YWx1ZSwgYSk7XG4gICAgICBpZiAobyBpbnN0YW5jZW9mIFByb21pc2UpIHRocm93IG5ldyBFcnJvcihcIkFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgcmV0dXJuIHsgc3RhdHVzOiB0LnZhbHVlLCB2YWx1ZTogbyB9O1xuICAgIH0gZWxzZSByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSkudGhlbigoaSkgPT4gSmUoaSkgPyBQcm9taXNlLnJlc29sdmUocy50cmFuc2Zvcm0oaS52YWx1ZSwgYSkpLnRoZW4oKG8pID0+ICh7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IG8gfSkpIDogaSk7XG4gICAgdy5hc3NlcnROZXZlcihzKTtcbiAgfVxufTtcblouY3JlYXRlID0gKHIxOCwgZSwgdCkgPT4gbmV3IFooeyBzY2hlbWE6IHIxOCwgdHlwZU5hbWU6IG0uWm9kRWZmZWN0cywgZWZmZWN0OiBlLCAuLi5nKHQpIH0pO1xuWi5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChyMTgsIGUsIHQpID0+IG5ldyBaKHsgc2NoZW1hOiBlLCBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcjE4IH0sIHR5cGVOYW1lOiBtLlpvZEVmZmVjdHMsIC4uLmcodCkgfSk7XG52YXIgeiA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IGQudW5kZWZpbmVkID8gaih2b2lkIDApIDogdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoZSk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuei5jcmVhdGUgPSAocjE4LCBlKSA9PiBuZXcgeih7IGlubmVyVHlwZTogcjE4LCB0eXBlTmFtZTogbS5ab2RPcHRpb25hbCwgLi4uZyhlKSB9KTtcbnZhciAkID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZShlKSA9PT0gZC5udWxsID8gaihudWxsKSA6IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcbiQuY3JlYXRlID0gKHIxOCwgZSkgPT4gbmV3ICQoeyBpbm5lclR5cGU6IHIxOCwgdHlwZU5hbWU6IG0uWm9kTnVsbGFibGUsIC4uLmcoZSkgfSk7XG52YXIgYmUgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBuID0gdC5kYXRhO1xuICAgIHJldHVybiB0LnBhcnNlZFR5cGUgPT09IGQudW5kZWZpbmVkICYmIChuID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpKSwgdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoeyBkYXRhOiBuLCBwYXRoOiB0LnBhdGgsIHBhcmVudDogdCB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuYmUuY3JlYXRlID0gKHIxOCwgZSkgPT4gbmV3IGJlKHsgaW5uZXJUeXBlOiByMTgsIHR5cGVOYW1lOiBtLlpvZERlZmF1bHQsIGRlZmF1bHRWYWx1ZTogdHlwZW9mIGUuZGVmYXVsdCA9PSBcImZ1bmN0aW9uXCIgPyBlLmRlZmF1bHQgOiAoKSA9PiBlLmRlZmF1bHQsIC4uLmcoZSkgfSk7XG52YXIgU2UgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGxldCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBuID0geyAuLi50LCBjb21tb246IHsgLi4udC5jb21tb24sIGlzc3VlczogW10gfSB9LCBzID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoeyBkYXRhOiBuLmRhdGEsIHBhdGg6IG4ucGF0aCwgcGFyZW50OiB7IC4uLm4gfSB9KTtcbiAgICByZXR1cm4geXQocykgPyBzLnRoZW4oKGEpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogYS5zdGF0dXMgPT09IFwidmFsaWRcIiA/IGEudmFsdWUgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7IGdldCBlcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgUChuLmNvbW1vbi5pc3N1ZXMpO1xuICAgIH0sIGlucHV0OiBuLmRhdGEgfSkgfSkpIDogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IHMuc3RhdHVzID09PSBcInZhbGlkXCIgPyBzLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoeyBnZXQgZXJyb3IoKSB7XG4gICAgICByZXR1cm4gbmV3IFAobi5jb21tb24uaXNzdWVzKTtcbiAgICB9LCBpbnB1dDogbi5kYXRhIH0pIH07XG4gIH1cbiAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5TZS5jcmVhdGUgPSAocjE4LCBlKSA9PiBuZXcgU2UoeyBpbm5lclR5cGU6IHIxOCwgdHlwZU5hbWU6IG0uWm9kQ2F0Y2gsIGNhdGNoVmFsdWU6IHR5cGVvZiBlLmNhdGNoID09IFwiZnVuY3Rpb25cIiA/IGUuY2F0Y2ggOiAoKSA9PiBlLmNhdGNoLCAuLi5nKGUpIH0pO1xudmFyIFplID0gY2xhc3MgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gZC5uYW4pIHtcbiAgICAgIGxldCBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gZihuLCB7IGNvZGU6IGMuaW52YWxpZF90eXBlLCBleHBlY3RlZDogZC5uYW4sIHJlY2VpdmVkOiBuLnBhcnNlZFR5cGUgfSksIHk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbn07XG5aZS5jcmVhdGUgPSAocjE4KSA9PiBuZXcgWmUoeyB0eXBlTmFtZTogbS5ab2ROYU4sIC4uLmcocjE4KSB9KTtcbnZhciBscyA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbnZhciBRZSA9IGNsYXNzIGV4dGVuZHMgXyB7XG4gIF9wYXJzZShlKSB7XG4gICAgbGV0IHsgY3R4OiB0IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG4gPSB0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7IGRhdGE6IG4sIHBhdGg6IHQucGF0aCwgcGFyZW50OiB0IH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn07XG52YXIgS2UgPSBjbGFzcyByMTcgZXh0ZW5kcyBfIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBsZXQgeyBzdGF0dXM6IHQsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChuLmNvbW1vbi5hc3luYykgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYSA9IGF3YWl0IHRoaXMuX2RlZi5pbi5fcGFyc2VBc3luYyh7IGRhdGE6IG4uZGF0YSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgICByZXR1cm4gYS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8geSA6IGEuc3RhdHVzID09PSBcImRpcnR5XCIgPyAodC5kaXJ0eSgpLCBSZShhLnZhbHVlKSkgOiB0aGlzLl9kZWYub3V0Ll9wYXJzZUFzeW5jKHsgZGF0YTogYS52YWx1ZSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgfSkoKTtcbiAgICB7XG4gICAgICBsZXQgcyA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHsgZGF0YTogbi5kYXRhLCBwYXRoOiBuLnBhdGgsIHBhcmVudDogbiB9KTtcbiAgICAgIHJldHVybiBzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyB5IDogcy5zdGF0dXMgPT09IFwiZGlydHlcIiA/ICh0LmRpcnR5KCksIHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlOiBzLnZhbHVlIH0pIDogdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHsgZGF0YTogcy52YWx1ZSwgcGF0aDogbi5wYXRoLCBwYXJlbnQ6IG4gfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiBuZXcgcjE3KHsgaW46IGUsIG91dDogdCwgdHlwZU5hbWU6IG0uWm9kUGlwZWxpbmUgfSk7XG4gIH1cbn07XG52YXIga2UgPSBjbGFzcyBleHRlbmRzIF8ge1xuICBfcGFyc2UoZSkge1xuICAgIGxldCB0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoZSk7XG4gICAgcmV0dXJuIEplKHQpICYmICh0LnZhbHVlID0gT2JqZWN0LmZyZWV6ZSh0LnZhbHVlKSksIHQ7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xua2UuY3JlYXRlID0gKHIxOCwgZSkgPT4gbmV3IGtlKHsgaW5uZXJUeXBlOiByMTgsIHR5cGVOYW1lOiBtLlpvZFJlYWRvbmx5LCAuLi5nKGUpIH0pO1xuZnVuY3Rpb24gQnIocjE4LCBlID0ge30sIHQpIHtcbiAgcmV0dXJuIHIxOCA/IGFlLmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChuLCBzKSA9PiB7XG4gICAgdmFyIGEsIGk7XG4gICAgaWYgKCFyMTgobikpIHtcbiAgICAgIGxldCBvID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZShuKSA6IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IGUgfSA6IGUsIHUgPSAoaSA9IChhID0gby5mYXRhbCkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IHQpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiB0cnVlLCBsID0gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogbyB9IDogbztcbiAgICAgIHMuYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5sLCBmYXRhbDogdSB9KTtcbiAgICB9XG4gIH0pIDogYWUuY3JlYXRlKCk7XG59XG52YXIgY3MgPSB7IG9iamVjdDogTi5sYXp5Y3JlYXRlIH07XG52YXIgbTtcbihmdW5jdGlvbihyMTgpIHtcbiAgcjE4LlpvZFN0cmluZyA9IFwiWm9kU3RyaW5nXCIsIHIxOC5ab2ROdW1iZXIgPSBcIlpvZE51bWJlclwiLCByMTguWm9kTmFOID0gXCJab2ROYU5cIiwgcjE4LlpvZEJpZ0ludCA9IFwiWm9kQmlnSW50XCIsIHIxOC5ab2RCb29sZWFuID0gXCJab2RCb29sZWFuXCIsIHIxOC5ab2REYXRlID0gXCJab2REYXRlXCIsIHIxOC5ab2RTeW1ib2wgPSBcIlpvZFN5bWJvbFwiLCByMTguWm9kVW5kZWZpbmVkID0gXCJab2RVbmRlZmluZWRcIiwgcjE4LlpvZE51bGwgPSBcIlpvZE51bGxcIiwgcjE4LlpvZEFueSA9IFwiWm9kQW55XCIsIHIxOC5ab2RVbmtub3duID0gXCJab2RVbmtub3duXCIsIHIxOC5ab2ROZXZlciA9IFwiWm9kTmV2ZXJcIiwgcjE4LlpvZFZvaWQgPSBcIlpvZFZvaWRcIiwgcjE4LlpvZEFycmF5ID0gXCJab2RBcnJheVwiLCByMTguWm9kT2JqZWN0ID0gXCJab2RPYmplY3RcIiwgcjE4LlpvZFVuaW9uID0gXCJab2RVbmlvblwiLCByMTguWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIiwgcjE4LlpvZEludGVyc2VjdGlvbiA9IFwiWm9kSW50ZXJzZWN0aW9uXCIsIHIxOC5ab2RUdXBsZSA9IFwiWm9kVHVwbGVcIiwgcjE4LlpvZFJlY29yZCA9IFwiWm9kUmVjb3JkXCIsIHIxOC5ab2RNYXAgPSBcIlpvZE1hcFwiLCByMTguWm9kU2V0ID0gXCJab2RTZXRcIiwgcjE4LlpvZEZ1bmN0aW9uID0gXCJab2RGdW5jdGlvblwiLCByMTguWm9kTGF6eSA9IFwiWm9kTGF6eVwiLCByMTguWm9kTGl0ZXJhbCA9IFwiWm9kTGl0ZXJhbFwiLCByMTguWm9kRW51bSA9IFwiWm9kRW51bVwiLCByMTguWm9kRWZmZWN0cyA9IFwiWm9kRWZmZWN0c1wiLCByMTguWm9kTmF0aXZlRW51bSA9IFwiWm9kTmF0aXZlRW51bVwiLCByMTguWm9kT3B0aW9uYWwgPSBcIlpvZE9wdGlvbmFsXCIsIHIxOC5ab2ROdWxsYWJsZSA9IFwiWm9kTnVsbGFibGVcIiwgcjE4LlpvZERlZmF1bHQgPSBcIlpvZERlZmF1bHRcIiwgcjE4LlpvZENhdGNoID0gXCJab2RDYXRjaFwiLCByMTguWm9kUHJvbWlzZSA9IFwiWm9kUHJvbWlzZVwiLCByMTguWm9kQnJhbmRlZCA9IFwiWm9kQnJhbmRlZFwiLCByMTguWm9kUGlwZWxpbmUgPSBcIlpvZFBpcGVsaW5lXCIsIHIxOC5ab2RSZWFkb25seSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKG0gfHwgKG0gPSB7fSkpO1xudmFyIGZzID0gKHIxOCwgZSA9IHsgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke3IxOC5uYW1lfWAgfSkgPT4gQnIoKHQpID0+IHQgaW5zdGFuY2VvZiByMTgsIGUpO1xudmFyIEZyID0gc2UuY3JlYXRlO1xudmFyIFVyID0gY2UuY3JlYXRlO1xudmFyIGRzID0gWmUuY3JlYXRlO1xudmFyIGhzID0gZmUuY3JlYXRlO1xudmFyICRyID0gZGUuY3JlYXRlO1xudmFyIHBzID0gaGUuY3JlYXRlO1xudmFyIG1zID0gSWUuY3JlYXRlO1xudmFyIHlzID0gcGUuY3JlYXRlO1xudmFyIGdzID0gbWUuY3JlYXRlO1xudmFyIF9zID0gYWUuY3JlYXRlO1xudmFyIHZzID0gWS5jcmVhdGU7XG52YXIgeHMgPSBELmNyZWF0ZTtcbnZhciB3cyA9IE5lLmNyZWF0ZTtcbnZhciBicyA9IEouY3JlYXRlO1xudmFyIFNzID0gTi5jcmVhdGU7XG52YXIga3MgPSBOLnN0cmljdENyZWF0ZTtcbnZhciBUcyA9IHllLmNyZWF0ZTtcbnZhciBPcyA9IF90LmNyZWF0ZTtcbnZhciBFcyA9IGdlLmNyZWF0ZTtcbnZhciBBcyA9IFUuY3JlYXRlO1xudmFyIENzID0gdnQuY3JlYXRlO1xudmFyIFJzID0gTGUuY3JlYXRlO1xudmFyIGpzID0gUGUuY3JlYXRlO1xudmFyIElzID0geHQuY3JlYXRlO1xudmFyIE5zID0gX2UuY3JlYXRlO1xudmFyIExzID0gdmUuY3JlYXRlO1xudmFyIFBzID0geGUuY3JlYXRlO1xudmFyIFpzID0gd2UuY3JlYXRlO1xudmFyIFdzID0gaWUuY3JlYXRlO1xudmFyIExyID0gWi5jcmVhdGU7XG52YXIgenMgPSB6LmNyZWF0ZTtcbnZhciBNcyA9ICQuY3JlYXRlO1xudmFyIERzID0gWi5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbnZhciBCcyA9IEtlLmNyZWF0ZTtcbnZhciBGcyA9ICgpID0+IEZyKCkub3B0aW9uYWwoKTtcbnZhciBVcyA9ICgpID0+IFVyKCkub3B0aW9uYWwoKTtcbnZhciAkcyA9ICgpID0+ICRyKCkub3B0aW9uYWwoKTtcbnZhciBWcyA9IHsgc3RyaW5nOiAocjE4KSA9PiBzZS5jcmVhdGUoeyAuLi5yMTgsIGNvZXJjZTogdHJ1ZSB9KSwgbnVtYmVyOiAocjE4KSA9PiBjZS5jcmVhdGUoeyAuLi5yMTgsIGNvZXJjZTogdHJ1ZSB9KSwgYm9vbGVhbjogKHIxOCkgPT4gZGUuY3JlYXRlKHsgLi4ucjE4LCBjb2VyY2U6IHRydWUgfSksIGJpZ2ludDogKHIxOCkgPT4gZmUuY3JlYXRlKHsgLi4ucjE4LCBjb2VyY2U6IHRydWUgfSksIGRhdGU6IChyMTgpID0+IGhlLmNyZWF0ZSh7IC4uLnIxOCwgY29lcmNlOiB0cnVlIH0pIH07XG52YXIgcXMgPSB5O1xudmFyIGIgPSBPYmplY3QuZnJlZXplKHsgX19wcm90b19fOiBudWxsLCBkZWZhdWx0RXJyb3JNYXA6IGplLCBzZXRFcnJvck1hcDogcW4sIGdldEVycm9yTWFwOiBwdCwgbWFrZUlzc3VlOiBtdCwgRU1QVFlfUEFUSDogR24sIGFkZElzc3VlVG9Db250ZXh0OiBmLCBQYXJzZVN0YXR1czogUiwgSU5WQUxJRDogeSwgRElSVFk6IFJlLCBPSzogaiwgaXNBYm9ydGVkOiBHdCwgaXNEaXJ0eTogSHQsIGlzVmFsaWQ6IEplLCBpc0FzeW5jOiB5dCwgZ2V0IHV0aWwoKSB7XG4gIHJldHVybiB3O1xufSwgZ2V0IG9iamVjdFV0aWwoKSB7XG4gIHJldHVybiBxdDtcbn0sIFpvZFBhcnNlZFR5cGU6IGQsIGdldFBhcnNlZFR5cGU6IG5lLCBab2RUeXBlOiBfLCBkYXRldGltZVJlZ2V4OiBNciwgWm9kU3RyaW5nOiBzZSwgWm9kTnVtYmVyOiBjZSwgWm9kQmlnSW50OiBmZSwgWm9kQm9vbGVhbjogZGUsIFpvZERhdGU6IGhlLCBab2RTeW1ib2w6IEllLCBab2RVbmRlZmluZWQ6IHBlLCBab2ROdWxsOiBtZSwgWm9kQW55OiBhZSwgWm9kVW5rbm93bjogWSwgWm9kTmV2ZXI6IEQsIFpvZFZvaWQ6IE5lLCBab2RBcnJheTogSiwgWm9kT2JqZWN0OiBOLCBab2RVbmlvbjogeWUsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogX3QsIFpvZEludGVyc2VjdGlvbjogZ2UsIFpvZFR1cGxlOiBVLCBab2RSZWNvcmQ6IHZ0LCBab2RNYXA6IExlLCBab2RTZXQ6IFBlLCBab2RGdW5jdGlvbjogeHQsIFpvZExhenk6IF9lLCBab2RMaXRlcmFsOiB2ZSwgWm9kRW51bTogeGUsIFpvZE5hdGl2ZUVudW06IHdlLCBab2RQcm9taXNlOiBpZSwgWm9kRWZmZWN0czogWiwgWm9kVHJhbnNmb3JtZXI6IFosIFpvZE9wdGlvbmFsOiB6LCBab2ROdWxsYWJsZTogJCwgWm9kRGVmYXVsdDogYmUsIFpvZENhdGNoOiBTZSwgWm9kTmFOOiBaZSwgQlJBTkQ6IGxzLCBab2RCcmFuZGVkOiBRZSwgWm9kUGlwZWxpbmU6IEtlLCBab2RSZWFkb25seToga2UsIGN1c3RvbTogQnIsIFNjaGVtYTogXywgWm9kU2NoZW1hOiBfLCBsYXRlOiBjcywgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCgpIHtcbiAgcmV0dXJuIG07XG59LCBjb2VyY2U6IFZzLCBhbnk6IF9zLCBhcnJheTogYnMsIGJpZ2ludDogaHMsIGJvb2xlYW46ICRyLCBkYXRlOiBwcywgZGlzY3JpbWluYXRlZFVuaW9uOiBPcywgZWZmZWN0OiBMciwgZW51bTogUHMsIGZ1bmN0aW9uOiBJcywgaW5zdGFuY2VvZjogZnMsIGludGVyc2VjdGlvbjogRXMsIGxhenk6IE5zLCBsaXRlcmFsOiBMcywgbWFwOiBScywgbmFuOiBkcywgbmF0aXZlRW51bTogWnMsIG5ldmVyOiB4cywgbnVsbDogZ3MsIG51bGxhYmxlOiBNcywgbnVtYmVyOiBVciwgb2JqZWN0OiBTcywgb2Jvb2xlYW46ICRzLCBvbnVtYmVyOiBVcywgb3B0aW9uYWw6IHpzLCBvc3RyaW5nOiBGcywgcGlwZWxpbmU6IEJzLCBwcmVwcm9jZXNzOiBEcywgcHJvbWlzZTogV3MsIHJlY29yZDogQ3MsIHNldDoganMsIHN0cmljdE9iamVjdDoga3MsIHN0cmluZzogRnIsIHN5bWJvbDogbXMsIHRyYW5zZm9ybWVyOiBMciwgdHVwbGU6IEFzLCB1bmRlZmluZWQ6IHlzLCB1bmlvbjogVHMsIHVua25vd246IHZzLCB2b2lkOiB3cywgTkVWRVI6IHFzLCBab2RJc3N1ZUNvZGU6IGMsIHF1b3RlbGVzc0pzb246IFZuLCBab2RFcnJvcjogUCB9KTtcbnZhciBWciA9IGIub2JqZWN0KHsgdXJsOiBiLnN0cmluZygpLCBhZGRyZXNzOiBiLnN0cmluZygpIH0pO1xudmFyIHFyID0gYi5vYmplY3QoeyB1cmw6IGIuc3RyaW5nKCksIGFkZHJlc3M6IGIuc3RyaW5nKCksIHR0bDogYi5jb2VyY2UubnVtYmVyKCkgfSk7XG52YXIgR3IgPSBiLmZ1bmN0aW9uKCkuYXJncyhiLnN0cmluZygpLCBiLnN0cmluZygpKS5yZXR1cm5zKGIucHJvbWlzZShiLnN0cmluZygpKSk7XG52YXIgSHIgPSBiLmZ1bmN0aW9uKCkuYXJncyhiLnN0cmluZygpKS5yZXR1cm5zKGIucHJvbWlzZShWci5udWxsaXNoKCkpKTtcbnZhciBYciA9IGIuZnVuY3Rpb24oKS5hcmdzKGIuc3RyaW5nKCksIFZyLCBiLm51bWJlcigpKS5yZXR1cm5zKGIucHJvbWlzZShiLmFueSgpKSk7XG52YXIgV2UgPSBiLmZ1bmN0aW9uKCkuYXJncyhiLnN0cmluZygpKS5yZXR1cm5zKGIucHJvbWlzZShxci5udWxsaXNoKCkpKTtcbnZhciB6ZSA9IGIuZnVuY3Rpb24oKS5hcmdzKGIuc3RyaW5nKCksIGIuc3RyaW5nKCksIGIubnVtYmVyKCkpLnJldHVybnMoYi5wcm9taXNlKGIuYW55KCkpKTtcbnZhciBUZSA9IGIuZnVuY3Rpb24oKS5hcmdzKGIuc3RyaW5nKCkpLnJldHVybnMoYi5wcm9taXNlKHFyKSk7XG52YXIgWXIgPSBUZTtcbmZ1bmN0aW9uIEpyKHsgbG9hZFByb2Nlc3NTY2hlZHVsZXI6IHIxOCwgbG9hZFNjaGVkdWxlcjogZSwgY2FjaGU6IHQsIGZvbGxvd1JlZGlyZWN0czogbiwgY2hlY2tGb3JSZWRpcmVjdDogcyB9KSB7XG4gIHIxOCA9IFlyLmltcGxlbWVudChyMTgpLCBlID0gVGUuaW1wbGVtZW50KGUpLCBzID0gR3IuaW1wbGVtZW50KHMpO1xuICBsZXQgYSA9IEhyLmltcGxlbWVudCh0LmdldEJ5UHJvY2VzcyksIGkgPSBXZS5pbXBsZW1lbnQodC5nZXRCeU93bmVyKSwgbyA9IFhyLmltcGxlbWVudCh0LnNldEJ5UHJvY2VzcyksIHUgPSB6ZS5pbXBsZW1lbnQodC5zZXRCeU93bmVyKTtcbiAgcmV0dXJuIChsLCBoKSA9PiBhKGwpLnRoZW4oYXN5bmMgKHYyKSA9PiB2MiB8fCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICBpZiAoaCkge1xuICAgICAgbGV0IFQzID0gYXdhaXQgaShoKTtcbiAgICAgIHJldHVybiBUMyB8fCBlKGgpLnRoZW4oKFMpID0+ICh1KFMuYWRkcmVzcywgUy51cmwsIFMudHRsKSwgUykpO1xuICAgIH1cbiAgICByZXR1cm4gcjE4KGwpO1xuICB9KS50aGVuKGFzeW5jIChUMykgPT4ge1xuICAgIGxldCBTID0gVDMudXJsO1xuICAgIG4gJiYgKFMgPSBhd2FpdCBzKFQzLnVybCwgbCkpO1xuICAgIGxldCBCMiA9IHsgdXJsOiBIZShTKSwgYWRkcmVzczogVDMuYWRkcmVzcyB9O1xuICAgIHJldHVybiBhd2FpdCBvKGwsIEIyLCBUMy50dGwpLCBCMjtcbiAgfSkpO1xufVxuZnVuY3Rpb24gUXIoeyBsb2FkU2NoZWR1bGVyOiByMTgsIGNhY2hlOiBlIH0pIHtcbiAgcjE4ID0gVGUuaW1wbGVtZW50KHIxOCk7XG4gIGxldCB0ID0gV2UuaW1wbGVtZW50KGUuZ2V0QnlPd25lciksIG4gPSB6ZS5pbXBsZW1lbnQoZS5zZXRCeU93bmVyKTtcbiAgcmV0dXJuIChzKSA9PiB0KHMpLnRoZW4oKGEpID0+IGEgPyB7IHVybDogYS51cmwgfSA6IHIxOChzKS50aGVuKChpKSA9PiBuKHMsIGkudXJsLCBpLnR0bCkudGhlbigoKSA9PiAoeyB1cmw6IEhlKGkudXJsKSB9KSkpLmNhdGNoKChpKSA9PiB7XG4gICAgaWYgKCEoaSBpbnN0YW5jZW9mIEgpKSB0aHJvdyBpO1xuICB9KSk7XG59XG5mdW5jdGlvbiBLcih7IGxvYWRTY2hlZHVsZXI6IHIxOCwgY2FjaGU6IGUgfSkge1xuICByMTggPSBUZS5pbXBsZW1lbnQocjE4KTtcbiAgbGV0IHQgPSBXZS5pbXBsZW1lbnQoZS5nZXRCeU93bmVyKSwgbiA9IHplLmltcGxlbWVudChlLnNldEJ5T3duZXIpO1xuICByZXR1cm4gKHMpID0+IHQocykudGhlbigoYSkgPT4gYSA/IHRydWUgOiByMTgocykudGhlbigoaSkgPT4gbihzLCBpLnVybCwgaS50dGwpKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKChpKSA9PiB7XG4gICAgaWYgKGkgaW5zdGFuY2VvZiBIKSByZXR1cm4gZmFsc2U7XG4gICAgdGhyb3cgaTtcbiAgfSkpO1xufVxudmFyIEdzID0gMTAwO1xudmFyIEhzID0gXCJodHRwczovL2Fyd2VhdmUubmV0L2dyYXBocWxcIjtcbnZhciBYcyA9IDA7XG52YXIgWXMgPSAzMDA7XG52YXIgSnMgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuKHsgY2FjaGVTaXplOiByMTggPSBHcywgZm9sbG93UmVkaXJlY3RzOiBlID0gSnMsIEdSQVBIUUxfVVJMOiB0ID0gSHMsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IG4gPSBYcywgR1JBUEhRTF9SRVRSWV9CQUNLT0ZGOiBzID0gWXMgfSA9IHt9KSB7XG4gIGxldCBhID0gRXIoeyBzaXplOiByMTggfSksIGkgPSBGdCh7IGZldGNoLCBHUkFQSFFMX1VSTDogdCwgR1JBUEhRTF9NQVhfUkVUUklFUzogbiwgR1JBUEhRTF9SRVRSWV9CQUNLT0ZGOiBzIH0pLCBvID0geyBnZXRCeVByb2Nlc3M6IEFyKHsgY2FjaGU6IGEgfSksIGdldEJ5T3duZXI6IFJyKHsgY2FjaGU6IGEgfSksIHNldEJ5UHJvY2VzczogQ3IoeyBjYWNoZTogYSB9KSwgc2V0QnlPd25lcjoganIoeyBjYWNoZTogYSB9KSB9LCB1ID0gSnIoeyBsb2FkUHJvY2Vzc1NjaGVkdWxlcjogYnIoeyBmZXRjaCwgR1JBUEhRTF9VUkw6IHQsIEdSQVBIUUxfTUFYX1JFVFJJRVM6IG4sIEdSQVBIUUxfUkVUUllfQkFDS09GRjogcyB9KSwgbG9hZFNjaGVkdWxlcjogaSwgY2FjaGU6IG8sIGZvbGxvd1JlZGlyZWN0czogZSwgY2hlY2tGb3JSZWRpcmVjdDogSXIoeyBmZXRjaCB9KSB9KSwgbCA9IEtyKHsgbG9hZFNjaGVkdWxlcjogaSwgY2FjaGU6IG8gfSksIGggPSBRcih7IGxvYWRTY2hlZHVsZXI6IGksIGNhY2hlOiBvIH0pO1xuICByZXR1cm4geyBsb2NhdGU6IHUsIHZhbGlkYXRlOiBsLCByYXc6IGggfTtcbn1cbnZhciBRcyA9IGdsb2JhbFRoaXMuR1JBUEhRTF9VUkwgfHwgdm9pZCAwO1xudmFyIEtzID0gZ2xvYmFsVGhpcy5TQ0hFRFVMRVJfVVRJTFNfQ0FDSEVfU0laRSB8fCB2b2lkIDA7XG52YXIgZWEgPSBnbG9iYWxUaGlzLlNDSEVEVUxFUl9VVElMU19GT0xMT1dfUkVESVJFQ1RTID09PSBcInRydWVcIiB8fCB2b2lkIDA7XG52YXIgdGEgPSBnbG9iYWxUaGlzLkdSQVBIUUxfTUFYX1JFVFJJRVMgfHwgdm9pZCAwO1xudmFyIHJhID0gZ2xvYmFsVGhpcy5HUkFQSFFMX1JFVFJZX0JBQ0tPRkYgfHwgdm9pZCAwO1xudmFyIHsgbG9jYXRlOiBlbCwgdmFsaWRhdGU6IHRsLCByYXc6IHJsIH0gPSBlbih7IEdSQVBIUUxfVVJMOiBRcywgY2FjaGVTaXplOiBLcywgZm9sbG93UmVkaXJlY3RzOiBlYSwgR1JBUEhRTF9NQVhfUkVUUklFUzogdGEsIEdSQVBIUUxfUkVUUllfQkFDS09GRjogcmEgfSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9oeXBlci1hc3luYy9kaXN0L2luZGV4LmpzXG52YXIgQXN5bmMgPSAoZm9yaykgPT4gKHtcbiAgZm9yayxcbiAgdG9Qcm9taXNlOiAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0MykgPT4gZm9yayhyZWplY3QzLCByZXNvbHZlKSksXG4gIG1hcDogKGZuMikgPT4gQXN5bmMoKHJlaiwgcmVzKSA9PiBmb3JrKHJlaiwgKHgzKSA9PiByZXMoZm4yKHgzKSkpKSxcbiAgYmltYXA6IChmMiwgZzIpID0+IEFzeW5jKFxuICAgIChyZWosIHJlcykgPT4gZm9yayhcbiAgICAgICh4MykgPT4gcmVqKGYyKHgzKSksXG4gICAgICAoeDMpID0+IHJlcyhnMih4MykpXG4gICAgKVxuICApLFxuICBjaGFpbjogKGZuMikgPT4gQXN5bmMoKHJlaiwgcmVzKSA9PiBmb3JrKHJlaiwgKHgzKSA9PiBmbjIoeDMpLmZvcmsocmVqLCByZXMpKSksXG4gIGJpY2hhaW46IChmMiwgZzIpID0+IEFzeW5jKFxuICAgIChyZWosIHJlcykgPT4gZm9yayhcbiAgICAgICh4MykgPT4gZjIoeDMpLmZvcmsocmVqLCByZXMpLFxuICAgICAgKHgzKSA9PiBnMih4MykuZm9yayhyZWosIHJlcylcbiAgICApXG4gICksXG4gIGZvbGQ6IChmMiwgZzIpID0+IEFzeW5jKFxuICAgIChyZWosIHJlcykgPT4gZm9yayhcbiAgICAgICh4MykgPT4gZjIoeDMpLmZvcmsocmVqLCByZXMpLFxuICAgICAgKHgzKSA9PiBnMih4MykuZm9yayhyZWosIHJlcylcbiAgICApXG4gIClcbn0pO1xudmFyIG9mID0gKHgzKSA9PiBBc3luYygocmVqLCByZXMpID0+IHJlcyh4MykpO1xudmFyIFJlc29sdmVkID0gKHgzKSA9PiBBc3luYygocmVqLCByZXMpID0+IHJlcyh4MykpO1xudmFyIFJlamVjdGVkID0gKHgzKSA9PiBBc3luYygocmVqLCByZXMpID0+IHJlaih4MykpO1xudmFyIGZyb21Qcm9taXNlID0gKGYyKSA9PiAoLi4uYXJncykgPT4gQXN5bmMoXG4gIChyZWosIHJlcykgPT4gZjIoLi4uYXJncykudGhlbihyZXMpLmNhdGNoKHJlailcbik7XG5cbi8vIHNyYy9jbGllbnQvYW8tbXUuanNcbmZ1bmN0aW9uIGRlcGxveU1lc3NhZ2VXaXRoKHsgZmV0Y2g6IGZldGNoMiwgTVVfVVJMOiBNVV9VUkwyLCBsb2dnZXI6IF9sb2dnZXIgfSkge1xuICBjb25zdCBsb2dnZXIgPSBfbG9nZ2VyLmNoaWxkKFwiZGVwbG95TWVzc2FnZVwiKTtcbiAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG9mKGFyZ3MpLmNoYWluKFxuICAgICAgZnJvbVByb21pc2UoKHsgcHJvY2Vzc0lkLCBkYXRhLCB0YWdzLCBhbmNob3IsIHNpZ25lciB9KSA9PiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcHJvY2Vzc0lkIGlzIHRoZSB0YXJnZXQgc2V0IG9uIHRoZSBkYXRhIGl0ZW1cbiAgICAgICAgICogU2VlIGh0dHBzOi8vc3BlY3MuZzh3YXkuaW8vP3R4PXh3T2dYLU1tcU41Xy1OeV96TnUyQThvLVBuVEdzb1JiXzNGcnRpTUFrdXdcbiAgICAgICAgICovXG4gICAgICAgIHNpZ25lcih7IGRhdGEsIHRhZ3MsIHRhcmdldDogcHJvY2Vzc0lkLCBhbmNob3IgfSlcbiAgICAgICkpXG4gICAgKS5jaGFpbihcbiAgICAgIChzaWduZWREYXRhSXRlbSkgPT4gb2Yoc2lnbmVkRGF0YUl0ZW0pLmNoYWluKGZyb21Qcm9taXNlKFxuICAgICAgICBhc3luYyAoc2lnbmVkRGF0YUl0ZW0yKSA9PiBmZXRjaDIoXG4gICAgICAgICAgTVVfVVJMMixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgICAgICBib2R5OiBzaWduZWREYXRhSXRlbTIucmF3XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApKS5iaWNoYWluKFxuICAgICAgICAoZXJyKSA9PiBSZWplY3RlZChuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBNVTogJHtKU09OLnN0cmluZ2lmeShlcnIpfWApKSxcbiAgICAgICAgZnJvbVByb21pc2UoXG4gICAgICAgICAgYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c306ICR7YXdhaXQgcmVzLnRleHQoKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICkuYmltYXAoXG4gICAgICAgIGxvZ2dlci50YXAoXCJFcnJvciBlbmNvdW50ZXJlZCB3aGVuIHdyaXRpbmcgbWVzc2FnZSB2aWEgTVVcIiksXG4gICAgICAgIGxvZ2dlci50YXAoXCJTdWNjZXNzZnVsbHkgd3JvdGUgbWVzc2FnZSB2aWEgTVVcIilcbiAgICAgICkubWFwKChyZXMpID0+ICh7IHJlcywgbWVzc2FnZUlkOiBzaWduZWREYXRhSXRlbS5pZCB9KSlcbiAgICApLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuZnVuY3Rpb24gZGVwbG95UHJvY2Vzc1dpdGgoeyBmZXRjaDogZmV0Y2gyLCBNVV9VUkw6IE1VX1VSTDIsIGxvZ2dlcjogX2xvZ2dlciB9KSB7XG4gIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIuY2hpbGQoXCJkZXBsb3lQcm9jZXNzXCIpO1xuICByZXR1cm4gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gb2YoYXJncykuY2hhaW4oZnJvbVByb21pc2UoKHsgZGF0YSwgdGFncywgc2lnbmVyIH0pID0+IHNpZ25lcih7IGRhdGEsIHRhZ3MgfSkpKS5jaGFpbihcbiAgICAgIChzaWduZWREYXRhSXRlbSkgPT4gb2Yoc2lnbmVkRGF0YUl0ZW0pLmNoYWluKGZyb21Qcm9taXNlKFxuICAgICAgICBhc3luYyAoc2lnbmVkRGF0YUl0ZW0yKSA9PiBmZXRjaDIoXG4gICAgICAgICAgTVVfVVJMMixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgICAgICBib2R5OiBzaWduZWREYXRhSXRlbTIucmF3XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApKS5iaWNoYWluKFxuICAgICAgICAoZXJyKSA9PiBSZWplY3RlZChuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBNVTogJHtKU09OLnN0cmluZ2lmeShlcnIpfWApKSxcbiAgICAgICAgZnJvbVByb21pc2UoXG4gICAgICAgICAgYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c306ICR7YXdhaXQgcmVzLnRleHQoKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICkuYmltYXAoXG4gICAgICAgIGxvZ2dlci50YXAoXCJFcnJvciBlbmNvdW50ZXJlZCB3aGVuIGRlcGxveWluZyBwcm9jZXNzIHZpYSBNVVwiKSxcbiAgICAgICAgbG9nZ2VyLnRhcChcIlN1Y2Nlc3NmdWxseSBkZXBsb3llZCBwcm9jZXNzIHZpYSBNVVwiKVxuICAgICAgKS5tYXAoKHJlcykgPT4gKHsgcmVzLCBwcm9jZXNzSWQ6IHNpZ25lZERhdGFJdGVtLmlkIH0pKVxuICAgICkudG9Qcm9taXNlKCk7XG4gIH07XG59XG5mdW5jdGlvbiBkZXBsb3lNb25pdG9yV2l0aCh7IGZldGNoOiBmZXRjaDIsIE1VX1VSTDogTVVfVVJMMiwgbG9nZ2VyOiBfbG9nZ2VyIH0pIHtcbiAgY29uc3QgbG9nZ2VyID0gX2xvZ2dlci5jaGlsZChcImRlcGxveU1vbml0b3JcIik7XG4gIHJldHVybiAoYXJncykgPT4gb2YoYXJncykuY2hhaW4oXG4gICAgZnJvbVByb21pc2UoKHsgcHJvY2Vzc0lkLCBkYXRhLCB0YWdzLCBhbmNob3IsIHNpZ25lciB9KSA9PiAoXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwcm9jZXNzSWQgaXMgdGhlIHRhcmdldCBzZXQgb24gdGhlIGRhdGEgaXRlbVxuICAgICAgICovXG4gICAgICBzaWduZXIoeyBkYXRhLCB0YWdzLCB0YXJnZXQ6IHByb2Nlc3NJZCwgYW5jaG9yIH0pXG4gICAgKSlcbiAgKS5jaGFpbihcbiAgICAoc2lnbmVkRGF0YUl0ZW0pID0+IG9mKHNpZ25lZERhdGFJdGVtKS5jaGFpbihmcm9tUHJvbWlzZShcbiAgICAgIGFzeW5jIChzaWduZWREYXRhSXRlbTIpID0+IGZldGNoMihcbiAgICAgICAgTVVfVVJMMiArIFwiL21vbml0b3IvXCIgKyBhcmdzLnByb2Nlc3NJZCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgICAgIGJvZHk6IHNpZ25lZERhdGFJdGVtMi5yYXdcbiAgICAgICAgfVxuICAgICAgKVxuICAgICkpLmJpY2hhaW4oXG4gICAgICAoZXJyKSA9PiBSZWplY3RlZChuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBNVTogJHtKU09OLnN0cmluZ2lmeShlcnIpfWApKSxcbiAgICAgIGZyb21Qcm9taXNlKFxuICAgICAgICBhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHsgb2s6IHRydWUgfTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c306ICR7YXdhaXQgcmVzLnRleHQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICkuYmltYXAoXG4gICAgICBsb2dnZXIudGFwKFwiRXJyb3IgZW5jb3VudGVyZWQgd2hlbiBzdWJzY3JpYmluZyB0byBwcm9jZXNzIHZpYSBNVVwiKSxcbiAgICAgIGxvZ2dlci50YXAoXCJTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCB0byBwcm9jZXNzIHZpYSBNVVwiKVxuICAgICkubWFwKChyZXMpID0+ICh7IHJlcywgbWVzc2FnZUlkOiBzaWduZWREYXRhSXRlbS5pZCB9KSlcbiAgKS50b1Byb21pc2UoKTtcbn1cbmZ1bmN0aW9uIGRlcGxveVVubW9uaXRvcldpdGgoeyBmZXRjaDogZmV0Y2gyLCBNVV9VUkw6IE1VX1VSTDIsIGxvZ2dlcjogX2xvZ2dlciB9KSB7XG4gIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIuY2hpbGQoXCJkZXBsb3lVbm1vbml0b3JcIik7XG4gIHJldHVybiAoYXJncykgPT4gb2YoYXJncykuY2hhaW4oXG4gICAgZnJvbVByb21pc2UoKHsgcHJvY2Vzc0lkLCBkYXRhLCB0YWdzLCBhbmNob3IsIHNpZ25lciB9KSA9PiAoXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBwcm9jZXNzSWQgaXMgdGhlIHRhcmdldCBzZXQgb24gdGhlIGRhdGEgaXRlbVxuICAgICAgICovXG4gICAgICBzaWduZXIoeyBkYXRhLCB0YWdzLCB0YXJnZXQ6IHByb2Nlc3NJZCwgYW5jaG9yIH0pXG4gICAgKSlcbiAgKS5jaGFpbihcbiAgICAoc2lnbmVkRGF0YUl0ZW0pID0+IG9mKHNpZ25lZERhdGFJdGVtKS5jaGFpbihmcm9tUHJvbWlzZShcbiAgICAgIGFzeW5jIChzaWduZWREYXRhSXRlbTIpID0+IGZldGNoMihcbiAgICAgICAgTVVfVVJMMiArIFwiL21vbml0b3IvXCIgKyBhcmdzLnByb2Nlc3NJZCxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgICAgYm9keTogc2lnbmVkRGF0YUl0ZW0yLnJhd1xuICAgICAgICB9XG4gICAgICApXG4gICAgKSkuYmljaGFpbihcbiAgICAgIChlcnIpID0+IFJlamVjdGVkKG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIE1VOiAke0pTT04uc3RyaW5naWZ5KGVycil9YCkpLFxuICAgICAgZnJvbVByb21pc2UoXG4gICAgICAgIGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICBpZiAocmVzLm9rKSByZXR1cm4geyBvazogdHJ1ZSB9O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfTogJHthd2FpdCByZXMudGV4dCgpfWApO1xuICAgICAgICB9XG4gICAgICApXG4gICAgKS5iaW1hcChcbiAgICAgIGxvZ2dlci50YXAoXCJFcnJvciBlbmNvdW50ZXJlZCB3aGVuIHVuc3Vic2NyaWJpbmcgdG8gcHJvY2VzcyB2aWEgTVVcIiksXG4gICAgICBsb2dnZXIudGFwKFwiU3VjY2Vzc2Z1bGx5IHVuc3Vic2NyaWJlZCB0byBwcm9jZXNzIHZpYSBNVVwiKVxuICAgICkubWFwKChyZXMpID0+ICh7IHJlcywgbWVzc2FnZUlkOiBzaWduZWREYXRhSXRlbS5pZCB9KSlcbiAgKS50b1Byb21pc2UoKTtcbn1cbmZ1bmN0aW9uIGRlcGxveUFzc2lnbldpdGgoeyBmZXRjaDogZmV0Y2gyLCBNVV9VUkw6IE1VX1VSTDIsIGxvZ2dlcjogX2xvZ2dlciB9KSB7XG4gIGNvbnN0IGxvZ2dlciA9IF9sb2dnZXIuY2hpbGQoXCJkZXBsb3lBc3NpZ25cIik7XG4gIHJldHVybiAoYXJncykgPT4ge1xuICAgIHJldHVybiBvZihhcmdzKS5jaGFpbihmcm9tUHJvbWlzZShcbiAgICAgIGFzeW5jICh7IHByb2Nlc3M6IHByb2Nlc3MyLCBtZXNzYWdlOiBtZXNzYWdlMiwgYmFzZUxheWVyLCBleGNsdWRlIH0pID0+IGZldGNoMihcbiAgICAgICAgYCR7TVVfVVJMMn0/cHJvY2Vzcy1pZD0ke3Byb2Nlc3MyfSZhc3NpZ249JHttZXNzYWdlMn0ke2Jhc2VMYXllciA/IFwiJmJhc2UtbGF5ZXJcIiA6IFwiXCJ9JHtleGNsdWRlID8gXCImZXhjbHVkZT1cIiArIGV4Y2x1ZGUuam9pbihcIixcIikgOiBcIlwifWAsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKSkuYmljaGFpbihcbiAgICAgIChlcnIpID0+IFJlamVjdGVkKG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIE1VOiAke0pTT04uc3RyaW5naWZ5KGVycil9YCkpLFxuICAgICAgZnJvbVByb21pc2UoXG4gICAgICAgIGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICBpZiAocmVzLm9rKSByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c306ICR7YXdhaXQgcmVzLnRleHQoKX1gKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICkuYmltYXAoXG4gICAgICBsb2dnZXIudGFwKFwiRXJyb3IgZW5jb3VudGVyZWQgd2hlbiB3cml0aW5nIGFzc2lnbm1lbnQgdmlhIE1VXCIpLFxuICAgICAgbG9nZ2VyLnRhcChcIlN1Y2Nlc3NmdWxseSB3cm90ZSBhc3NpZ25tZW50IHZpYSBNVVwiKVxuICAgICkubWFwKChyZXMpID0+ICh7IHJlcywgYXNzaWdubWVudElkOiByZXMuaWQgfSkpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvY2xpZW50L2FvLWN1LmpzXG5mdW5jdGlvbiBkcnlydW5GZXRjaFdpdGgoeyBmZXRjaDogZmV0Y2gyLCBDVV9VUkw6IENVX1VSTDIsIGxvZ2dlciB9KSB7XG4gIHJldHVybiAobXNnKSA9PiBvZihtc2cpLm1hcChsb2dnZXIudGFwKFwicG9zdGluZyBkcnlydW4gcmVxdWVzdCB0byBDVVwiKSkuY2hhaW4oZnJvbVByb21pc2UoKG1zZzIpID0+IGZldGNoMihgJHtDVV9VUkwyfS9kcnktcnVuP3Byb2Nlc3MtaWQ9JHttc2cyLlRhcmdldH1gLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkobXNnMilcbiAgfSkudGhlbigocmVzKSA9PiByZXMuanNvbigpKSkpLnRvUHJvbWlzZSgpO1xufVxuZnVuY3Rpb24gbG9hZFJlc3VsdFdpdGgoeyBmZXRjaDogZmV0Y2gyLCBDVV9VUkw6IENVX1VSTDIsIGxvZ2dlciB9KSB7XG4gIHJldHVybiAoeyBpZCwgcHJvY2Vzc0lkIH0pID0+IHtcbiAgICByZXR1cm4gb2YoYCR7Q1VfVVJMMn0vcmVzdWx0LyR7aWR9P3Byb2Nlc3MtaWQ9JHtwcm9jZXNzSWR9YCkubWFwKGxvZ2dlci50YXAoXCJmZXRjaGluZyBtZXNzYWdlIHJlc3VsdCBmcm9tIENVXCIpKS5jaGFpbihmcm9tUHJvbWlzZShcbiAgICAgIGFzeW5jICh1cmwpID0+IGZldGNoMih1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICAgICAgfSkudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICkpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuZnVuY3Rpb24gcXVlcnlSZXN1bHRzV2l0aCh7IGZldGNoOiBmZXRjaDIsIENVX1VSTDogQ1VfVVJMMiwgbG9nZ2VyIH0pIHtcbiAgcmV0dXJuICh7IHByb2Nlc3M6IHByb2Nlc3MyLCBmcm9tLCB0bywgc29ydCwgbGltaXQgfSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IG5ldyBVUkwoYCR7Q1VfVVJMMn0vcmVzdWx0cy8ke3Byb2Nlc3MyfWApO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModGFyZ2V0LnNlYXJjaCk7XG4gICAgaWYgKGZyb20pIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJmcm9tXCIsIGZyb20pO1xuICAgIH1cbiAgICBpZiAodG8pIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoXCJ0b1wiLCB0byk7XG4gICAgfVxuICAgIGlmIChzb3J0KSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKFwic29ydFwiLCBzb3J0KTtcbiAgICB9XG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgbGltaXQpO1xuICAgIH1cbiAgICB0YXJnZXQuc2VhcmNoID0gcGFyYW1zO1xuICAgIHJldHVybiBvZih0YXJnZXQudG9TdHJpbmcoKSkubWFwKGxvZ2dlci50YXAoXCJmZXRjaGluZyBtZXNzYWdlIHJlc3VsdCBmcm9tIENVXCIpKS5jaGFpbihmcm9tUHJvbWlzZShcbiAgICAgIGFzeW5jICh1cmwpID0+IGZldGNoMih1cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9LFxuICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICAgICAgfSkudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICkpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvY2xpZW50L2FvLXN1LmpzXG52YXIgaW1wb3J0X2xydV9tYXAgPSBfX3RvRVNNKHJlcXVpcmVfbHJ1X21hcCgpLCAxKTtcbnZhciBwcm9jZXNzTWV0YUNhY2hlO1xudmFyIGNyZWF0ZVByb2Nlc3NNZXRhQ2FjaGUgPSAoeyBNQVhfU0laRSB9KSA9PiB7XG4gIGlmIChwcm9jZXNzTWV0YUNhY2hlKSByZXR1cm4gcHJvY2Vzc01ldGFDYWNoZTtcbiAgcHJvY2Vzc01ldGFDYWNoZSA9IG5ldyBpbXBvcnRfbHJ1X21hcC5kZWZhdWx0KE1BWF9TSVpFKTtcbiAgcmV0dXJuIHByb2Nlc3NNZXRhQ2FjaGU7XG59O1xudmFyIGxvYWRQcm9jZXNzTWV0YVdpdGggPSAoeyBsb2dnZXIsIGZldGNoOiBmZXRjaDIsIGNhY2hlID0gcHJvY2Vzc01ldGFDYWNoZSB9KSA9PiB7XG4gIHJldHVybiBhc3luYyAoeyBzdVVybCwgcHJvY2Vzc0lkIH0pID0+IHtcbiAgICBpZiAoY2FjaGUuaGFzKHByb2Nlc3NJZCkpIHJldHVybiBjYWNoZS5nZXQocHJvY2Vzc0lkKTtcbiAgICByZXR1cm4gZmV0Y2gyKGAke3N1VXJsfS9wcm9jZXNzZXMvJHtwcm9jZXNzSWR9YCwgeyBtZXRob2Q6IFwiR0VUXCIsIHJlZGlyZWN0OiBcImZvbGxvd1wiIH0pLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgaWYgKHJlcy5vaykgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICBsb2dnZXIoXCJFcnJvciBFbmNvdW50ZXJlZCB3aGVuIGZldGNoaW5nIHByb2Nlc3MgbWV0YSBmcm9tIFNVICclcycgZm9yIHByb2Nlc3MgJyVzJ1wiLCBzdVVybCwgcHJvY2Vzc0lkKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW5jb3VudGVyZWQgRXJyb3IgZmV0Y2hpbmcgc2NoZWR1bGVkIG1lc3NhZ2VzIGZyb20gU2NoZWR1bGVyIFVuaXQ6ICR7cmVzLnN0YXR1c306ICR7YXdhaXQgcmVzLnRleHQoKX1gKTtcbiAgICB9KS50aGVuKChtZXRhKSA9PiB7XG4gICAgICBsb2dnZXIoXCJDYWNoaW5nIHByb2Nlc3MgbWV0YSBmb3IgcHJvY2VzcyAnJXMnXCIsIHByb2Nlc3NJZCk7XG4gICAgICBjYWNoZS5zZXQocHJvY2Vzc0lkLCB7IHRhZ3M6IG1ldGEudGFncyB9KTtcbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH0pO1xuICB9O1xufTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL0YuanNcbnZhciBGMiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIEZfZGVmYXVsdCA9IEYyO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvVC5qc1xudmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIFRfZGVmYXVsdCA9IFQ7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9fXy5qc1xudmFyIF9fZGVmYXVsdCA9IHtcbiAgXCJAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXJcIjogdHJ1ZVxufTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1BsYWNlaG9sZGVyLmpzXG5mdW5jdGlvbiBfaXNQbGFjZWhvbGRlcihhKSB7XG4gIHJldHVybiBhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiYgYVtcIkBAZnVuY3Rpb25hbC9wbGFjZWhvbGRlclwiXSA9PT0gdHJ1ZTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jdXJyeTEuanNcbmZ1bmN0aW9uIF9jdXJyeTEoZm4yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jdXJyeTIuanNcbmZ1bmN0aW9uIF9jdXJyeTIoZm4yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMihhLCBiMikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjI7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYyIDogX2N1cnJ5MShmdW5jdGlvbihfYikge1xuICAgICAgICAgIHJldHVybiBmbjIoYSwgX2IpO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiMikgPyBmMiA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbihfYSkge1xuICAgICAgICAgIHJldHVybiBmbjIoX2EsIGIyKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiMikgPyBfY3VycnkxKGZ1bmN0aW9uKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuMihhLCBfYik7XG4gICAgICAgIH0pIDogZm4yKGEsIGIyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY29uY2F0LmpzXG5mdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgc2V0MSA9IHNldDEgfHwgW107XG4gIHNldDIgPSBzZXQyIHx8IFtdO1xuICB2YXIgaWR4O1xuICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICB2YXIgcmVzdWx0MiA9IFtdO1xuICBpZHggPSAwO1xuICB3aGlsZSAoaWR4IDwgbGVuMSkge1xuICAgIHJlc3VsdDJbcmVzdWx0Mi5sZW5ndGhdID0gc2V0MVtpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsZW4yKSB7XG4gICAgcmVzdWx0MltyZXN1bHQyLmxlbmd0aF0gPSBzZXQyW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDI7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fYXJpdHkuanNcbmZ1bmN0aW9uIF9hcml0eShuLCBmbjIpIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCkge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCwgYTEpIHtcbiAgICAgICAgcmV0dXJuIGZuMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMikge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICAgICAgcmV0dXJuIGZuMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICAgICAgcmV0dXJuIGZuMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgcmV0dXJuIGZuMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuXCIpO1xuICB9XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnlOLmpzXG5mdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuMikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgdmFyIGFyZ3NJZHggPSAwO1xuICAgIHZhciBsZWZ0ID0gbGVuZ3RoO1xuICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgdmFyIGhhc1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gICAgd2hpbGUgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoIHx8IGFyZ3NJZHggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0MjtcbiAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJiAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHwgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICByZXN1bHQyID0gcmVjZWl2ZWRbY29tYmluZWRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0MiA9IGFyZ3VtZW50c1thcmdzSWR4XTtcbiAgICAgICAgYXJnc0lkeCArPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRbY29tYmluZWRJZHhdID0gcmVzdWx0MjtcbiAgICAgIGlmICghX2lzUGxhY2Vob2xkZXIocmVzdWx0MikpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuICFoYXNQbGFjZWhvbGRlciAmJiBsZWZ0IDw9IDAgPyBmbjIuYXBwbHkodGhpcywgY29tYmluZWQpIDogX2FyaXR5KE1hdGgubWF4KDAsIGxlZnQpLCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuMikpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvY3VycnlOLmpzXG52YXIgY3VycnlOID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoZnVuY3Rpb24gY3VycnlOMihsZW5ndGgsIGZuMikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4yKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbjIpKTtcbn0pO1xudmFyIGN1cnJ5Tl9kZWZhdWx0ID0gY3VycnlOO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2N1cnJ5My5qc1xuZnVuY3Rpb24gX2N1cnJ5MyhmbjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYzKGEsIGIyLCBjMikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYzIDogX2N1cnJ5MihmdW5jdGlvbihfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4yKGEsIF9iLCBfYyk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYjIpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuMihfYSwgYjIsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiMikgPyBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbjIoYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uKF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuMihhLCBiMiwgX2MpO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiMikgJiYgX2lzUGxhY2Vob2xkZXIoYzIpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiMikgPyBfY3VycnkyKGZ1bmN0aW9uKF9hLCBfYikge1xuICAgICAgICAgIHJldHVybiBmbjIoX2EsIF9iLCBjMik7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYzIpID8gX2N1cnJ5MihmdW5jdGlvbihfYSwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4yKF9hLCBiMiwgX2MpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIyKSAmJiBfaXNQbGFjZWhvbGRlcihjMikgPyBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbjIoYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgICByZXR1cm4gZm4yKF9hLCBiMiwgYzIpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIyKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4yKGEsIF9iLCBjMik7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYzIpID8gX2N1cnJ5MShmdW5jdGlvbihfYykge1xuICAgICAgICAgIHJldHVybiBmbjIoYSwgYjIsIF9jKTtcbiAgICAgICAgfSkgOiBmbjIoYSwgYjIsIGMyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheS5qc1xudmFyIGlzQXJyYXlfZGVmYXVsdCA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNUcmFuc2Zvcm1lci5qc1xuZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcbmZ1bmN0aW9uIF9kaXNwYXRjaGFibGUobWV0aG9kTmFtZXMsIHRyYW5zZHVjZXJDcmVhdG9yLCBmbjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4yKCk7XG4gICAgfVxuICAgIHZhciBvYmogPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghaXNBcnJheV9kZWZhdWx0KG9iaikpIHtcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgd2hpbGUgKGlkeCA8IG1ldGhvZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIG9ialttZXRob2ROYW1lc1tpZHhdXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialttZXRob2ROYW1lc1tpZHhdXS5hcHBseShvYmosIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZHggKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgIHZhciB0cmFuc2R1Y2VyID0gdHJhbnNkdWNlckNyZWF0b3IuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSkpO1xuICAgICAgICByZXR1cm4gdHJhbnNkdWNlcihvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZCYXNlLmpzXG52YXIgeGZCYXNlX2RlZmF1bHQgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnhmW1wiQEB0cmFuc2R1Y2VyL2luaXRcIl0oKTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbihyZXN1bHQyKSB7XG4gICAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdKHJlc3VsdDIpO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzXG5mdW5jdGlvbiBfYXJyYXlGcm9tSXRlcmF0b3IoaXRlcikge1xuICB2YXIgbGlzdCA9IFtdO1xuICB2YXIgbmV4dDtcbiAgd2hpbGUgKCEobmV4dCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgbGlzdC5wdXNoKG5leHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2luY2x1ZGVzV2l0aC5qc1xuZnVuY3Rpb24gX2luY2x1ZGVzV2l0aChwcmVkLCB4MywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKHByZWQoeDMsIGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZnVuY3Rpb25OYW1lLmpzXG5mdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYyKSB7XG4gIHZhciBtYXRjaCA9IFN0cmluZyhmMikubWF0Y2goL15mdW5jdGlvbiAoXFx3KikvKTtcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBcIlwiIDogbWF0Y2hbMV07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faGFzLmpzXG5mdW5jdGlvbiBfaGFzKHByb3AzLCBvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3AzKTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19vYmplY3RJcy5qc1xuZnVuY3Rpb24gX29iamVjdElzKGEsIGIyKSB7XG4gIGlmIChhID09PSBiMikge1xuICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYjIgIT09IGIyO1xuICB9XG59XG52YXIgb2JqZWN0SXNfZGVmYXVsdCA9IHR5cGVvZiBPYmplY3QuaXMgPT09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IF9vYmplY3RJcztcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc0FyZ3VtZW50cy5qc1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBfaXNBcmd1bWVudHMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIgPyBmdW5jdGlvbiBfaXNBcmd1bWVudHMyKHgzKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoeDMpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiO1xuICB9IDogZnVuY3Rpb24gX2lzQXJndW1lbnRzMih4Mykge1xuICAgIHJldHVybiBfaGFzKFwiY2FsbGVlXCIsIHgzKTtcbiAgfTtcbn0oKTtcbnZhciBpc0FyZ3VtZW50c19kZWZhdWx0ID0gX2lzQXJndW1lbnRzO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMva2V5cy5qc1xudmFyIGhhc0VudW1CdWcgPSAhLyogQF9fUFVSRV9fICovIHtcbiAgdG9TdHJpbmc6IG51bGxcbn0ucHJvcGVydHlJc0VudW1lcmFibGUoXCJ0b1N0cmluZ1wiKTtcbnZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbXCJjb25zdHJ1Y3RvclwiLCBcInZhbHVlT2ZcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImhhc093blByb3BlcnR5XCIsIFwidG9Mb2NhbGVTdHJpbmdcIl07XG52YXIgaGFzQXJnc0VudW1CdWcgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwibGVuZ3RoXCIpO1xufSgpO1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMyKGxpc3QsIGl0ZW0pIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChsaXN0W2lkeF0gPT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAmJiAhaGFzQXJnc0VudW1CdWcgPyAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MShmdW5jdGlvbiBrZXlzMihvYmopIHtcbiAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG59KSA6IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkxKGZ1bmN0aW9uIGtleXMzKG9iaikge1xuICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgcHJvcDMsIG5JZHg7XG4gIHZhciBrczIgPSBbXTtcbiAgdmFyIGNoZWNrQXJnc0xlbmd0aCA9IGhhc0FyZ3NFbnVtQnVnICYmIGlzQXJndW1lbnRzX2RlZmF1bHQob2JqKTtcbiAgZm9yIChwcm9wMyBpbiBvYmopIHtcbiAgICBpZiAoX2hhcyhwcm9wMywgb2JqKSAmJiAoIWNoZWNrQXJnc0xlbmd0aCB8fCBwcm9wMyAhPT0gXCJsZW5ndGhcIikpIHtcbiAgICAgIGtzMltrczIubGVuZ3RoXSA9IHByb3AzO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzRW51bUJ1Zykge1xuICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobklkeCA+PSAwKSB7XG4gICAgICBwcm9wMyA9IG5vbkVudW1lcmFibGVQcm9wc1tuSWR4XTtcbiAgICAgIGlmIChfaGFzKHByb3AzLCBvYmopICYmICFjb250YWlucyhrczIsIHByb3AzKSkge1xuICAgICAgICBrczJba3MyLmxlbmd0aF0gPSBwcm9wMztcbiAgICAgIH1cbiAgICAgIG5JZHggLT0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtzMjtcbn0pO1xudmFyIGtleXNfZGVmYXVsdCA9IGtleXM7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy90eXBlLmpzXG52YXIgdHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkxKGZ1bmN0aW9uIHR5cGUyKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsID8gXCJOdWxsXCIgOiB2YWwgPT09IHZvaWQgMCA/IFwiVW5kZWZpbmVkXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59KTtcbnZhciB0eXBlX2RlZmF1bHQgPSB0eXBlO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2VxdWFscy5qc1xuZnVuY3Rpb24gX3VuaXFDb250ZW50RXF1YWxzKGFJdGVyYXRvciwgYkl0ZXJhdG9yLCBzdGFja0EsIHN0YWNrQikge1xuICB2YXIgYSA9IF9hcnJheUZyb21JdGVyYXRvcihhSXRlcmF0b3IpO1xuICB2YXIgYjIgPSBfYXJyYXlGcm9tSXRlcmF0b3IoYkl0ZXJhdG9yKTtcbiAgZnVuY3Rpb24gZXEoX2EsIF9iKSB7XG4gICAgcmV0dXJuIF9lcXVhbHMoX2EsIF9iLCBzdGFja0Euc2xpY2UoKSwgc3RhY2tCLnNsaWNlKCkpO1xuICB9XG4gIHJldHVybiAhX2luY2x1ZGVzV2l0aChmdW5jdGlvbihiMywgYUl0ZW0pIHtcbiAgICByZXR1cm4gIV9pbmNsdWRlc1dpdGgoZXEsIGFJdGVtLCBiMyk7XG4gIH0sIGIyLCBhKTtcbn1cbmZ1bmN0aW9uIF9lcXVhbHMoYSwgYjIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmIChvYmplY3RJc19kZWZhdWx0KGEsIGIyKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciB0eXBlQSA9IHR5cGVfZGVmYXVsdChhKTtcbiAgaWYgKHR5cGVBICE9PSB0eXBlX2RlZmF1bHQoYjIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYVtcImZhbnRhc3ktbGFuZC9lcXVhbHNcIl0gPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgYjJbXCJmYW50YXN5LWxhbmQvZXF1YWxzXCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFbXCJmYW50YXN5LWxhbmQvZXF1YWxzXCJdID09PSBcImZ1bmN0aW9uXCIgJiYgYVtcImZhbnRhc3ktbGFuZC9lcXVhbHNcIl0oYjIpICYmIHR5cGVvZiBiMltcImZhbnRhc3ktbGFuZC9lcXVhbHNcIl0gPT09IFwiZnVuY3Rpb25cIiAmJiBiMltcImZhbnRhc3ktbGFuZC9lcXVhbHNcIl0oYSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhLmVxdWFscyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBiMi5lcXVhbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0eXBlb2YgYS5lcXVhbHMgPT09IFwiZnVuY3Rpb25cIiAmJiBhLmVxdWFscyhiMikgJiYgdHlwZW9mIGIyLmVxdWFscyA9PT0gXCJmdW5jdGlvblwiICYmIGIyLmVxdWFscyhhKTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVBKSB7XG4gICAgY2FzZSBcIkFyZ3VtZW50c1wiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgIGlmICh0eXBlb2YgYS5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmIF9mdW5jdGlvbk5hbWUoYS5jb25zdHJ1Y3RvcikgPT09IFwiUHJvbWlzZVwiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiMjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgY2FzZSBcIk51bWJlclwiOlxuICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgIGlmICghKHR5cGVvZiBhID09PSB0eXBlb2YgYjIgJiYgb2JqZWN0SXNfZGVmYXVsdChhLnZhbHVlT2YoKSwgYjIudmFsdWVPZigpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkRhdGVcIjpcbiAgICAgIGlmICghb2JqZWN0SXNfZGVmYXVsdChhLnZhbHVlT2YoKSwgYjIudmFsdWVPZigpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRXJyb3JcIjpcbiAgICAgIHJldHVybiBhLm5hbWUgPT09IGIyLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiMi5tZXNzYWdlO1xuICAgIGNhc2UgXCJSZWdFeHBcIjpcbiAgICAgIGlmICghKGEuc291cmNlID09PSBiMi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIyLmdsb2JhbCAmJiBhLmlnbm9yZUNhc2UgPT09IGIyLmlnbm9yZUNhc2UgJiYgYS5tdWx0aWxpbmUgPT09IGIyLm11bHRpbGluZSAmJiBhLnN0aWNreSA9PT0gYjIuc3RpY2t5ICYmIGEudW5pY29kZSA9PT0gYjIudW5pY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBpZiAoc3RhY2tBW2lkeF0gPT09IGEpIHtcbiAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjI7XG4gICAgfVxuICAgIGlkeCAtPSAxO1xuICB9XG4gIHN3aXRjaCAodHlwZUEpIHtcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgICBpZiAoYS5zaXplICE9PSBiMi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS5lbnRyaWVzKCksIGIyLmVudHJpZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiMl0pKTtcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgICBpZiAoYS5zaXplICE9PSBiMi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS52YWx1ZXMoKSwgYjIudmFsdWVzKCksIHN0YWNrQS5jb25jYXQoW2FdKSwgc3RhY2tCLmNvbmNhdChbYjJdKSk7XG4gICAgY2FzZSBcIkFyZ3VtZW50c1wiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgY2FzZSBcIkRhdGVcIjpcbiAgICBjYXNlIFwiRXJyb3JcIjpcbiAgICBjYXNlIFwiUmVnRXhwXCI6XG4gICAgY2FzZSBcIkludDhBcnJheVwiOlxuICAgIGNhc2UgXCJVaW50OEFycmF5XCI6XG4gICAgY2FzZSBcIlVpbnQ4Q2xhbXBlZEFycmF5XCI6XG4gICAgY2FzZSBcIkludDE2QXJyYXlcIjpcbiAgICBjYXNlIFwiVWludDE2QXJyYXlcIjpcbiAgICBjYXNlIFwiSW50MzJBcnJheVwiOlxuICAgIGNhc2UgXCJVaW50MzJBcnJheVwiOlxuICAgIGNhc2UgXCJGbG9hdDMyQXJyYXlcIjpcbiAgICBjYXNlIFwiRmxvYXQ2NEFycmF5XCI6XG4gICAgY2FzZSBcIkFycmF5QnVmZmVyXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBrZXlzQSA9IGtleXNfZGVmYXVsdChhKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c19kZWZhdWx0KGIyKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGV4dGVuZGVkU3RhY2tBID0gc3RhY2tBLmNvbmNhdChbYV0pO1xuICB2YXIgZXh0ZW5kZWRTdGFja0IgPSBzdGFja0IuY29uY2F0KFtiMl0pO1xuICBpZHggPSBrZXlzQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcbiAgICBpZiAoIShfaGFzKGtleSwgYjIpICYmIF9lcXVhbHMoYjJba2V5XSwgYVtrZXldLCBleHRlbmRlZFN0YWNrQSwgZXh0ZW5kZWRTdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZHggLT0gMTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VxdWFscy5qc1xudmFyIGVxdWFscyA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkyKGZ1bmN0aW9uIGVxdWFsczIoYSwgYjIpIHtcbiAgcmV0dXJuIF9lcXVhbHMoYSwgYjIsIFtdLCBbXSk7XG59KTtcbnZhciBlcXVhbHNfZGVmYXVsdCA9IGVxdWFscztcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pbmRleE9mLmpzXG5mdW5jdGlvbiBfaW5kZXhPZihsaXN0LCBhLCBpZHgpIHtcbiAgdmFyIGluZiwgaXRlbTtcbiAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICBpbmYgPSAxIC8gYTtcbiAgICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gMCAmJiAxIC8gaXRlbSA9PT0gaW5mKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgIT09IGEpIHtcbiAgICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIgJiYgaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKGVxdWFsc19kZWZhdWx0KGxpc3RbaWR4XSwgYSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pbmNsdWRlcy5qc1xuZnVuY3Rpb24gX2luY2x1ZGVzKGEsIGxpc3QpIHtcbiAgcmV0dXJuIF9pbmRleE9mKGxpc3QsIGEsIDApID49IDA7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fbWFwLmpzXG5mdW5jdGlvbiBfbWFwKGZuMiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0MiA9IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICByZXN1bHQyW2lkeF0gPSBmbjIoZnVuY3RvcltpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Mjtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19xdW90ZS5qc1xuZnVuY3Rpb24gX3F1b3RlKHMpIHtcbiAgdmFyIGVzY2FwZWQgPSBzLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9bXFxiXS9nLCBcIlxcXFxiXCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcdi9nLCBcIlxcXFx2XCIpLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpO1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL190b0lTT1N0cmluZy5qc1xudmFyIHBhZCA9IGZ1bmN0aW9uIHBhZDIobikge1xuICByZXR1cm4gKG4gPCAxMCA/IFwiMFwiIDogXCJcIikgKyBuO1xufTtcbnZhciBfdG9JU09TdHJpbmcgPSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uIF90b0lTT1N0cmluZzIoZDIpIHtcbiAgcmV0dXJuIGQyLnRvSVNPU3RyaW5nKCk7XG59IDogZnVuY3Rpb24gX3RvSVNPU3RyaW5nMyhkMikge1xuICByZXR1cm4gZDIuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICsgcGFkKGQyLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICsgcGFkKGQyLmdldFVUQ0RhdGUoKSkgKyBcIlRcIiArIHBhZChkMi5nZXRVVENIb3VycygpKSArIFwiOlwiICsgcGFkKGQyLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArIHBhZChkMi5nZXRVVENTZWNvbmRzKCkpICsgXCIuXCIgKyAoZDIuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgLyAxZTMpLnRvRml4ZWQoMykuc2xpY2UoMiwgNSkgKyBcIlpcIjtcbn07XG52YXIgdG9JU09TdHJpbmdfZGVmYXVsdCA9IF90b0lTT1N0cmluZztcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jb21wbGVtZW50LmpzXG5mdW5jdGlvbiBfY29tcGxlbWVudChmMikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FycmF5UmVkdWNlLmpzXG5mdW5jdGlvbiBfYXJyYXlSZWR1Y2UocmVkdWNlciwgYWNjLCBsaXN0KSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjID0gcmVkdWNlcihhY2MsIGxpc3RbaW5kZXhdKTtcbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHJldHVybiBhY2M7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZmlsdGVyLmpzXG5mdW5jdGlvbiBfZmlsdGVyKGZuMiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0MiA9IFtdO1xuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuMihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHQyW3Jlc3VsdDIubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDI7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNPYmplY3QuanNcbmZ1bmN0aW9uIF9pc09iamVjdCh4Mykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgzKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmlsdGVyLmpzXG52YXIgWEZpbHRlciA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWEZpbHRlcjIoZjIsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGYyO1xuICB9XG4gIFhGaWx0ZXIyLnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0geGZCYXNlX2RlZmF1bHQuaW5pdDtcbiAgWEZpbHRlcjIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IHhmQmFzZV9kZWZhdWx0LnJlc3VsdDtcbiAgWEZpbHRlcjIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0gPSBmdW5jdGlvbihyZXN1bHQyLCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9zdGVwXCJdKHJlc3VsdDIsIGlucHV0KSA6IHJlc3VsdDI7XG4gIH07XG4gIHJldHVybiBYRmlsdGVyMjtcbn0oKTtcbmZ1bmN0aW9uIF94ZmlsdGVyKGYyKSB7XG4gIHJldHVybiBmdW5jdGlvbih4Zikge1xuICAgIHJldHVybiBuZXcgWEZpbHRlcihmMiwgeGYpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvZmlsdGVyLmpzXG52YXIgZmlsdGVyID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoLyogQF9fUFVSRV9fICovIF9kaXNwYXRjaGFibGUoW1wiZmFudGFzeS1sYW5kL2ZpbHRlclwiLCBcImZpbHRlclwiXSwgX3hmaWx0ZXIsIGZ1bmN0aW9uKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIF9pc09iamVjdChmaWx0ZXJhYmxlKSA/IF9hcnJheVJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgIGlmIChwcmVkKGZpbHRlcmFibGVba2V5XSkpIHtcbiAgICAgIGFjY1trZXldID0gZmlsdGVyYWJsZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSwga2V5c19kZWZhdWx0KGZpbHRlcmFibGUpKSA6IChcbiAgICAvLyBlbHNlXG4gICAgX2ZpbHRlcihwcmVkLCBmaWx0ZXJhYmxlKVxuICApO1xufSkpO1xudmFyIGZpbHRlcl9kZWZhdWx0ID0gZmlsdGVyO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVqZWN0LmpzXG52YXIgcmVqZWN0ID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoZnVuY3Rpb24gcmVqZWN0MihwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gIHJldHVybiBmaWx0ZXJfZGVmYXVsdChfY29tcGxlbWVudChwcmVkKSwgZmlsdGVyYWJsZSk7XG59KTtcbnZhciByZWplY3RfZGVmYXVsdCA9IHJlamVjdDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL190b1N0cmluZy5qc1xuZnVuY3Rpb24gX3RvU3RyaW5nKHgzLCBzZWVuKSB7XG4gIHZhciByZWN1ciA9IGZ1bmN0aW9uIHJlY3VyMih5Mikge1xuICAgIHZhciB4czIgPSBzZWVuLmNvbmNhdChbeDNdKTtcbiAgICByZXR1cm4gX2luY2x1ZGVzKHkyLCB4czIpID8gXCI8Q2lyY3VsYXI+XCIgOiBfdG9TdHJpbmcoeTIsIHhzMik7XG4gIH07XG4gIHZhciBtYXBQYWlycyA9IGZ1bmN0aW9uKG9iaiwga2V5czQpIHtcbiAgICByZXR1cm4gX21hcChmdW5jdGlvbihrMikge1xuICAgICAgcmV0dXJuIF9xdW90ZShrMikgKyBcIjogXCIgKyByZWN1cihvYmpbazJdKTtcbiAgICB9LCBrZXlzNC5zbGljZSgpLnNvcnQoKSk7XG4gIH07XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgzKSkge1xuICAgIGNhc2UgXCJbb2JqZWN0IEFyZ3VtZW50c11cIjpcbiAgICAgIHJldHVybiBcIihmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfShcIiArIF9tYXAocmVjdXIsIHgzKS5qb2luKFwiLCBcIikgKyBcIikpXCI7XG4gICAgY2FzZSBcIltvYmplY3QgQXJyYXldXCI6XG4gICAgICByZXR1cm4gXCJbXCIgKyBfbWFwKHJlY3VyLCB4MykuY29uY2F0KG1hcFBhaXJzKHgzLCByZWplY3RfZGVmYXVsdChmdW5jdGlvbihrMikge1xuICAgICAgICByZXR1cm4gL15cXGQrJC8udGVzdChrMik7XG4gICAgICB9LCBrZXlzX2RlZmF1bHQoeDMpKSkpLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgIGNhc2UgXCJbb2JqZWN0IEJvb2xlYW5dXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIHgzID09PSBcIm9iamVjdFwiID8gXCJuZXcgQm9vbGVhbihcIiArIHJlY3VyKHgzLnZhbHVlT2YoKSkgKyBcIilcIiA6IHgzLnRvU3RyaW5nKCk7XG4gICAgY2FzZSBcIltvYmplY3QgRGF0ZV1cIjpcbiAgICAgIHJldHVybiBcIm5ldyBEYXRlKFwiICsgKGlzTmFOKHgzLnZhbHVlT2YoKSkgPyByZWN1cihOYU4pIDogX3F1b3RlKHRvSVNPU3RyaW5nX2RlZmF1bHQoeDMpKSkgKyBcIilcIjtcbiAgICBjYXNlIFwiW29iamVjdCBNYXBdXCI6XG4gICAgICByZXR1cm4gXCJuZXcgTWFwKFwiICsgcmVjdXIoQXJyYXkuZnJvbSh4MykpICsgXCIpXCI7XG4gICAgY2FzZSBcIltvYmplY3QgTnVsbF1cIjpcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICBjYXNlIFwiW29iamVjdCBOdW1iZXJdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIHgzID09PSBcIm9iamVjdFwiID8gXCJuZXcgTnVtYmVyKFwiICsgcmVjdXIoeDMudmFsdWVPZigpKSArIFwiKVwiIDogMSAvIHgzID09PSAtSW5maW5pdHkgPyBcIi0wXCIgOiB4My50b1N0cmluZygxMCk7XG4gICAgY2FzZSBcIltvYmplY3QgU2V0XVwiOlxuICAgICAgcmV0dXJuIFwibmV3IFNldChcIiArIHJlY3VyKEFycmF5LmZyb20oeDMpLnNvcnQoKSkgKyBcIilcIjtcbiAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIHgzID09PSBcIm9iamVjdFwiID8gXCJuZXcgU3RyaW5nKFwiICsgcmVjdXIoeDMudmFsdWVPZigpKSArIFwiKVwiIDogX3F1b3RlKHgzKTtcbiAgICBjYXNlIFwiW29iamVjdCBVbmRlZmluZWRdXCI6XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiB4My50b1N0cmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciByZXByID0geDMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlcHIgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVwcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwie1wiICsgbWFwUGFpcnMoeDMsIGtleXNfZGVmYXVsdCh4MykpLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuICB9XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy90b1N0cmluZy5qc1xudmFyIHRvU3RyaW5nMiA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkxKGZ1bmN0aW9uIHRvU3RyaW5nMyh2YWwpIHtcbiAgcmV0dXJuIF90b1N0cmluZyh2YWwsIFtdKTtcbn0pO1xudmFyIHRvU3RyaW5nX2RlZmF1bHQgPSB0b1N0cmluZzI7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXguanNcbnZhciBtYXggPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MihmdW5jdGlvbiBtYXgyKGEsIGIyKSB7XG4gIGlmIChhID09PSBiMikge1xuICAgIHJldHVybiBiMjtcbiAgfVxuICBmdW5jdGlvbiBzYWZlTWF4KHgzLCB5Mikge1xuICAgIGlmICh4MyA+IHkyICE9PSB5MiA+IHgzKSB7XG4gICAgICByZXR1cm4geTIgPiB4MyA/IHkyIDogeDM7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdmFyIG1heEJ5VmFsdWUgPSBzYWZlTWF4KGEsIGIyKTtcbiAgaWYgKG1heEJ5VmFsdWUgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBtYXhCeVZhbHVlO1xuICB9XG4gIHZhciBtYXhCeVR5cGUgPSBzYWZlTWF4KHR5cGVvZiBhLCB0eXBlb2YgYjIpO1xuICBpZiAobWF4QnlUeXBlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gbWF4QnlUeXBlID09PSB0eXBlb2YgYSA/IGEgOiBiMjtcbiAgfVxuICB2YXIgc3RyaW5nQSA9IHRvU3RyaW5nX2RlZmF1bHQoYSk7XG4gIHZhciBtYXhCeVN0cmluZ1ZhbHVlID0gc2FmZU1heChzdHJpbmdBLCB0b1N0cmluZ19kZWZhdWx0KGIyKSk7XG4gIGlmIChtYXhCeVN0cmluZ1ZhbHVlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gbWF4QnlTdHJpbmdWYWx1ZSA9PT0gc3RyaW5nQSA/IGEgOiBiMjtcbiAgfVxuICByZXR1cm4gYjI7XG59KTtcbnZhciBtYXhfZGVmYXVsdCA9IG1heDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194bWFwLmpzXG52YXIgWE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWE1hcDIoZjIsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGYyO1xuICB9XG4gIFhNYXAyLnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0geGZCYXNlX2RlZmF1bHQuaW5pdDtcbiAgWE1hcDIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IHhmQmFzZV9kZWZhdWx0LnJlc3VsdDtcbiAgWE1hcDIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0gPSBmdW5jdGlvbihyZXN1bHQyLCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLnhmW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0ocmVzdWx0MiwgdGhpcy5mKGlucHV0KSk7XG4gIH07XG4gIHJldHVybiBYTWFwMjtcbn0oKTtcbnZhciBfeG1hcCA9IGZ1bmN0aW9uIF94bWFwMihmMikge1xuICByZXR1cm4gZnVuY3Rpb24oeGYpIHtcbiAgICByZXR1cm4gbmV3IFhNYXAoZjIsIHhmKTtcbiAgfTtcbn07XG52YXIgeG1hcF9kZWZhdWx0ID0gX3htYXA7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXAuanNcbnZhciBtYXAgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MigvKiBAX19QVVJFX18gKi8gX2Rpc3BhdGNoYWJsZShbXCJmYW50YXN5LWxhbmQvbWFwXCIsIFwibWFwXCJdLCB4bWFwX2RlZmF1bHQsIGZ1bmN0aW9uIG1hcDIoZm4yLCBmdW5jdG9yKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0b3IpKSB7XG4gICAgY2FzZSBcIltvYmplY3QgRnVuY3Rpb25dXCI6XG4gICAgICByZXR1cm4gY3VycnlOX2RlZmF1bHQoZnVuY3Rvci5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4yLmNhbGwodGhpcywgZnVuY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH0pO1xuICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjpcbiAgICAgIHJldHVybiBfYXJyYXlSZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBmbjIoZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzX2RlZmF1bHQoZnVuY3RvcikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX21hcChmbjIsIGZ1bmN0b3IpO1xuICB9XG59KSk7XG52YXIgbWFwX2RlZmF1bHQgPSBtYXA7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNJbnRlZ2VyLmpzXG52YXIgaXNJbnRlZ2VyX2RlZmF1bHQgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uIF9pc0ludGVnZXIobikge1xuICByZXR1cm4gbiA8PCAwID09PSBuO1xufTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1N0cmluZy5qc1xuZnVuY3Rpb24gX2lzU3RyaW5nKHgzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeDMpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX250aC5qc1xuZnVuY3Rpb24gX250aChvZmZzZXQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IG9mZnNldCA8IDAgPyBsaXN0Lmxlbmd0aCArIG9mZnNldCA6IG9mZnNldDtcbiAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3QuY2hhckF0KGlkeCkgOiBsaXN0W2lkeF07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wLmpzXG52YXIgcHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkyKGZ1bmN0aW9uIHByb3AyKHAyLCBvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBpc0ludGVnZXJfZGVmYXVsdChwMikgPyBfbnRoKHAyLCBvYmopIDogb2JqW3AyXTtcbn0pO1xudmFyIHByb3BfZGVmYXVsdCA9IHByb3A7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheUxpa2UuanNcbnZhciBfaXNBcnJheUxpa2UgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MShmdW5jdGlvbiBpc0FycmF5TGlrZSh4Mykge1xuICBpZiAoaXNBcnJheV9kZWZhdWx0KHgzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgheDMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiB4MyAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoX2lzU3RyaW5nKHgzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeDMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHgzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4geDMuaGFzT3duUHJvcGVydHkoMCkgJiYgeDMuaGFzT3duUHJvcGVydHkoeDMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG52YXIgaXNBcnJheUxpa2VfZGVmYXVsdCA9IF9pc0FycmF5TGlrZTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jcmVhdGVSZWR1Y2UuanNcbnZhciBzeW1JdGVyYXRvciA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wuaXRlcmF0b3IgOiBcIkBAaXRlcmF0b3JcIjtcbmZ1bmN0aW9uIF9jcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2UsIG1ldGhvZFJlZHVjZSwgaXRlcmFibGVSZWR1Y2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9yZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICAgIGlmIChpc0FycmF5TGlrZV9kZWZhdWx0KGxpc3QpKSB7XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCk7XG4gICAgfVxuICAgIGlmIChsaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGlzdFtcImZhbnRhc3ktbGFuZC9yZWR1Y2VcIl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG1ldGhvZFJlZHVjZSh4ZiwgYWNjLCBsaXN0LCBcImZhbnRhc3ktbGFuZC9yZWR1Y2VcIik7XG4gICAgfVxuICAgIGlmIChsaXN0W3N5bUl0ZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaXRlcmFibGVSZWR1Y2UoeGYsIGFjYywgbGlzdFtzeW1JdGVyYXRvcl0oKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGlzdC5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZVJlZHVjZSh4ZiwgYWNjLCBsaXN0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaXN0LnJlZHVjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gbWV0aG9kUmVkdWNlKHhmLCBhY2MsIGxpc3QsIFwicmVkdWNlXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVkdWNlOiBsaXN0IG11c3QgYmUgYXJyYXkgb3IgaXRlcmFibGVcIik7XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feEFycmF5UmVkdWNlLmpzXG5mdW5jdGlvbiBfeEFycmF5UmVkdWNlKHhmLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGFjYyA9IHhmW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oYWNjLCBsaXN0W2lkeF0pO1xuICAgIGlmIChhY2MgJiYgYWNjW1wiQEB0cmFuc2R1Y2VyL3JlZHVjZWRcIl0pIHtcbiAgICAgIGFjYyA9IGFjY1tcIkBAdHJhbnNkdWNlci92YWx1ZVwiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZHggKz0gMTtcbiAgfVxuICByZXR1cm4geGZbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdKGFjYyk7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9iaW5kLmpzXG52YXIgYmluZCA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkyKGZ1bmN0aW9uIGJpbmQyKGZuMiwgdGhpc09iaikge1xuICByZXR1cm4gX2FyaXR5KGZuMi5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmbjIuYXBwbHkodGhpc09iaiwgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcbnZhciBiaW5kX2RlZmF1bHQgPSBiaW5kO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hSZWR1Y2UuanNcbmZ1bmN0aW9uIF94SXRlcmFibGVSZWR1Y2UoeGYsIGFjYywgaXRlcikge1xuICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgIGFjYyA9IHhmW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oYWNjLCBzdGVwLnZhbHVlKTtcbiAgICBpZiAoYWNjICYmIGFjY1tcIkBAdHJhbnNkdWNlci9yZWR1Y2VkXCJdKSB7XG4gICAgICBhY2MgPSBhY2NbXCJAQHRyYW5zZHVjZXIvdmFsdWVcIl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICB9XG4gIHJldHVybiB4ZltcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0oYWNjKTtcbn1cbmZ1bmN0aW9uIF94TWV0aG9kUmVkdWNlKHhmLCBhY2MsIG9iaiwgbWV0aG9kTmFtZSkge1xuICByZXR1cm4geGZbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdKG9ialttZXRob2ROYW1lXShiaW5kX2RlZmF1bHQoeGZbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSwgeGYpLCBhY2MpKTtcbn1cbnZhciBfeFJlZHVjZSA9IC8qIEBfX1BVUkVfXyAqLyBfY3JlYXRlUmVkdWNlKF94QXJyYXlSZWR1Y2UsIF94TWV0aG9kUmVkdWNlLCBfeEl0ZXJhYmxlUmVkdWNlKTtcbnZhciB4UmVkdWNlX2RlZmF1bHQgPSBfeFJlZHVjZTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194d3JhcC5qc1xudmFyIFhXcmFwID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYV3JhcDIoZm4yKSB7XG4gICAgdGhpcy5mID0gZm4yO1xuICB9XG4gIFhXcmFwMi5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXQgbm90IGltcGxlbWVudGVkIG9uIFhXcmFwXCIpO1xuICB9O1xuICBYV3JhcDIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IGZ1bmN0aW9uKGFjYykge1xuICAgIHJldHVybiBhY2M7XG4gIH07XG4gIFhXcmFwMi5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9IGZ1bmN0aW9uKGFjYywgeDMpIHtcbiAgICByZXR1cm4gdGhpcy5mKGFjYywgeDMpO1xuICB9O1xuICByZXR1cm4gWFdyYXAyO1xufSgpO1xuZnVuY3Rpb24gX3h3cmFwKGZuMikge1xuICByZXR1cm4gbmV3IFhXcmFwKGZuMik7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWR1Y2UuanNcbnZhciByZWR1Y2UgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MyhmdW5jdGlvbih4ZiwgYWNjLCBsaXN0KSB7XG4gIHJldHVybiB4UmVkdWNlX2RlZmF1bHQodHlwZW9mIHhmID09PSBcImZ1bmN0aW9uXCIgPyBfeHdyYXAoeGYpIDogeGYsIGFjYywgbGlzdCk7XG59KTtcbnZhciByZWR1Y2VfZGVmYXVsdCA9IHJlZHVjZTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Fsd2F5cy5qc1xudmFyIGFsd2F5cyA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkxKGZ1bmN0aW9uIGFsd2F5czIodmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xufSk7XG52YXIgYWx3YXlzX2RlZmF1bHQgPSBhbHdheXM7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBlbmQuanNcbnZhciBhcHBlbmQgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MihmdW5jdGlvbiBhcHBlbmQyKGVsMiwgbGlzdCkge1xuICByZXR1cm4gX2NvbmNhdChsaXN0LCBbZWwyXSk7XG59KTtcbnZhciBhcHBlbmRfZGVmYXVsdCA9IGFwcGVuZDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2N1cnJ5LmpzXG52YXIgY3VycnkgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MShmdW5jdGlvbiBjdXJyeTIoZm4yKSB7XG4gIHJldHVybiBjdXJyeU5fZGVmYXVsdChmbjIubGVuZ3RoLCBmbjIpO1xufSk7XG52YXIgY3VycnlfZGVmYXVsdCA9IGN1cnJ5O1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Fzc29jLmpzXG5mdW5jdGlvbiBfYXNzb2MocHJvcDMsIHZhbCwgb2JqKSB7XG4gIGlmIChpc0ludGVnZXJfZGVmYXVsdChwcm9wMykgJiYgaXNBcnJheV9kZWZhdWx0KG9iaikpIHtcbiAgICB2YXIgYXJyID0gW10uY29uY2F0KG9iaik7XG4gICAgYXJyW3Byb3AzXSA9IHZhbDtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIHZhciByZXN1bHQyID0ge307XG4gIGZvciAodmFyIHAyIGluIG9iaikge1xuICAgIHJlc3VsdDJbcDJdID0gb2JqW3AyXTtcbiAgfVxuICByZXN1bHQyW3Byb3AzXSA9IHZhbDtcbiAgcmV0dXJuIHJlc3VsdDI7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pc05pbC5qc1xudmFyIGlzTmlsID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTEoZnVuY3Rpb24gaXNOaWwyKHgzKSB7XG4gIHJldHVybiB4MyA9PSBudWxsO1xufSk7XG52YXIgaXNOaWxfZGVmYXVsdCA9IGlzTmlsO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvYXNzb2NQYXRoLmpzXG52YXIgYXNzb2NQYXRoID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTMoZnVuY3Rpb24gYXNzb2NQYXRoMihwYXRoMiwgdmFsLCBvYmopIHtcbiAgaWYgKHBhdGgyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFyIGlkeCA9IHBhdGgyWzBdO1xuICBpZiAocGF0aDIubGVuZ3RoID4gMSkge1xuICAgIHZhciBuZXh0T2JqID0gIWlzTmlsX2RlZmF1bHQob2JqKSAmJiBfaGFzKGlkeCwgb2JqKSAmJiB0eXBlb2Ygb2JqW2lkeF0gPT09IFwib2JqZWN0XCIgPyBvYmpbaWR4XSA6IGlzSW50ZWdlcl9kZWZhdWx0KHBhdGgyWzFdKSA/IFtdIDoge307XG4gICAgdmFsID0gYXNzb2NQYXRoMihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXRoMiwgMSksIHZhbCwgbmV4dE9iaik7XG4gIH1cbiAgcmV0dXJuIF9hc3NvYyhpZHgsIHZhbCwgb2JqKTtcbn0pO1xudmFyIGFzc29jUGF0aF9kZWZhdWx0ID0gYXNzb2NQYXRoO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvYXNzb2MuanNcbnZhciBhc3NvYyA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkzKGZ1bmN0aW9uIGFzc29jMihwcm9wMywgdmFsLCBvYmopIHtcbiAgcmV0dXJuIGFzc29jUGF0aF9kZWZhdWx0KFtwcm9wM10sIHZhbCwgb2JqKTtcbn0pO1xudmFyIGFzc29jX2RlZmF1bHQgPSBhc3NvYztcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc0Z1bmN0aW9uLmpzXG5mdW5jdGlvbiBfaXNGdW5jdGlvbih4Mykge1xuICB2YXIgdHlwZTMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeDMpO1xuICByZXR1cm4gdHlwZTMgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIiB8fCB0eXBlMyA9PT0gXCJbb2JqZWN0IEFzeW5jRnVuY3Rpb25dXCIgfHwgdHlwZTMgPT09IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiB8fCB0eXBlMyA9PT0gXCJbb2JqZWN0IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25dXCI7XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fbWFrZUZsYXQuanNcbmZ1bmN0aW9uIF9tYWtlRmxhdChyZWN1cnNpdmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZsYXR0KGxpc3QpIHtcbiAgICB2YXIgdmFsdWUsIGpsZW4sIGoyO1xuICAgIHZhciByZXN1bHQyID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGlsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaWR4IDwgaWxlbikge1xuICAgICAgaWYgKGlzQXJyYXlMaWtlX2RlZmF1bHQobGlzdFtpZHhdKSkge1xuICAgICAgICB2YWx1ZSA9IHJlY3Vyc2l2ZSA/IGZsYXR0KGxpc3RbaWR4XSkgOiBsaXN0W2lkeF07XG4gICAgICAgIGoyID0gMDtcbiAgICAgICAgamxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGoyIDwgamxlbikge1xuICAgICAgICAgIHJlc3VsdDJbcmVzdWx0Mi5sZW5ndGhdID0gdmFsdWVbajJdO1xuICAgICAgICAgIGoyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdDJbcmVzdWx0Mi5sZW5ndGhdID0gbGlzdFtpZHhdO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2ZvcmNlUmVkdWNlZC5qc1xuZnVuY3Rpb24gX2ZvcmNlUmVkdWNlZCh4Mykge1xuICByZXR1cm4ge1xuICAgIFwiQEB0cmFuc2R1Y2VyL3ZhbHVlXCI6IHgzLFxuICAgIFwiQEB0cmFuc2R1Y2VyL3JlZHVjZWRcIjogdHJ1ZVxuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2ZsYXRDYXQuanNcbnZhciB0SW5pdCA9IFwiQEB0cmFuc2R1Y2VyL2luaXRcIjtcbnZhciB0U3RlcCA9IFwiQEB0cmFuc2R1Y2VyL3N0ZXBcIjtcbnZhciB0UmVzdWx0ID0gXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCI7XG52YXIgWFByZXNlcnZpbmdSZWR1Y2VkID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYUHJlc2VydmluZ1JlZHVjZWQyKHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICB9XG4gIFhQcmVzZXJ2aW5nUmVkdWNlZDIucHJvdG90eXBlW3RJbml0XSA9IHhmQmFzZV9kZWZhdWx0LmluaXQ7XG4gIFhQcmVzZXJ2aW5nUmVkdWNlZDIucHJvdG90eXBlW3RSZXN1bHRdID0geGZCYXNlX2RlZmF1bHQucmVzdWx0O1xuICBYUHJlc2VydmluZ1JlZHVjZWQyLnByb3RvdHlwZVt0U3RlcF0gPSBmdW5jdGlvbihyZXN1bHQyLCBpbnB1dCkge1xuICAgIHZhciByZXQgPSB0aGlzLnhmW3RTdGVwXShyZXN1bHQyLCBpbnB1dCk7XG4gICAgcmV0dXJuIHJldFtcIkBAdHJhbnNkdWNlci9yZWR1Y2VkXCJdID8gX2ZvcmNlUmVkdWNlZChyZXQpIDogcmV0O1xuICB9O1xuICByZXR1cm4gWFByZXNlcnZpbmdSZWR1Y2VkMjtcbn0oKTtcbnZhciBYRmxhdENhdCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWEZsYXRDYXQyKHhmKSB7XG4gICAgdGhpcy54ZiA9IG5ldyBYUHJlc2VydmluZ1JlZHVjZWQoeGYpO1xuICB9XG4gIFhGbGF0Q2F0Mi5wcm90b3R5cGVbdEluaXRdID0geGZCYXNlX2RlZmF1bHQuaW5pdDtcbiAgWEZsYXRDYXQyLnByb3RvdHlwZVt0UmVzdWx0XSA9IHhmQmFzZV9kZWZhdWx0LnJlc3VsdDtcbiAgWEZsYXRDYXQyLnByb3RvdHlwZVt0U3RlcF0gPSBmdW5jdGlvbihyZXN1bHQyLCBpbnB1dCkge1xuICAgIHJldHVybiAhaXNBcnJheUxpa2VfZGVmYXVsdChpbnB1dCkgPyBfeEFycmF5UmVkdWNlKHRoaXMueGYsIHJlc3VsdDIsIFtpbnB1dF0pIDogeFJlZHVjZV9kZWZhdWx0KHRoaXMueGYsIHJlc3VsdDIsIGlucHV0KTtcbiAgfTtcbiAgcmV0dXJuIFhGbGF0Q2F0Mjtcbn0oKTtcbnZhciBfZmxhdENhdCA9IGZ1bmN0aW9uIF94Y2F0KHhmKSB7XG4gIHJldHVybiBuZXcgWEZsYXRDYXQoeGYpO1xufTtcbnZhciBmbGF0Q2F0X2RlZmF1bHQgPSBfZmxhdENhdDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194Y2hhaW4uanNcbmZ1bmN0aW9uIF94Y2hhaW4oZjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHhmKSB7XG4gICAgcmV0dXJuIHhtYXBfZGVmYXVsdChmMikoZmxhdENhdF9kZWZhdWx0KHhmKSk7XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9jaGFpbi5qc1xudmFyIGNoYWluID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoLyogQF9fUFVSRV9fICovIF9kaXNwYXRjaGFibGUoW1wiZmFudGFzeS1sYW5kL2NoYWluXCIsIFwiY2hhaW5cIl0sIF94Y2hhaW4sIGZ1bmN0aW9uIGNoYWluMihmbjIsIG1vbmFkKSB7XG4gIGlmICh0eXBlb2YgbW9uYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmdW5jdGlvbih4Mykge1xuICAgICAgcmV0dXJuIGZuMihtb25hZCh4MykpKHgzKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfbWFrZUZsYXQoZmFsc2UpKG1hcF9kZWZhdWx0KGZuMiwgbW9uYWQpKTtcbn0pKTtcbnZhciBjaGFpbl9kZWZhdWx0ID0gY2hhaW47XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGlwZS5qc1xuZnVuY3Rpb24gX3BpcGUoZjIsIGcyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZzIuY2FsbCh0aGlzLCBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qc1xuZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuMikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZuMigpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpc0FycmF5X2RlZmF1bHQob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSBcImZ1bmN0aW9uXCIgPyBmbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgbGVuZ3RoIC0gMSkpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvc2xpY2UuanNcbnZhciBzbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkzKC8qIEBfX1BVUkVfXyAqLyBfY2hlY2tGb3JNZXRob2QoXCJzbGljZVwiLCBmdW5jdGlvbiBzbGljZTIoZnJvbUluZGV4LCB0b0luZGV4LCBsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xufSkpO1xudmFyIHNsaWNlX2RlZmF1bHQgPSBzbGljZTtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RhaWwuanNcbnZhciB0YWlsID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTEoLyogQF9fUFVSRV9fICovIF9jaGVja0Zvck1ldGhvZChcInRhaWxcIiwgLyogQF9fUFVSRV9fICovIHNsaWNlX2RlZmF1bHQoMSwgSW5maW5pdHkpKSk7XG52YXIgdGFpbF9kZWZhdWx0ID0gdGFpbDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpcGUuanNcbmZ1bmN0aW9uIHBpcGUoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIF9hcml0eShhcmd1bWVudHNbMF0ubGVuZ3RoLCByZWR1Y2VfZGVmYXVsdChfcGlwZSwgYXJndW1lbnRzWzBdLCB0YWlsX2RlZmF1bHQoYXJndW1lbnRzKSkpO1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lkZW50aXR5LmpzXG5mdW5jdGlvbiBfaWRlbnRpdHkoeDMpIHtcbiAgcmV0dXJuIHgzO1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaWRlbnRpdHkuanNcbnZhciBpZGVudGl0eSA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkxKF9pZGVudGl0eSk7XG52YXIgaWRlbnRpdHlfZGVmYXVsdCA9IGlkZW50aXR5O1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uY2F0LmpzXG52YXIgY29uY2F0ID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoZnVuY3Rpb24gY29uY2F0MihhLCBiMikge1xuICBpZiAoaXNBcnJheV9kZWZhdWx0KGEpKSB7XG4gICAgaWYgKGlzQXJyYXlfZGVmYXVsdChiMikpIHtcbiAgICAgIHJldHVybiBhLmNvbmNhdChiMik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmdfZGVmYXVsdChiMikgKyBcIiBpcyBub3QgYW4gYXJyYXlcIik7XG4gIH1cbiAgaWYgKF9pc1N0cmluZyhhKSkge1xuICAgIGlmIChfaXNTdHJpbmcoYjIpKSB7XG4gICAgICByZXR1cm4gYSArIGIyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nX2RlZmF1bHQoYjIpICsgXCIgaXMgbm90IGEgc3RyaW5nXCIpO1xuICB9XG4gIGlmIChhICE9IG51bGwgJiYgX2lzRnVuY3Rpb24oYVtcImZhbnRhc3ktbGFuZC9jb25jYXRcIl0pKSB7XG4gICAgcmV0dXJuIGFbXCJmYW50YXN5LWxhbmQvY29uY2F0XCJdKGIyKTtcbiAgfVxuICBpZiAoYSAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKGEuY29uY2F0KSkge1xuICAgIHJldHVybiBhLmNvbmNhdChiMik7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZ19kZWZhdWx0KGEpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiY29uY2F0XCIgb3IgXCJmYW50YXN5LWxhbmQvY29uY2F0XCInKTtcbn0pO1xudmFyIGNvbmNhdF9kZWZhdWx0ID0gY29uY2F0O1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uZC5qc1xudmFyIGNvbmQgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MShmdW5jdGlvbiBjb25kMihwYWlycykge1xuICB2YXIgYXJpdHkgPSByZWR1Y2VfZGVmYXVsdChtYXhfZGVmYXVsdCwgMCwgbWFwX2RlZmF1bHQoZnVuY3Rpb24ocGFpcikge1xuICAgIHJldHVybiBwYWlyWzBdLmxlbmd0aDtcbiAgfSwgcGFpcnMpKTtcbiAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IHBhaXJzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIGNvbmRfZGVmYXVsdCA9IGNvbmQ7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWZhdWx0VG8uanNcbnZhciBkZWZhdWx0VG8gPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8yKGQyLCB2Mikge1xuICByZXR1cm4gdjIgPT0gbnVsbCB8fCB2MiAhPT0gdjIgPyBkMiA6IHYyO1xufSk7XG52YXIgZGVmYXVsdFRvX2RlZmF1bHQgPSBkZWZhdWx0VG87XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9oYXNQYXRoLmpzXG52YXIgaGFzUGF0aCA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkyKGZ1bmN0aW9uIGhhc1BhdGgyKF9wYXRoMiwgb2JqKSB7XG4gIGlmIChfcGF0aDIubGVuZ3RoID09PSAwIHx8IGlzTmlsX2RlZmF1bHQob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gb2JqO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IF9wYXRoMi5sZW5ndGgpIHtcbiAgICBpZiAoIWlzTmlsX2RlZmF1bHQodmFsKSAmJiBfaGFzKF9wYXRoMltpZHhdLCB2YWwpKSB7XG4gICAgICB2YWwgPSB2YWxbX3BhdGgyW2lkeF1dO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcbnZhciBoYXNQYXRoX2RlZmF1bHQgPSBoYXNQYXRoO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaGFzLmpzXG52YXIgaGFzID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoZnVuY3Rpb24gaGFzMihwcm9wMywgb2JqKSB7XG4gIHJldHVybiBoYXNQYXRoX2RlZmF1bHQoW3Byb3AzXSwgb2JqKTtcbn0pO1xudmFyIGhhc19kZWZhdWx0ID0gaGFzO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaWZFbHNlLmpzXG52YXIgaWZFbHNlID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTMoZnVuY3Rpb24gaWZFbHNlMihjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICByZXR1cm4gY3VycnlOX2RlZmF1bHQoTWF0aC5tYXgoY29uZGl0aW9uLmxlbmd0aCwgb25UcnVlLmxlbmd0aCwgb25GYWxzZS5sZW5ndGgpLCBmdW5jdGlvbiBfaWZFbHNlKCkge1xuICAgIHJldHVybiBjb25kaXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IG9uVHJ1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb25GYWxzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xudmFyIGlmRWxzZV9kZWZhdWx0ID0gaWZFbHNlO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5jbHVkZXMuanNcbnZhciBpbmNsdWRlcyA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkyKF9pbmNsdWRlcyk7XG52YXIgaW5jbHVkZXNfZGVmYXVsdCA9IGluY2x1ZGVzO1xuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52b2tlci5qc1xudmFyIGludm9rZXIgPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MihmdW5jdGlvbiBpbnZva2VyMihhcml0eSwgbWV0aG9kKSB7XG4gIHJldHVybiBjdXJyeU5fZGVmYXVsdChhcml0eSArIDEsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbYXJpdHldO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiBfaXNGdW5jdGlvbih0YXJnZXRbbWV0aG9kXSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbbWV0aG9kXS5hcHBseSh0YXJnZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJpdHkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZ19kZWZhdWx0KHRhcmdldCkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gIH0pO1xufSk7XG52YXIgaW52b2tlcl9kZWZhdWx0ID0gaW52b2tlcjtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lzLmpzXG52YXIgaXMyID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoZnVuY3Rpb24gaXMzKEN0b3IsIHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQ3RvciB8fCB2YWwgIT0gbnVsbCAmJiAodmFsLmNvbnN0cnVjdG9yID09PSBDdG9yIHx8IEN0b3IubmFtZSA9PT0gXCJPYmplY3RcIiAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKTtcbn0pO1xudmFyIGlzX2RlZmF1bHQgPSBpczI7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pc05vdE5pbC5qc1xudmFyIGlzTm90TmlsID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTEoZnVuY3Rpb24gaXNOb3ROaWwyKHgzKSB7XG4gIHJldHVybiAhaXNOaWxfZGVmYXVsdCh4Myk7XG59KTtcbnZhciBpc05vdE5pbF9kZWZhdWx0ID0gaXNOb3ROaWw7XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9qb2luLmpzXG52YXIgam9pbiA9IC8qIEBfX1BVUkVfXyAqLyBpbnZva2VyX2RlZmF1bHQoMSwgXCJqb2luXCIpO1xudmFyIGpvaW5fZGVmYXVsdCA9IGpvaW47XG5cbi8vIG5vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGF0aC5qc1xuZnVuY3Rpb24gX3BhdGgocGF0aEFyLCBvYmopIHtcbiAgdmFyIHZhbCA9IG9iajtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoQXIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBwMiA9IHBhdGhBcltpXTtcbiAgICBpZiAoaXNJbnRlZ2VyX2RlZmF1bHQocDIpKSB7XG4gICAgICB2YWwgPSBfbnRoKHAyLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSB2YWxbcDJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aC5qc1xudmFyIHBhdGggPSAvKiBAX19QVVJFX18gKi8gX2N1cnJ5MihfcGF0aCk7XG52YXIgcGF0aF9kZWZhdWx0ID0gcGF0aDtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3BPci5qc1xudmFyIHByb3BPciA9IC8qIEBfX1BVUkVfXyAqLyBfY3VycnkzKGZ1bmN0aW9uIHByb3BPcjIodmFsLCBwMiwgb2JqKSB7XG4gIHJldHVybiBkZWZhdWx0VG9fZGVmYXVsdCh2YWwsIHByb3BfZGVmYXVsdChwMiwgb2JqKSk7XG59KTtcbnZhciBwcm9wT3JfZGVmYXVsdCA9IHByb3BPcjtcblxuLy8gbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194dGFwLmpzXG52YXIgWFRhcCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFRhcDIoZjIsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGYyO1xuICB9XG4gIFhUYXAyLnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0geGZCYXNlX2RlZmF1bHQuaW5pdDtcbiAgWFRhcDIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IHhmQmFzZV9kZWZhdWx0LnJlc3VsdDtcbiAgWFRhcDIucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0gPSBmdW5jdGlvbihyZXN1bHQyLCBpbnB1dCkge1xuICAgIHRoaXMuZihpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXShyZXN1bHQyLCBpbnB1dCk7XG4gIH07XG4gIHJldHVybiBYVGFwMjtcbn0oKTtcbmZ1bmN0aW9uIF94dGFwKGYyKSB7XG4gIHJldHVybiBmdW5jdGlvbih4Zikge1xuICAgIHJldHVybiBuZXcgWFRhcChmMiwgeGYpO1xuICB9O1xufVxuXG4vLyBub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFwLmpzXG52YXIgdGFwID0gLyogQF9fUFVSRV9fICovIF9jdXJyeTIoLyogQF9fUFVSRV9fICovIF9kaXNwYXRjaGFibGUoW10sIF94dGFwLCBmdW5jdGlvbiB0YXAyKGZuMiwgeDMpIHtcbiAgZm4yKHgzKTtcbiAgcmV0dXJuIHgzO1xufSkpO1xudmFyIHRhcF9kZWZhdWx0ID0gdGFwO1xuXG4vLyBub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanNcbnZhciB1dGlsO1xuKGZ1bmN0aW9uKHV0aWwyKSB7XG4gIHV0aWwyLmFzc2VydEVxdWFsID0gKHZhbCkgPT4gdmFsO1xuICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICB1dGlsMi5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICB1dGlsMi5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgdXRpbDIuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwyLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGsyKSA9PiB0eXBlb2Ygb2JqW29ialtrMl1dICE9PSBcIm51bWJlclwiKTtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgIGZvciAoY29uc3QgazIgb2YgdmFsaWRLZXlzKSB7XG4gICAgICBmaWx0ZXJlZFtrMl0gPSBvYmpbazJdO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbDIub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgfTtcbiAgdXRpbDIub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB1dGlsMi5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBvYmpbZV07XG4gICAgfSk7XG4gIH07XG4gIHV0aWwyLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgOiAob2JqZWN0KSA9PiB7XG4gICAgY29uc3Qga2V5czQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIGtleXM0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM0O1xuICB9O1xuICB1dGlsMi5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcbiAgdXRpbDIuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIiA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbiAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgIHJldHVybiBhcnJheS5tYXAoKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfVxuICB1dGlsMi5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgdXRpbDIuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8zLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uKG9iamVjdFV0aWwyKSB7XG4gIG9iamVjdFV0aWwyLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmlyc3QsXG4gICAgICAuLi5zZWNvbmRcbiAgICAgIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgfTtcbiAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xudmFyIFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgXCJzdHJpbmdcIixcbiAgXCJuYW5cIixcbiAgXCJudW1iZXJcIixcbiAgXCJpbnRlZ2VyXCIsXG4gIFwiZmxvYXRcIixcbiAgXCJib29sZWFuXCIsXG4gIFwiZGF0ZVwiLFxuICBcImJpZ2ludFwiLFxuICBcInN5bWJvbFwiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwidW5kZWZpbmVkXCIsXG4gIFwibnVsbFwiLFxuICBcImFycmF5XCIsXG4gIFwib2JqZWN0XCIsXG4gIFwidW5rbm93blwiLFxuICBcInByb21pc2VcIixcbiAgXCJ2b2lkXCIsXG4gIFwibmV2ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJzZXRcIlxuXSk7XG52YXIgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5hcnJheTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubWFwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgfVxufTtcbnZhciBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgXCJpbnZhbGlkX3R5cGVcIixcbiAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgXCJpbnZhbGlkX2RhdGVcIixcbiAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICBcInRvb19zbWFsbFwiLFxuICBcInRvb19iaWdcIixcbiAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICBcIm5vdF9maW5pdGVcIlxuXSk7XG52YXIgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xudmFyIFpvZEVycm9yID0gY2xhc3MgX1pvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgIH07XG4gICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgfTtcbiAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgfVxuICBnZXQgZXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgfVxuICBmb3JtYXQoX21hcHBlcikge1xuICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHwgZnVuY3Rpb24oaXNzdWUpIHtcbiAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgIH07XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZWwyID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICBjdXJyW2VsMl0gPSBjdXJyW2VsMl0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycltlbDJdID0gY3VycltlbDJdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgY3VycltlbDJdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsMl07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59O1xuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICByZXR1cm4gZXJyb3I7XG59O1xudmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gIGxldCBtZXNzYWdlMjtcbiAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICBtZXNzYWdlMiA9IFwiUmVxdWlyZWRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UyID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICBtZXNzYWdlMiA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgIG1lc3NhZ2UyID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgbWVzc2FnZTIgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgbWVzc2FnZTIgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgbWVzc2FnZTIgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZTIgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UyID0gYCR7bWVzc2FnZTJ9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZTIgPSBcIkludmFsaWRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIG1lc3NhZ2UyID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICBtZXNzYWdlMiA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIG1lc3NhZ2UyID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UyID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZTIgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICBtZXNzYWdlMiA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgbWVzc2FnZTIgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgbWVzc2FnZTIgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgbWVzc2FnZTIgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UyID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2AgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XG4gICAgICBlbHNlXG4gICAgICAgIG1lc3NhZ2UyID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICBtZXNzYWdlMiA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgbWVzc2FnZTIgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICBtZXNzYWdlMiA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgIG1lc3NhZ2UyID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtZXNzYWdlMiA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gIH1cbiAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZTIgfTtcbn07XG52YXIgb3ZlcnJpZGVFcnJvck1hcCA9IGVycm9yTWFwO1xuZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwMykge1xuICBvdmVycmlkZUVycm9yTWFwID0gbWFwMztcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cbnZhciBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gIGNvbnN0IHsgZGF0YSwgcGF0aDogcGF0aDIsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgyLCAuLi5pc3N1ZURhdGEucGF0aCB8fCBbXV07XG4gIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGhcbiAgfTtcbiAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gIGNvbnN0IG1hcHMgPSBlcnJvck1hcHMuZmlsdGVyKChtMikgPT4gISFtMikuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAoY29uc3QgbWFwMyBvZiBtYXBzKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gbWFwMyhmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmlzc3VlRGF0YSxcbiAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2VcbiAgfTtcbn07XG52YXIgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgaXNzdWVEYXRhLFxuICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgIGVycm9yTWFwczogW1xuICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICBvdmVycmlkZU1hcCxcbiAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHZvaWQgMCA6IGVycm9yTWFwXG4gICAgICAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgIF0uZmlsdGVyKCh4MykgPT4gISF4MylcbiAgfSk7XG4gIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxudmFyIFBhcnNlU3RhdHVzID0gY2xhc3MgX1BhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzMikge1xuICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0czIpIHtcbiAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gIH1cbn07XG52YXIgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICBzdGF0dXM6IFwiYWJvcnRlZFwiXG59KTtcbnZhciBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xudmFyIE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG52YXIgaXNBYm9ydGVkID0gKHgzKSA9PiB4My5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xudmFyIGlzRGlydHkgPSAoeDMpID0+IHgzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xudmFyIGlzVmFsaWQgPSAoeDMpID0+IHgzLnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xudmFyIGlzQXN5bmMgPSAoeDMpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHgzIGluc3RhbmNlb2YgUHJvbWlzZTtcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmMikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYyKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYyIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYyIDoga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyKSA6IGYyID8gZjIudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmMikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZjIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZjIgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJhXCIgPyBmMi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmMiA/IGYyLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSwgdmFsdWU7XG59XG52YXIgZXJyb3JVdGlsO1xuKGZ1bmN0aW9uKGVycm9yVXRpbDIpIHtcbiAgZXJyb3JVdGlsMi5lcnJUb09iaiA9IChtZXNzYWdlMikgPT4gdHlwZW9mIG1lc3NhZ2UyID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBtZXNzYWdlMiB9IDogbWVzc2FnZTIgfHwge307XG4gIGVycm9yVXRpbDIudG9TdHJpbmcgPSAobWVzc2FnZTIpID0+IHR5cGVvZiBtZXNzYWdlMiA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UyIDogbWVzc2FnZTIgPT09IG51bGwgfHwgbWVzc2FnZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UyLm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG52YXIgX1pvZEVudW1fY2FjaGU7XG52YXIgX1pvZE5hdGl2ZUVudW1fY2FjaGU7XG52YXIgUGFyc2VJbnB1dExhenlQYXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoMiwga2V5KSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMuX3BhdGggPSBwYXRoMjtcbiAgICB0aGlzLl9rZXkgPSBrZXk7XG4gIH1cbiAgZ2V0IHBhdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICB9XG59O1xudmFyIGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdDIpID0+IHtcbiAgaWYgKGlzVmFsaWQocmVzdWx0MikpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQyLnZhbHVlIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICBpZiAoIXBhcmFtcylcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgaWYgKGVycm9yTWFwMiAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgfVxuICBpZiAoZXJyb3JNYXAyKVxuICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcDIsIGRlc2NyaXB0aW9uIH07XG4gIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBtZXNzYWdlOiBtZXNzYWdlMiB9ID0gcGFyYW1zO1xuICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZTIgIT09IG51bGwgJiYgbWVzc2FnZTIgIT09IHZvaWQgMCA/IG1lc3NhZ2UyIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2EgPSBtZXNzYWdlMiAhPT0gbnVsbCAmJiBtZXNzYWdlMiAhPT0gdm9pZCAwID8gbWVzc2FnZTIgOiByZXF1aXJlZF9lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH1cbiAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgcmV0dXJuIHsgbWVzc2FnZTogKF9iID0gbWVzc2FnZTIgIT09IG51bGwgJiYgbWVzc2FnZTIgIT09IHZvaWQgMCA/IG1lc3NhZ2UyIDogaW52YWxpZF90eXBlX2Vycm9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gIH07XG4gIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG52YXIgWm9kVHlwZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgfVxuICBfZ2V0VHlwZShpbnB1dCkge1xuICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICB9XG4gIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgcmV0dXJuIGN0eCB8fCB7XG4gICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnRcbiAgICB9O1xuICB9XG4gIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgIGN0eDoge1xuICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICBpZiAoaXNBc3luYyhyZXN1bHQyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdDIpO1xuICB9XG4gIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdDIgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgIGlmIChyZXN1bHQyLnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0Mi5kYXRhO1xuICAgIHRocm93IHJlc3VsdDIuZXJyb3I7XG4gIH1cbiAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhLFxuICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0Mik7XG4gIH1cbiAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xuICAgIGlmIChyZXN1bHQyLnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0Mi5kYXRhO1xuICAgIHRocm93IHJlc3VsdDIuZXJyb3I7XG4gIH1cbiAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcbiAgICB9O1xuICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0Mik7XG4gIH1cbiAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlMikge1xuICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZTIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UyIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlMih2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UyO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQyID0gY2hlY2sodmFsKTtcbiAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdDIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQyLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3VsdDIpIHtcbiAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihvcHRpb24pIHtcbiAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICB9XG4gIGFuZChpbmNvbWluZykge1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICB9XG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBicmFuZCgpIHtcbiAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgdHlwZTogdGhpcyxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKVxuICAgIH0pO1xuICB9XG4gIGNhdGNoKGRlZikge1xuICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoXG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBwaXBlKHRhcmdldCkge1xuICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgfVxuICByZWFkb25seSgpIHtcbiAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICB9XG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHZvaWQgMCkuc3VjY2VzcztcbiAgfVxuICBpc051bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICB9XG59O1xudmFyIGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xudmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xudmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xudmFyIHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xudmFyIG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbnZhciBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbnZhciBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbnZhciBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG52YXIgZW1vamlSZWdleDtcbnZhciBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xudmFyIGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xudmFyIGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICBsZXQgcmVnZXggPSBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZGA7XG4gIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICB9IGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgfVxuICByZXR1cm4gcmVnZXg7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gIGNvbnN0IG9wdHMgPSBbXTtcbiAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBab2RTdHJpbmcgPSBjbGFzcyBfWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgoZGF0YSkgPT4gcmVnZXgudGVzdChkYXRhKSwge1xuICAgICAgdmFsaWRhdGlvbixcbiAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgZW1haWwobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMikgfSk7XG4gIH1cbiAgdXJsKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UyKSB9KTtcbiAgfVxuICBlbW9qaShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UyKSB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMikgfSk7XG4gIH1cbiAgbmFub2lkKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UyKSB9KTtcbiAgfVxuICBjdWlkKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMikgfSk7XG4gIH1cbiAgY3VpZDIobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMikgfSk7XG4gIH1cbiAgdWxpZChtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpIH0pO1xuICB9XG4gIGJhc2U2NChtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMikgfSk7XG4gIH1cbiAgaXAob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICB9XG4gIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcbiAgICAgIG9mZnNldDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICBsb2NhbDogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBkYXRlKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2U6IG1lc3NhZ2UyIH0pO1xuICB9XG4gIHRpbWUob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgbWVzc2FnZTogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGR1cmF0aW9uKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpIH0pO1xuICB9XG4gIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICByZWdleCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHBvc2l0aW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgdmFsdWUsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heExlbmd0aCwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbiwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgKiBAc2VlIHtAbGluayBab2RTdHJpbmcubWlufVxuICAgKi9cbiAgbm9uZW1wdHkobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UyKSk7XG4gIH1cbiAgdHJpbSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XVxuICAgIH0pO1xuICB9XG4gIHRvTG93ZXJDYXNlKCkge1xuICAgIHJldHVybiBuZXcgX1pvZFN0cmluZyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XVxuICAgIH0pO1xuICB9XG4gIHRvVXBwZXJDYXNlKCkge1xuICAgIHJldHVybiBuZXcgX1pvZFN0cmluZyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XVxuICAgIH0pO1xuICB9XG4gIGdldCBpc0RhdGV0aW1lKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gIH1cbiAgZ2V0IGlzRGF0ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gIH1cbiAgZ2V0IGlzVGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gIH1cbiAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgfVxuICBnZXQgaXNFbWFpbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICB9XG4gIGdldCBpc1VSTCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgfVxuICBnZXQgaXNFbW9qaSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICB9XG4gIGdldCBpc1VVSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICB9XG4gIGdldCBpc05BTk9JRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgfVxuICBnZXQgaXNDVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgfVxuICBnZXQgaXNDVUlEMigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICB9XG4gIGdldCBpc1VMSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICB9XG4gIGdldCBpc0lQKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gIH1cbiAgZ2V0IGlzQmFzZTY0KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICB9XG4gIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgbGV0IG1heDMgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heDMgPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgzKVxuICAgICAgICAgIG1heDMgPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDM7XG4gIH1cbn07XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICBjaGVja3M6IFtdLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgcmV0dXJuIHZhbEludCAlIHN0ZXBJbnQgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxudmFyIFpvZE51bWJlciA9IGNsYXNzIF9ab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBndGUodmFsdWUsIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMikpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSk7XG4gIH1cbiAgbHRlKHZhbHVlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMikpO1xuICB9XG4gIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kTnVtYmVyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kTnVtYmVyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGludChtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImludFwiLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIHBvc2l0aXZlKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgbm9ubmVnYXRpdmUobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgZmluaXRlKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpXG4gICAgfSk7XG4gIH1cbiAgc2FmZShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIGdldCBtaW5WYWx1ZSgpIHtcbiAgICBsZXQgbWluID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW47XG4gIH1cbiAgZ2V0IG1heFZhbHVlKCkge1xuICAgIGxldCBtYXgzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXgzID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4MylcbiAgICAgICAgICBtYXgzID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXgzO1xuICB9XG4gIGdldCBpc0ludCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSk7XG4gIH1cbiAgZ2V0IGlzRmluaXRlKCkge1xuICAgIGxldCBtYXgzID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4MyA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heDMpXG4gICAgICAgICAgbWF4MyA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heDMpO1xuICB9XG59O1xuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RCaWdJbnQgPSBjbGFzcyBfWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSk7XG4gIH1cbiAgZ3QodmFsdWUsIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMikpO1xuICB9XG4gIGx0KHZhbHVlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSk7XG4gIH1cbiAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZTIpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIG5lZ2F0aXZlKG1lc3NhZ2UyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlMilcbiAgICB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIGdldCBtaW5WYWx1ZSgpIHtcbiAgICBsZXQgbWluID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW47XG4gIH1cbiAgZ2V0IG1heFZhbHVlKCkge1xuICAgIGxldCBtYXgzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXgzID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4MylcbiAgICAgICAgICBtYXgzID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXgzO1xuICB9XG59O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQm9vbGVhbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZERhdGUgPSBjbGFzcyBfWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhEYXRlLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKVxuICAgIH0pO1xuICB9XG4gIGdldCBtaW5EYXRlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XG4gIH1cbiAgZ2V0IG1heERhdGUoKSB7XG4gICAgbGV0IG1heDMgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heDMgPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgzKVxuICAgICAgICAgIG1heDMgPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDMgIT0gbnVsbCA/IG5ldyBEYXRlKG1heDMpIDogbnVsbDtcbiAgfVxufTtcblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgIGNoZWNrczogW10sXG4gICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kU3ltYm9sID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RVbmRlZmluZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZE51bGwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQW55ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFVua25vd24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZE5ldmVyID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgfSk7XG4gICAgcmV0dXJuIElOVkFMSUQ7XG4gIH1cbn07XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RWb2lkID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQXJyYXkgPSBjbGFzcyBfWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiB0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgICBtYXhpbXVtOiB0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB2b2lkIDAsXG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1heExlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICB9KSkudGhlbigocmVzdWx0MykgPT4ge1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdDMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDIgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQyKTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heExlbmd0aCwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSB9XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbiwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBleGFjdExlbmd0aDogeyB2YWx1ZTogbGVuLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlMik7XG4gIH1cbn07XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgdHlwZTogc2NoZW1hLFxuICAgIG1pbkxlbmd0aDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudClcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XG4gICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbn1cbnZhciBab2RPYmplY3QgPSBjbGFzcyBfWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gIH1cbiAgX2dldENhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIGNvbnN0IGtleXM0ID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5czoga2V5czQgfTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJiB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XG4gICAgICBjb25zdCBrZXlWYWxpZGF0b3IgPSBzaGFwZVtrZXldO1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcbiAgICAgIGNvbnN0IHVua25vd25LZXlzID0gdGhpcy5fZGVmLnVua25vd25LZXlzO1xuICAgICAgaWYgKHVua25vd25LZXlzID09PSBcInBhc3N0aHJvdWdoXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICBrZXlzOiBleHRyYUtleXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNhdGNoYWxsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgdmFsdWU6IGNhdGNoYWxsLl9wYXJzZShcbiAgICAgICAgICAgIG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSlcbiAgICAgICAgICAgIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgfSkudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgfVxuICB9XG4gIGdldCBzaGFwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gIH1cbiAgc3RyaWN0KG1lc3NhZ2UyKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgIC4uLm1lc3NhZ2UyICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UyKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIHN0cmlwKCkge1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiXG4gICAgfSk7XG4gIH1cbiAgcGFzc3Rocm91Z2goKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCJcbiAgICB9KTtcbiAgfVxuICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gIC8vICAgKTogWm9kT2JqZWN0PFxuICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gIC8vICAgPiA9PiB7XG4gIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gIC8vICAgICAgIC4uLmRlZixcbiAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAvLyAgICAgICB9KSxcbiAgLy8gICAgIH0pIGFzIGFueTtcbiAgLy8gICB9O1xuICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLi4uYXVnbWVudGF0aW9uXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgKi9cbiAgbWVyZ2UobWVyZ2luZykge1xuICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgICAgfSksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdFxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbiAgLy8gbWVyZ2U8XG4gIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9LFxuICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gIC8vICAgICAgID8gSW5wdXRba11cbiAgLy8gICAgICAgOiBuZXZlcjtcbiAgLy8gICB9XG4gIC8vID4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgLy8gICBOZXdPdXRwdXQsXG4gIC8vICAgTmV3SW5wdXRcbiAgLy8gPiB7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICB9XG4gIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAvLyBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gIC8vID4ge1xuICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgLy8gICAvLyApO1xuICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgLy8gICB9KSBhcyBhbnk7XG4gIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgLy8gfVxuICBjYXRjaGFsbChpbmRleCkge1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjYXRjaGFsbDogaW5kZXhcbiAgICB9KTtcbiAgfVxuICBwaWNrKG1hc2spIHtcbiAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZVxuICAgIH0pO1xuICB9XG4gIG9taXQobWFzaykge1xuICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBkZWVwUGFydGlhbCgpIHtcbiAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gIH1cbiAgcGFydGlhbChtYXNrKSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZVxuICAgIH0pO1xuICB9XG4gIHJlcXVpcmVkKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAga2V5b2YoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgfVxufTtcblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kVW5pb24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzMikge1xuICAgICAgZm9yIChjb25zdCByZXN1bHQyIG9mIHJlc3VsdHMyKSB7XG4gICAgICAgIGlmIChyZXN1bHQyLnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQyLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZXN1bHQyIG9mIHJlc3VsdHMyKSB7XG4gICAgICAgIGlmIChyZXN1bHQyLnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0Mi5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMyLm1hcCgocmVzdWx0MikgPT4gbmV3IFpvZEVycm9yKHJlc3VsdDIuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHhcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjdHg6IGNoaWxkQ3R4XG4gICAgICAgIH07XG4gICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpcnR5ID0gdm9pZCAwO1xuICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0Mi5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdDIuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgZGlydHkgPSB7IHJlc3VsdDogcmVzdWx0MiwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlczIpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMyKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn07XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICBvcHRpb25zOiB0eXBlcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlMykgPT4ge1xuICBpZiAodHlwZTMgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZTMuc2NoZW1hKTtcbiAgfSBlbHNlIGlmICh0eXBlMyBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlMy5pbm5lclR5cGUoKSk7XG4gIH0gZWxzZSBpZiAodHlwZTMgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgcmV0dXJuIFt0eXBlMy52YWx1ZV07XG4gIH0gZWxzZSBpZiAodHlwZTMgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgcmV0dXJuIHR5cGUzLm9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZTMgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUzLmVudW0pO1xuICB9IGVsc2UgaWYgKHR5cGUzIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUzLl9kZWYuaW5uZXJUeXBlKTtcbiAgfSBlbHNlIGlmICh0eXBlMyBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbdm9pZCAwXTtcbiAgfSBlbHNlIGlmICh0eXBlMyBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKHR5cGUzIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICByZXR1cm4gW3ZvaWQgMCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlMy51bndyYXAoKSldO1xuICB9IGVsc2UgaWYgKHR5cGUzIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZTMudW53cmFwKCkpXTtcbiAgfSBlbHNlIGlmICh0eXBlMyBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlMy51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZTMgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUzLnVud3JhcCgpKTtcbiAgfSBlbHNlIGlmICh0eXBlMyBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZTMuX2RlZi5pbm5lclR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcbnZhciBab2REaXNjcmltaW5hdGVkVW5pb24gPSBjbGFzcyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG4gIGdldCBvcHRpb25zTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgdHlwZTMgb2Ygb3B0aW9ucykge1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZTMuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlMyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1pvZERpc2NyaW1pbmF0ZWRVbmlvbih7XG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICBvcHRpb25zLFxuICAgICAgb3B0aW9uc01hcCxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYjIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYjIpO1xuICBpZiAoYSA9PT0gYjIpIHtcbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICB9IGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiMik7XG4gICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iMiB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiMltrZXldKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYjIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICBjb25zdCBpdGVtQiA9IGIyW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiMikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gIH1cbn1cbnZhciBab2RJbnRlcnNlY3Rpb24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgIH07XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KVxuICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbn07XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RUdXBsZSA9IGNsYXNzIF9ab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICB0eXBlOiBcImFycmF5XCJcbiAgICAgIH0pO1xuICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgIH0pLmZpbHRlcigoeDMpID0+ICEheDMpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMyKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0czIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgIH1cbiAgfVxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgfVxuICByZXN0KHJlc3QpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RUdXBsZSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXN0XG4gICAgfSk7XG4gIH1cbn07XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICB9XG4gIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgcmVzdDogbnVsbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFJlY29yZCA9IGNsYXNzIF9ab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gIH1cbiAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgIH1cbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgIHJldHVybiBuZXcgX1pvZFJlY29yZCh7XG4gICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfWm9kUmVjb3JkKHtcbiAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKVxuICAgIH0pO1xuICB9XG59O1xudmFyIFpvZE1hcCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIGNvbnN0IGZpbmFsTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmluYWxNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XG4gICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICB9XG4gIH1cbn07XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICB2YWx1ZVR5cGUsXG4gICAga2V5VHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFNldCA9IGNsYXNzIF9ab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMyKSB7XG4gICAgICBjb25zdCBwYXJzZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzMikge1xuICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzMikgPT4gZmluYWxpemVTZXQoZWxlbWVudHMyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgfVxuICB9XG4gIG1pbihtaW5TaXplLCBtZXNzYWdlMikge1xuICAgIHJldHVybiBuZXcgX1pvZFNldCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZTIpIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4U2l6ZSwgbWVzc2FnZTIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTZXQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UyKSB9XG4gICAgfSk7XG4gIH1cbiAgc2l6ZShzaXplLCBtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlMikubWF4KHNpemUsIG1lc3NhZ2UyKTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlMikge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlMik7XG4gIH1cbn07XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICB2YWx1ZVR5cGUsXG4gICAgbWluU2l6ZTogbnVsbCxcbiAgICBtYXhTaXplOiBudWxsLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kRnVuY3Rpb24gPSBjbGFzcyBfWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICBlcnJvck1hcFxuICAgICAgICBdLmZpbHRlcigoeDMpID0+ICEheDMpLFxuICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgIGVycm9yTWFwXG4gICAgICAgIF0uZmlsdGVyKCh4MykgPT4gISF4MyksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgY29uc3QgZm4yID0gY3R4LmRhdGE7XG4gICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgY29uc3QgbWUyID0gdGhpcztcbiAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lMi5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbjIsIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUyLl9kZWYucmV0dXJucy5fZGVmLnR5cGUucGFyc2VBc3luYyhyZXN1bHQyLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQyLCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZTIgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lMi5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IFJlZmxlY3QuYXBwbHkoZm4yLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUyLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0MiwgcGFyYW1zKTtcbiAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0MiwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICB9XG4gIHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICB9XG4gIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXR1cm5zOiByZXR1cm5UeXBlXG4gICAgfSk7XG4gIH1cbiAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgfVxuICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xuICAgICAgYXJnczogYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgWm9kTGF6eSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn07XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgIGdldHRlcixcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn07XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgdmFsdWUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kRW51bSA9IGNsYXNzIF9ab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBWYWx1ZXMoKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZ2V0IEVudW0oKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIF9ab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLm5ld0RlZlxuICAgIH0pO1xuICB9XG59O1xuX1pvZEVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbnZhciBab2ROYXRpdmVFbnVtID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgIH1cbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFByb21pc2UgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59O1xuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICB0eXBlOiBzY2hlbWEsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kRWZmZWN0cyA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKCkgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkMikgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkMixcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzdWx0Mi5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgaWYgKHJlc3VsdDIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0Mi52YWx1ZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdDIudmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChyZXN1bHQyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQyLnZhbHVlKTtcbiAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQyLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQyID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfTtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICBpZiAocmVzdWx0MiBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQyIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdDIpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0MiB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gIH1cbn07XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgc2NoZW1hLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICBlZmZlY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICBzY2hlbWEsXG4gICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RPcHRpb25hbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPSyh2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlMywgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgIGlubmVyVHlwZTogdHlwZTMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZE51bGxhYmxlID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZTMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICBpbm5lclR5cGU6IHR5cGUzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZTMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgIGlubmVyVHlwZTogdHlwZTMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuZGVmYXVsdCA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQ2F0Y2ggPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAuLi5jdHgsXG4gICAgICBjb21tb246IHtcbiAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgLi4ubmV3Q3R4XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0MikpIHtcbiAgICAgIHJldHVybiByZXN1bHQyLnRoZW4oKHJlc3VsdDMpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0My5zdGF0dXMgPT09IFwidmFsaWRcIiA/IHJlc3VsdDMudmFsdWUgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgIHZhbHVlOiByZXN1bHQyLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0Mi52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZTMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICBpbm5lclR5cGU6IHR5cGUzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmFOID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxufTtcblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyIFpvZEJyYW5kZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICBkYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn07XG52YXIgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoYSwgYjIpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RQaXBlbGluZSh7XG4gICAgICBpbjogYSxcbiAgICAgIG91dDogYjIsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lXG4gICAgfSk7XG4gIH1cbn07XG52YXIgWm9kUmVhZG9ubHkgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHQyID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0MikgPyByZXN1bHQyLnRoZW4oKGRhdGEpID0+IGZyZWV6ZShkYXRhKSkgOiBmcmVlemUocmVzdWx0Mik7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUzLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgaW5uZXJUeXBlOiB0eXBlMyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIHBhcmFtcyA9IHt9LCBmYXRhbCkge1xuICBpZiAoY2hlY2spXG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICBjb25zdCBwMiA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwMi5mYXRhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmF0YWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICAgIGNvbnN0IHAyMiA9IHR5cGVvZiBwMiA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcDIgfSA6IHAyO1xuICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wMjIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG52YXIgbGF0ZSA9IHtcbiAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZVxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24oWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMikge1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xudmFyIGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xudmFyIHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xudmFyIG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xudmFyIG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xudmFyIGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xudmFyIGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG52YXIgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbnZhciBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbnZhciB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbnZhciBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xudmFyIGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xudmFyIHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG52YXIgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xudmFyIHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG52YXIgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xudmFyIG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xudmFyIHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xudmFyIHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbnZhciBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbnZhciBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbnZhciB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG52YXIgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG52YXIgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG52YXIgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG52YXIgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xudmFyIGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG52YXIgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbnZhciBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xudmFyIG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG52YXIgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbnZhciBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xudmFyIG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbnZhciBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG52YXIgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xudmFyIHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbnZhciBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xudmFyIG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xudmFyIGNvZXJjZSA9IHtcbiAgc3RyaW5nOiAoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIG51bWJlcjogKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxuICBib29sZWFuOiAoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgLi4uYXJnLFxuICAgIGNvZXJjZTogdHJ1ZVxuICB9KSxcbiAgYmlnaW50OiAoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIGRhdGU6IChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSlcbn07XG52YXIgTkVWRVIgPSBJTlZBTElEO1xudmFyIHoyID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXG4gIHNldEVycm9yTWFwLFxuICBnZXRFcnJvck1hcCxcbiAgbWFrZUlzc3VlLFxuICBFTVBUWV9QQVRILFxuICBhZGRJc3N1ZVRvQ29udGV4dCxcbiAgUGFyc2VTdGF0dXMsXG4gIElOVkFMSUQsXG4gIERJUlRZLFxuICBPSyxcbiAgaXNBYm9ydGVkLFxuICBpc0RpcnR5LFxuICBpc1ZhbGlkLFxuICBpc0FzeW5jLFxuICBnZXQgdXRpbCgpIHtcbiAgICByZXR1cm4gdXRpbDtcbiAgfSxcbiAgZ2V0IG9iamVjdFV0aWwoKSB7XG4gICAgcmV0dXJuIG9iamVjdFV0aWw7XG4gIH0sXG4gIFpvZFBhcnNlZFR5cGUsXG4gIGdldFBhcnNlZFR5cGUsXG4gIFpvZFR5cGUsXG4gIGRhdGV0aW1lUmVnZXgsXG4gIFpvZFN0cmluZyxcbiAgWm9kTnVtYmVyLFxuICBab2RCaWdJbnQsXG4gIFpvZEJvb2xlYW4sXG4gIFpvZERhdGUsXG4gIFpvZFN5bWJvbCxcbiAgWm9kVW5kZWZpbmVkLFxuICBab2ROdWxsLFxuICBab2RBbnksXG4gIFpvZFVua25vd24sXG4gIFpvZE5ldmVyLFxuICBab2RWb2lkLFxuICBab2RBcnJheSxcbiAgWm9kT2JqZWN0LFxuICBab2RVbmlvbixcbiAgWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICBab2RJbnRlcnNlY3Rpb24sXG4gIFpvZFR1cGxlLFxuICBab2RSZWNvcmQsXG4gIFpvZE1hcCxcbiAgWm9kU2V0LFxuICBab2RGdW5jdGlvbixcbiAgWm9kTGF6eSxcbiAgWm9kTGl0ZXJhbCxcbiAgWm9kRW51bSxcbiAgWm9kTmF0aXZlRW51bSxcbiAgWm9kUHJvbWlzZSxcbiAgWm9kRWZmZWN0cyxcbiAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gIFpvZE9wdGlvbmFsLFxuICBab2ROdWxsYWJsZSxcbiAgWm9kRGVmYXVsdCxcbiAgWm9kQ2F0Y2gsXG4gIFpvZE5hTixcbiAgQlJBTkQsXG4gIFpvZEJyYW5kZWQsXG4gIFpvZFBpcGVsaW5lLFxuICBab2RSZWFkb25seSxcbiAgY3VzdG9tLFxuICBTY2hlbWE6IFpvZFR5cGUsXG4gIFpvZFNjaGVtYTogWm9kVHlwZSxcbiAgbGF0ZSxcbiAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCgpIHtcbiAgICByZXR1cm4gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuICB9LFxuICBjb2VyY2UsXG4gIGFueTogYW55VHlwZSxcbiAgYXJyYXk6IGFycmF5VHlwZSxcbiAgYmlnaW50OiBiaWdJbnRUeXBlLFxuICBib29sZWFuOiBib29sZWFuVHlwZSxcbiAgZGF0ZTogZGF0ZVR5cGUsXG4gIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcbiAgZWZmZWN0OiBlZmZlY3RzVHlwZSxcbiAgXCJlbnVtXCI6IGVudW1UeXBlLFxuICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uVHlwZSxcbiAgXCJpbnN0YW5jZW9mXCI6IGluc3RhbmNlT2ZUeXBlLFxuICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gIGxhenk6IGxhenlUeXBlLFxuICBsaXRlcmFsOiBsaXRlcmFsVHlwZSxcbiAgbWFwOiBtYXBUeXBlLFxuICBuYW46IG5hblR5cGUsXG4gIG5hdGl2ZUVudW06IG5hdGl2ZUVudW1UeXBlLFxuICBuZXZlcjogbmV2ZXJUeXBlLFxuICBcIm51bGxcIjogbnVsbFR5cGUsXG4gIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXG4gIG51bWJlcjogbnVtYmVyVHlwZSxcbiAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICBvYm9vbGVhbixcbiAgb251bWJlcixcbiAgb3B0aW9uYWw6IG9wdGlvbmFsVHlwZSxcbiAgb3N0cmluZyxcbiAgcGlwZWxpbmU6IHBpcGVsaW5lVHlwZSxcbiAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc1R5cGUsXG4gIHByb21pc2U6IHByb21pc2VUeXBlLFxuICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gIHNldDogc2V0VHlwZSxcbiAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gIHN5bWJvbDogc3ltYm9sVHlwZSxcbiAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICB0dXBsZTogdHVwbGVUeXBlLFxuICBcInVuZGVmaW5lZFwiOiB1bmRlZmluZWRUeXBlLFxuICB1bmlvbjogdW5pb25UeXBlLFxuICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgXCJ2b2lkXCI6IHZvaWRUeXBlLFxuICBORVZFUixcbiAgWm9kSXNzdWVDb2RlLFxuICBxdW90ZWxlc3NKc29uLFxuICBab2RFcnJvclxufSk7XG5cbi8vIHNyYy9jbGllbnQvZ2F0ZXdheS5qc1xuZnVuY3Rpb24gbG9hZFRyYW5zYWN0aW9uTWV0YVdpdGgoeyBmZXRjaDogZmV0Y2gyLCBHUkFQSFFMX1VSTDogR1JBUEhRTF9VUkwyLCBsb2dnZXIgfSkge1xuICBjb25zdCBHRVRfVFJBTlNBQ1RJT05TX1FVRVJZID0gYFxuICAgIHF1ZXJ5IEdldFRyYW5zYWN0aW9ucyAoJHRyYW5zYWN0aW9uSWRzOiBbSUQhXSEpIHtcbiAgICAgIHRyYW5zYWN0aW9ucyhpZHM6ICR0cmFuc2FjdGlvbklkcykge1xuICAgICAgICBlZGdlcyB7XG4gICAgICAgICAgbm9kZSB7XG4gICAgICAgICAgICBvd25lciB7XG4gICAgICAgICAgICAgIGFkZHJlc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZ3Mge1xuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgICB0aW1lc3RhbXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgY29uc3QgdHJhbnNhY3Rpb25Db25uZWN0aW9uU2NoZW1hID0gejIub2JqZWN0KHtcbiAgICBkYXRhOiB6Mi5vYmplY3Qoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB6Mi5vYmplY3Qoe1xuICAgICAgICBlZGdlczogejIuYXJyYXkoejIub2JqZWN0KHtcbiAgICAgICAgICBub2RlOiB6Mi5yZWNvcmQoejIuYW55KCkpXG4gICAgICAgIH0pKVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbiAgcmV0dXJuIChpZCkgPT4gb2YoaWQpLmNoYWluKGZyb21Qcm9taXNlKFxuICAgIChpZDIpID0+IGZldGNoMihHUkFQSFFMX1VSTDIsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHF1ZXJ5OiBHRVRfVFJBTlNBQ1RJT05TX1FVRVJZLFxuICAgICAgICB2YXJpYWJsZXM6IHsgdHJhbnNhY3Rpb25JZHM6IFtpZDJdIH1cbiAgICAgIH0pXG4gICAgfSkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBpZiAocmVzLm9rKSByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgIGxvZ2dlcignRXJyb3IgRW5jb3VudGVyZWQgd2hlbiBxdWVyeWluZyBnYXRld2F5IGZvciB0cmFuc2FjdGlvbiBcIiVzXCInLCBpZDIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9OiAke2F3YWl0IHJlcy50ZXh0KCl9YCk7XG4gICAgfSkudGhlbih0cmFuc2FjdGlvbkNvbm5lY3Rpb25TY2hlbWEucGFyc2UpLnRoZW4ocGF0aF9kZWZhdWx0KFtcImRhdGFcIiwgXCJ0cmFuc2FjdGlvbnNcIiwgXCJlZGdlc1wiLCBcIjBcIiwgXCJub2RlXCJdKSlcbiAgKSkudG9Qcm9taXNlKCk7XG59XG5cbi8vIHNyYy9sb2dnZXIuanNcbnZhciBpbXBvcnRfZGVidWcgPSBfX3RvRVNNKHJlcXVpcmVfYnJvd3NlcigpLCAxKTtcbnZhciBjcmVhdGVMb2dnZXIgPSAobmFtZSA9IFwiQHBlcm1hd2ViL2FvY29ubmVjdFwiKSA9PiB7XG4gIGNvbnN0IGxvZ2dlciA9ICgwLCBpbXBvcnRfZGVidWcuZGVmYXVsdCkobmFtZSk7XG4gIGxvZ2dlci5jaGlsZCA9IChuYW1lMikgPT4gY3JlYXRlTG9nZ2VyKGAke2xvZ2dlci5uYW1lc3BhY2V9OiR7bmFtZTJ9YCk7XG4gIGxvZ2dlci50YXAgPSAobm90ZSwgLi4ucmVzdCkgPT4gdGFwX2RlZmF1bHQoKC4uLmFyZ3MpID0+IGxvZ2dlcihub3RlLCAuLi5yZXN0LCAuLi5hcmdzKSk7XG4gIHJldHVybiBsb2dnZXI7XG59O1xuXG4vLyBzcmMvbGliL3V0aWxzLmpzXG52YXIgam9pblVybCA9ICh7IHVybCwgcGF0aDogcGF0aDIgfSkgPT4ge1xuICBpZiAoIXBhdGgyKSByZXR1cm4gdXJsO1xuICBpZiAocGF0aDIuc3RhcnRzV2l0aChcIi9cIikpIHJldHVybiBqb2luVXJsKHsgdXJsLCBwYXRoOiBwYXRoMi5zbGljZSgxKSB9KTtcbiAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICB1cmwucGF0aG5hbWUgKz0gcGF0aDI7XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn07XG5mdW5jdGlvbiBwYXJzZVRhZ3MocmF3VGFncykge1xuICByZXR1cm4gcGlwZShcbiAgICBkZWZhdWx0VG9fZGVmYXVsdChbXSksXG4gICAgcmVkdWNlX2RlZmF1bHQoXG4gICAgICAobWFwMywgdGFnKSA9PiBwaXBlKFxuICAgICAgICAvLyBbdmFsdWUsIHZhbHVlLCAuLi5dIHx8IFtdXG4gICAgICAgIHByb3BPcl9kZWZhdWx0KFtdLCB0YWcubmFtZSksXG4gICAgICAgIC8vIFt2YWx1ZV1cbiAgICAgICAgYXBwZW5kX2RlZmF1bHQodGFnLnZhbHVlKSxcbiAgICAgICAgLy8geyBbbmFtZV06IFt2YWx1ZSwgdmFsdWUsIC4uLl0gfVxuICAgICAgICBhc3NvY19kZWZhdWx0KHRhZy5uYW1lLCBfX2RlZmF1bHQsIG1hcDMpXG4gICAgICApKG1hcDMpLFxuICAgICAge31cbiAgICApLFxuICAgIC8qKlxuICAgICogSWYgdGhlIGZpZWxkIGlzIG9ubHkgYSBzaW5nbHkgbGlzdCwgdGhlbiBleHRyYWN0IHRoZSBvbmUgdmFsdWUuXG4gICAgKlxuICAgICogT3RoZXJ3aXNlLCBrZWVwIHRoZSB2YWx1ZSBhcyBhIGxpc3QuXG4gICAgKi9cbiAgICBtYXBfZGVmYXVsdCgodmFsdWVzKSA9PiB2YWx1ZXMubGVuZ3RoID4gMSA/IHZhbHVlcyA6IHZhbHVlc1swXSlcbiAgKShyYXdUYWdzKTtcbn1cbmZ1bmN0aW9uIGVxT3JJbmNsdWRlcyh2YWwpIHtcbiAgcmV0dXJuIGNvbmRfZGVmYXVsdChbXG4gICAgW2lzX2RlZmF1bHQoU3RyaW5nKSwgZXF1YWxzX2RlZmF1bHQodmFsKV0sXG4gICAgW2lzX2RlZmF1bHQoQXJyYXkpLCBpbmNsdWRlc19kZWZhdWx0KHZhbCldLFxuICAgIFtUX2RlZmF1bHQsIEZfZGVmYXVsdF1cbiAgXSk7XG59XG5mdW5jdGlvbiBlcnJGcm9tKGVycikge1xuICBsZXQgZTtcbiAgaWYgKGlzX2RlZmF1bHQoWm9kRXJyb3IsIGVycikpIHtcbiAgICBlID0gbmV3IEVycm9yKG1hcFpvZEVycihlcnIpKTtcbiAgICBlLnN0YWNrICs9IGVyci5zdGFjaztcbiAgfSBlbHNlIGlmIChpc19kZWZhdWx0KEVycm9yLCBlcnIpKSB7XG4gICAgZSA9IGVycjtcbiAgfSBlbHNlIGlmIChoYXNfZGVmYXVsdChcIm1lc3NhZ2VcIiwgZXJyKSkge1xuICAgIGUgPSBuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICB9IGVsc2UgaWYgKGlzX2RlZmF1bHQoU3RyaW5nLCBlcnIpKSB7XG4gICAgZSA9IG5ldyBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGUgPSBuZXcgRXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZFwiKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG1hcFpvZEVycih6b2RFcnIpIHtcbiAgcmV0dXJuIHBpcGUoXG4gICAgKHpvZEVycjIpID0+IChcbiAgICAgIC8qKlxuICAgICAgICogVGFrZSBhIFpvZEVycm9yIGFuZCBmbGF0dGVuIGl0J3MgaXNzdWVzIGludG8gYSBzaW5nbGUgZGVwdGggYXJyYXlcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2F0aGVyWm9kSXNzdWVzKHpvZEVycjMsIHN0YXR1cywgY29udGV4dENvZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZV9kZWZhdWx0KFxuICAgICAgICAgIChpc3N1ZXMsIGlzc3VlKSA9PiBwaXBlKFxuICAgICAgICAgICAgY29uZF9kZWZhdWx0KFtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFRoZXNlIGlzc3VlIGNvZGVzIGluZGljYXRlIG5lc3RlZCBab2RFcnJvcnMsIHNvIHdlIHJlc3Vyc2l2ZWx5IGdhdGhlciB0aG9zZVxuICAgICAgICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2Jsb2IvSEVBRC9FUlJPUl9IQU5ETElORy5tZCN6b2Rpc3N1ZWNvZGVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBlcXVhbHNfZGVmYXVsdChab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICgpID0+IGdhdGhlclpvZElzc3Vlcyhpc3N1ZS5hcmd1bWVudHNFcnJvciwgNDIyLCBcIkludmFsaWQgQXJndW1lbnRzXCIpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBlcXVhbHNfZGVmYXVsdChab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSksXG4gICAgICAgICAgICAgICAgKCkgPT4gZ2F0aGVyWm9kSXNzdWVzKGlzc3VlLnJldHVyblR5cGVFcnJvciwgNTAwLCBcIkludmFsaWQgUmV0dXJuXCIpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBlcXVhbHNfZGVmYXVsdChab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbiksXG4gICAgICAgICAgICAgICAgLy8gQW4gYXJyYXkgb2YgWm9kRXJyb3JzLCBzbyBtYXAgb3ZlciBhbmQgZmxhdHRlbiB0aGVtIGFsbFxuICAgICAgICAgICAgICAgICgpID0+IGNoYWluX2RlZmF1bHQoKGkpID0+IGdhdGhlclpvZElzc3VlcyhpLCA0MDAsIFwiSW52YWxpZCBVbmlvblwiKSwgaXNzdWUudW5pb25FcnJvcnMpXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIFtUX2RlZmF1bHQsICgpID0+IFt7IC4uLmlzc3VlLCBzdGF0dXMsIGNvbnRleHRDb2RlIH1dXVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBjb25jYXRfZGVmYXVsdChpc3N1ZXMpXG4gICAgICAgICAgKShpc3N1ZS5jb2RlKSxcbiAgICAgICAgICBbXSxcbiAgICAgICAgICB6b2RFcnIzLmlzc3Vlc1xuICAgICAgICApO1xuICAgICAgfSh6b2RFcnIyLCA0MDAsIFwiXCIpXG4gICAgKSxcbiAgICAvKipcbiAgICAgKiBjb21iaW5lIGFsbCB6b2QgaXNzdWVzIGludG8gYSBsaXN0IG9mIHsgbWVzc2FnZSwgc3RhdHVzIH1cbiAgICAgKiBzdW1tYXJpZXMgb2YgZWFjaCBpc3N1ZVxuICAgICAqL1xuICAgICh6b2RJc3N1ZXMpID0+IHJlZHVjZV9kZWZhdWx0KFxuICAgICAgKGFjYywgem9kSXNzdWUpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlOiBtZXNzYWdlMiwgcGF0aDogX3BhdGgyLCBjb250ZXh0Q29kZTogX2NvbnRleHRDb2RlIH0gPSB6b2RJc3N1ZTtcbiAgICAgICAgY29uc3QgcGF0aDIgPSBfcGF0aDJbMV0gfHwgX3BhdGgyWzBdO1xuICAgICAgICBjb25zdCBjb250ZXh0Q29kZSA9IF9jb250ZXh0Q29kZSA/IGAke19jb250ZXh0Q29kZX0gYCA6IFwiXCI7XG4gICAgICAgIGFjYy5wdXNoKGAke2NvbnRleHRDb2RlfScke3BhdGgyfSc6ICR7bWVzc2FnZTJ9LmApO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIFtdLFxuICAgICAgem9kSXNzdWVzXG4gICAgKSxcbiAgICBqb2luX2RlZmF1bHQoXCIgfCBcIilcbiAgKSh6b2RFcnIpO1xufVxuXG4vLyBzcmMvbGliL3Jlc3VsdC92ZXJpZnktaW5wdXQuanNcbnZhciBpbnB1dFNjaGVtYSA9IHoyLm9iamVjdCh7XG4gIGlkOiB6Mi5zdHJpbmcoKS5taW4oMSwgeyBtZXNzYWdlOiBcIm1lc3NhZ2UgaXMgcmVxdWlyZWQgdG8gYmUgYSBtZXNzYWdlIGlkXCIgfSksXG4gIHByb2Nlc3NJZDogejIuc3RyaW5nKCkubWluKDEsIHsgbWVzc2FnZTogXCJwcm9jZXNzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcHJvY2VzcyBpZFwiIH0pXG59KTtcbmZ1bmN0aW9uIHZlcmlmeUlucHV0V2l0aCgpIHtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICByZXR1cm4gb2YoY3R4KS5tYXAoaW5wdXRTY2hlbWEucGFyc2UpLm1hcCgoKSA9PiBjdHgpO1xuICB9O1xufVxuXG4vLyBzcmMvZGFsLmpzXG52YXIgdGFnU2NoZW1hID0gejIub2JqZWN0KHtcbiAgbmFtZTogejIuc3RyaW5nKCksXG4gIHZhbHVlOiB6Mi5zdHJpbmcoKVxufSk7XG52YXIgZHJ5cnVuUmVzdWx0U2NoZW1hID0gejIuZnVuY3Rpb24oKS5hcmdzKHoyLm9iamVjdCh7XG4gIElkOiB6Mi5zdHJpbmcoKSxcbiAgVGFyZ2V0OiB6Mi5zdHJpbmcoKSxcbiAgT3duZXI6IHoyLnN0cmluZygpLFxuICBBbmNob3I6IHoyLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIERhdGE6IHoyLmFueSgpLmRlZmF1bHQoXCIxMjM0XCIpLFxuICBUYWdzOiB6Mi5hcnJheSh6Mi5vYmplY3QoeyBuYW1lOiB6Mi5zdHJpbmcoKSwgdmFsdWU6IHoyLnN0cmluZygpIH0pKVxufSkpLnJldHVybnMoejIucHJvbWlzZSh6Mi5hbnkoKSkpO1xudmFyIGxvYWRSZXN1bHRTY2hlbWEgPSB6Mi5mdW5jdGlvbigpLmFyZ3MoejIub2JqZWN0KHtcbiAgaWQ6IHoyLnN0cmluZygpLm1pbigxLCB7IG1lc3NhZ2U6IFwibWVzc2FnZSBpZCBpcyByZXF1aXJlZFwiIH0pLFxuICBwcm9jZXNzSWQ6IHoyLnN0cmluZygpLm1pbigxLCB7IG1lc3NhZ2U6IFwicHJvY2VzcyBpZCBpcyByZXF1aXJlZFwiIH0pXG59KSkucmV0dXJucyh6Mi5wcm9taXNlKHoyLmFueSgpKSk7XG52YXIgcXVlcnlSZXN1bHRzU2NoZW1hID0gejIuZnVuY3Rpb24oKS5hcmdzKHoyLm9iamVjdCh7XG4gIHByb2Nlc3M6IHoyLnN0cmluZygpLm1pbigxLCB7IG1lc3NhZ2U6IFwicHJvY2VzcyBpZCBpcyByZXF1aXJlZFwiIH0pLFxuICBmcm9tOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0bzogejIuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgc29ydDogejIuZW51bShbXCJBU0NcIiwgXCJERVNDXCJdKS5kZWZhdWx0KFwiQVNDXCIpLFxuICBsaW1pdDogejIubnVtYmVyKCkub3B0aW9uYWwoKVxufSkpLnJldHVybnMoejIucHJvbWlzZSh6Mi5vYmplY3Qoe1xuICBlZGdlczogejIuYXJyYXkoejIub2JqZWN0KHtcbiAgICBjdXJzb3I6IHoyLnN0cmluZygpLFxuICAgIG5vZGU6IHoyLm9iamVjdCh7XG4gICAgICBPdXRwdXQ6IHoyLmFueSgpLm9wdGlvbmFsKCksXG4gICAgICBNZXNzYWdlczogejIuYXJyYXkoejIuYW55KCkpLm9wdGlvbmFsKCksXG4gICAgICBTcGF3bnM6IHoyLmFycmF5KHoyLmFueSgpKS5vcHRpb25hbCgpLFxuICAgICAgRXJyb3I6IHoyLmFueSgpLm9wdGlvbmFsKClcbiAgICB9KVxuICB9KSlcbn0pKSk7XG52YXIgZGVwbG95TWVzc2FnZVNjaGVtYSA9IHoyLmZ1bmN0aW9uKCkuYXJncyh6Mi5vYmplY3Qoe1xuICBwcm9jZXNzSWQ6IHoyLnN0cmluZygpLFxuICBkYXRhOiB6Mi5hbnkoKSxcbiAgdGFnczogejIuYXJyYXkodGFnU2NoZW1hKSxcbiAgYW5jaG9yOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBzaWduZXI6IHoyLmFueSgpXG59KSkucmV0dXJucyh6Mi5wcm9taXNlKFxuICB6Mi5vYmplY3Qoe1xuICAgIG1lc3NhZ2VJZDogejIuc3RyaW5nKClcbiAgfSkucGFzc3Rocm91Z2goKVxuKSk7XG52YXIgZGVwbG95UHJvY2Vzc1NjaGVtYSA9IHoyLmZ1bmN0aW9uKCkuYXJncyh6Mi5vYmplY3Qoe1xuICBkYXRhOiB6Mi5hbnkoKSxcbiAgdGFnczogejIuYXJyYXkodGFnU2NoZW1hKSxcbiAgc2lnbmVyOiB6Mi5hbnkoKVxufSkpLnJldHVybnMoejIucHJvbWlzZShcbiAgejIub2JqZWN0KHtcbiAgICBwcm9jZXNzSWQ6IHoyLnN0cmluZygpXG4gIH0pLnBhc3N0aHJvdWdoKClcbikpO1xudmFyIGRlcGxveUFzc2lnblNjaGVtYSA9IHoyLmZ1bmN0aW9uKCkuYXJncyh6Mi5vYmplY3Qoe1xuICBwcm9jZXNzOiB6Mi5zdHJpbmcoKSxcbiAgbWVzc2FnZTogejIuc3RyaW5nKCksXG4gIGJhc2VMYXllcjogejIuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIGV4Y2x1ZGU6IHoyLmFycmF5KHoyLnN0cmluZygpKS5vcHRpb25hbCgpXG59KSkucmV0dXJucyh6Mi5wcm9taXNlKFxuICB6Mi5vYmplY3Qoe1xuICAgIGFzc2lnbm1lbnRJZDogejIuc3RyaW5nKClcbiAgfSkucGFzc3Rocm91Z2goKVxuKSk7XG52YXIgZGVwbG95TW9uaXRvclNjaGVtYSA9IGRlcGxveU1lc3NhZ2VTY2hlbWE7XG52YXIgbG9hZFByb2Nlc3NNZXRhU2NoZW1hID0gejIuZnVuY3Rpb24oKS5hcmdzKHoyLm9iamVjdCh7XG4gIHN1VXJsOiB6Mi5zdHJpbmcoKS51cmwoKSxcbiAgcHJvY2Vzc0lkOiB6Mi5zdHJpbmcoKVxufSkpLnJldHVybnMoejIucHJvbWlzZShcbiAgejIub2JqZWN0KHtcbiAgICB0YWdzOiB6Mi5hcnJheSh0YWdTY2hlbWEpXG4gIH0pLnBhc3N0aHJvdWdoKClcbikpO1xudmFyIGxvY2F0ZVNjaGVkdWxlclNjaGVtYSA9IHoyLmZ1bmN0aW9uKCkuYXJncyh6Mi5zdHJpbmcoKSkucmV0dXJucyh6Mi5wcm9taXNlKFxuICB6Mi5vYmplY3Qoe1xuICAgIHVybDogejIuc3RyaW5nKClcbiAgfSlcbikpO1xudmFyIHZhbGlkYXRlU2NoZWR1bGVyU2NoZW1hID0gejIuZnVuY3Rpb24oKS5hcmdzKHoyLnN0cmluZygpKS5yZXR1cm5zKHoyLnByb21pc2UoejIuYm9vbGVhbigpKSk7XG52YXIgbG9hZFRyYW5zYWN0aW9uTWV0YVNjaGVtYSA9IHoyLmZ1bmN0aW9uKCkuYXJncyh6Mi5zdHJpbmcoKSkucmV0dXJucyh6Mi5wcm9taXNlKFxuICB6Mi5vYmplY3Qoe1xuICAgIHRhZ3M6IHoyLmFycmF5KHRhZ1NjaGVtYSlcbiAgfSkucGFzc3Rocm91Z2goKVxuKSk7XG52YXIgc2lnbmVyU2NoZW1hID0gejIuZnVuY3Rpb24oKS5hcmdzKHoyLm9iamVjdCh7XG4gIGRhdGE6IHoyLmFueSgpLFxuICB0YWdzOiB6Mi5hcnJheSh0YWdTY2hlbWEpLFxuICAvKipcbiAgICogdGFyZ2V0IG11c3QgYmUgc2V0IHdpdGggd3JpdGVNZXNzYWdlLFxuICAgKiBidXQgbm90IGZvciBjcmVhdGVQcm9jZXNzXG4gICAqL1xuICB0YXJnZXQ6IHoyLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGFuY2hvcjogejIuc3RyaW5nKCkub3B0aW9uYWwoKVxufSkpLnJldHVybnMoejIucHJvbWlzZShcbiAgejIub2JqZWN0KHtcbiAgICBpZDogejIuc3RyaW5nKCksXG4gICAgcmF3OiB6Mi5hbnkoKVxuICB9KVxuKSk7XG5cbi8vIHNyYy9saWIvcmVzdWx0L3JlYWQuanNcbmZ1bmN0aW9uIHJlYWRXaXRoKHsgbG9hZFJlc3VsdCB9KSB7XG4gIGxvYWRSZXN1bHQgPSBmcm9tUHJvbWlzZShsb2FkUmVzdWx0U2NoZW1hLmltcGxlbWVudChsb2FkUmVzdWx0KSk7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgcmV0dXJuIG9mKHsgaWQ6IGN0eC5pZCwgcHJvY2Vzc0lkOiBjdHgucHJvY2Vzc0lkIH0pLmNoYWluKGxvYWRSZXN1bHQpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL3Jlc3VsdC9pbmRleC5qc1xuZnVuY3Rpb24gcmVzdWx0V2l0aChlbnYpIHtcbiAgY29uc3QgdmVyaWZ5SW5wdXQgPSB2ZXJpZnlJbnB1dFdpdGgoZW52KTtcbiAgY29uc3QgcmVhZCA9IHJlYWRXaXRoKGVudik7XG4gIHJldHVybiAoeyBtZXNzYWdlOiBtZXNzYWdlMiwgcHJvY2VzczogcHJvY2VzczIgfSkgPT4ge1xuICAgIHJldHVybiBvZih7IGlkOiBtZXNzYWdlMiwgcHJvY2Vzc0lkOiBwcm9jZXNzMiB9KS5jaGFpbih2ZXJpZnlJbnB1dCkuY2hhaW4ocmVhZCkubWFwKFxuICAgICAgZW52LmxvZ2dlci50YXAoXG4gICAgICAgICdyZWFkUmVzdWx0IHJlc3VsdCBmb3IgbWVzc2FnZSBcIiVzXCI6ICVPJyxcbiAgICAgICAgbWVzc2FnZTJcbiAgICAgIClcbiAgICApLm1hcCgocmVzdWx0MikgPT4gcmVzdWx0MikuYmltYXAoZXJyRnJvbSwgaWRlbnRpdHlfZGVmYXVsdCkudG9Qcm9taXNlKCk7XG4gIH07XG59XG5cbi8vIG5vZGVfbW9kdWxlcy9AcGVybWF3ZWIvcHJvdG9jb2wtdGFnLXV0aWxzL2Rpc3QvaW5kZXguanNcbnZhciBwaXBlMiA9ICguLi5mbnMpID0+IChpKSA9PiBmbnMucmVkdWNlKChhY2MsIGZuMikgPT4gZm4yKGFjYyksIGkpO1xudmFyIGRlZmF1bHRUbzMgPSAoZFZhbCkgPT4gKHZhbCkgPT4gdmFsID09IG51bGwgPyBkVmFsIDogdmFsO1xudmFyIHByb3BPcjMgPSAoZGVmYXVsdFYpID0+IChwcm9wMykgPT4gcGlwZTIoXG4gIChvYmopID0+IG9iaiA/IG9ialtwcm9wM10gOiBvYmosXG4gIGRlZmF1bHRUbzMoZGVmYXVsdFYpXG4pO1xudmFyIG1hcE9iamVjdCA9IChmbjIpID0+IChvYmopID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgcmVzW2tleV0gPSBmbjIob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbnZhciBjb21wbGVtZW50ID0gKGZuMikgPT4gKC4uLmFyZ3MpID0+ICFmbjIoLi4uYXJncyk7XG52YXIgZmluZFByb3RvY29sQm91bmRhcmllcyA9IChwcm90b2NvbCkgPT4gKHRhZ3MpID0+IHtcbiAgY29uc3Qgc3RhcnRJZHggPSB0YWdzLmZpbmRJbmRleCgodCkgPT4gdC5uYW1lID09PSBcIkRhdGEtUHJvdG9jb2xcIiAmJiB0LnZhbHVlID09PSBwcm90b2NvbCk7XG4gIGlmIChzdGFydElkeCA9PT0gLTEpIHJldHVybiBbMCwgMF07XG4gIGxldCBlbmRJZHggPSB0YWdzLmZpbmRJbmRleCgodCwgaWR4KSA9PiBpZHggPiBzdGFydElkeCAmJiB0Lm5hbWUgPT09IFwiRGF0YS1Qcm90b2NvbFwiICYmIHQudmFsdWUgIT09IHByb3RvY29sKTtcbiAgaWYgKGVuZElkeCA9PT0gLTEpIGVuZElkeCA9IHRhZ3MubGVuZ3RoO1xuICByZXR1cm4gW3N0YXJ0SWR4LCBlbmRJZHhdO1xufTtcbnZhciBmaW5kRmlyc3RQcm90b2NvbEJvdW5kYXJ5ID0gKHRhZ3MpID0+IHtcbiAgbGV0IGlkeCA9IHRhZ3MuZmluZEluZGV4KCh0KSA9PiB0Lm5hbWUgPT09IFwiRGF0YS1Qcm90b2NvbFwiKTtcbiAgaWYgKGlkeCA9PT0gLTEpIGlkeCA9IHRhZ3MubGVuZ3RoO1xuICByZXR1cm4gaWR4O1xufTtcbnZhciBieU5hbWUgPSAobmFtZSkgPT4gKHQpID0+IHQubmFtZSA9PT0gbmFtZTtcbnZhciBmaW5kQWxsID0gKHByb3RvY29sLCB0YWdzKSA9PiBwaXBlMihcbiAgZmluZFByb3RvY29sQm91bmRhcmllcyhwcm90b2NvbCksXG4gIChbc3RhcnQsIGVuZF0pID0+IHRhZ3Muc2xpY2Uoc3RhcnQsIGVuZClcbikodGFncyk7XG52YXIgZmluZEFsbEJ5TmFtZSA9IChwcm90b2NvbCwgbmFtZSwgdGFncykgPT4gcGlwZTIoXG4gICh0YWdzMikgPT4gZmluZEFsbChwcm90b2NvbCwgdGFnczIpLFxuICAocFRhZ3MpID0+IHBUYWdzLmZpbHRlcihieU5hbWUobmFtZSkpXG4pKHRhZ3MpO1xudmFyIGZpbmRCeU5hbWUgPSAocHJvdG9jb2wsIG5hbWUsIHRhZ3MpID0+IHBpcGUyKFxuICAodGFnczIpID0+IGZpbmRBbGxCeU5hbWUocHJvdG9jb2wsIG5hbWUsIHRhZ3MyKSxcbiAgKGFycikgPT4gYXJyWzBdXG4pKHRhZ3MpO1xudmFyIGNyZWF0ZSA9IChwcm90b2NvbCwgcFRhZ3MpID0+IHtcbiAgcFRhZ3MgPSBwVGFncy5maWx0ZXIoKHQpID0+IHQubmFtZSAhPT0gXCJEYXRhLVByb3RvY29sXCIgfHwgdC52YWx1ZSAhPT0gcHJvdG9jb2wpO1xuICBpZiAoIXBUYWdzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICByZXR1cm4gW1xuICAgIHsgbmFtZTogXCJEYXRhLVByb3RvY29sXCIsIHZhbHVlOiBwcm90b2NvbCB9LFxuICAgIC4uLnBUYWdzXG4gIF07XG59O1xudmFyIGNvbmNhdDMgPSAocHJvdG9jb2wsIHBUYWdzLCB0YWdzKSA9PiB7XG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZpbmRQcm90b2NvbEJvdW5kYXJpZXMocHJvdG9jb2wpKHRhZ3MpO1xuICBsZXQgW2JlZm9yZSwgY3VyLCBhZnRlcl0gPSBbXG4gICAgdGFncy5zbGljZSgwLCBzdGFydCksXG4gICAgdGFncy5zbGljZShzdGFydCwgZW5kKSxcbiAgICB0YWdzLnNsaWNlKGVuZClcbiAgXTtcbiAgaWYgKCFjdXIubGVuZ3RoKSB7XG4gICAgcFRhZ3MgPSBjcmVhdGUocHJvdG9jb2wsIHBUYWdzKTtcbiAgICBiZWZvcmUgPSBhZnRlcjtcbiAgICBhZnRlciA9IFtdO1xuICB9XG4gIHJldHVybiBbYmVmb3JlLCBjdXIsIHBUYWdzLCBhZnRlcl0uZmxhdCgxKTtcbn07XG52YXIgY29uY2F0VW5hc3NvYyA9IChvdGhlcnMsIHRhZ3MpID0+IHtcbiAgY29uc3QgaWR4ID0gZmluZEZpcnN0UHJvdG9jb2xCb3VuZGFyeSh0YWdzKTtcbiAgY29uc3QgW2JlZm9yZSwgYWZ0ZXJdID0gW3RhZ3Muc2xpY2UoMCwgaWR4KSwgdGFncy5zbGljZShpZHgpXTtcbiAgcmV0dXJuIFtiZWZvcmUsIG90aGVycywgYWZ0ZXJdLmZsYXQoMSk7XG59O1xudmFyIHVwZGF0ZSA9IChwcm90b2NvbCwgcFRhZ3MsIHRhZ3MpID0+IHtcbiAgY29uc3QgW3N0YXJ0LCBlbmRdID0gZmluZFByb3RvY29sQm91bmRhcmllcyhwcm90b2NvbCkodGFncyk7XG4gIGxldCBbYmVmb3JlLCBhZnRlcl0gPSBbdGFncy5zbGljZSgwLCBzdGFydCksIHRhZ3Muc2xpY2UoZW5kKV07XG4gIGlmIChhZnRlci5sZW5ndGggPT09IHRhZ3MubGVuZ3RoKSB7XG4gICAgYmVmb3JlID0gYWZ0ZXI7XG4gICAgYWZ0ZXIgPSBbXTtcbiAgfVxuICByZXR1cm4gW2JlZm9yZSwgY3JlYXRlKHByb3RvY29sLCBwVGFncyksIGFmdGVyXS5mbGF0KDEpO1xufTtcbnZhciByZW1vdmVBbGwgPSAocHJvdG9jb2wsIHRhZ3MpID0+IHVwZGF0ZShwcm90b2NvbCwgW10sIHRhZ3MpO1xudmFyIHJlbW92ZUFsbEJ5TmFtZSA9IChwcm90b2NvbCwgbmFtZSwgdGFncykgPT4ge1xuICBjb25zdCBbc3RhcnQsIGVuZF0gPSBmaW5kUHJvdG9jb2xCb3VuZGFyaWVzKHByb3RvY29sKSh0YWdzKTtcbiAgY29uc3QgW2JlZm9yZSwgY3VyLCBhZnRlcl0gPSBbdGFncy5zbGljZSgwLCBzdGFydCksIHRhZ3Muc2xpY2Uoc3RhcnQsIGVuZCksIHRhZ3Muc2xpY2UoZW5kKV07XG4gIHJldHVybiBbYmVmb3JlLCBjcmVhdGUocHJvdG9jb2wsIGN1ci5maWx0ZXIoY29tcGxlbWVudChieU5hbWUobmFtZSkpKSksIGFmdGVyXS5mbGF0KDEpO1xufTtcbnZhciBwYXJzZVRhZ3MyID0gKHRhZ3MsIG11bHRpID0gZmFsc2UpID0+IHBpcGUyKFxuICBkZWZhdWx0VG8zKFtdKSxcbiAgLyoqXG4gICAqIE11dGF0aW9uIGlzIG9rYXkgaGVyZSwgc2luY2UgaXQnc1xuICAgKiBhbiBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZVxuICAgKi9cbiAgKHRhZ3MyKSA9PiB0YWdzMi5yZWR1Y2UoXG4gICAgKHBhcnNlZCwgdGFnKSA9PiBwaXBlMihcbiAgICAgIC8vIFt2YWx1ZSwgdmFsdWUsIC4uLl0gfHwgW11cbiAgICAgIHByb3BPcjMoW10pKHRhZy5uYW1lKSxcbiAgICAgIC8vIFt2YWx1ZV1cbiAgICAgIChhcnIpID0+IHtcbiAgICAgICAgYXJyLnB1c2godGFnLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICAvLyB7IFtuYW1lXTogW3ZhbHVlLCB2YWx1ZSwgLi4uXSB9XG4gICAgICAoYXJyKSA9PiB7XG4gICAgICAgIHBhcnNlZFt0YWcubmFtZV0gPSBhcnI7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgKShwYXJzZWQpLFxuICAgIHt9XG4gICksXG4gIG1hcE9iamVjdCgodmFsdWVzKSA9PiBtdWx0aSA/IHZhbHVlcyA6IHZhbHVlc1swXSlcbikodGFncyk7XG52YXIgcGFyc2VQcm90b2NvbCA9IChwcm90b2NvbCwgdGFncywgbXVsdGkpID0+IHBpcGUyKFxuICBkZWZhdWx0VG8zKFtdKSxcbiAgKHRhZ3MyKSA9PiBmaW5kQWxsKHByb3RvY29sLCB0YWdzMiksXG4gICh0YWdzMikgPT4gcGFyc2VUYWdzMih0YWdzMiwgbXVsdGkpXG4pKHRhZ3MpO1xudmFyIHBhcnNlQWxsID0gKHByb3RvY29sLCB0YWdzKSA9PiBwYXJzZVByb3RvY29sKHByb3RvY29sLCB0YWdzLCB0cnVlKTtcbnZhciBwYXJzZSA9IChwcm90b2NvbCwgdGFncykgPT4gcGFyc2VQcm90b2NvbChwcm90b2NvbCwgdGFncywgZmFsc2UpO1xudmFyIHBhcnNlVW5hc3NvYyA9ICh0YWdzKSA9PiB7XG4gIGNvbnN0IGlkeCA9IGZpbmRGaXJzdFByb3RvY29sQm91bmRhcnkodGFncyk7XG4gIHJldHVybiBwYXJzZVRhZ3MyKHRhZ3Muc2xpY2UoMCwgaWR4KSwgZmFsc2UpO1xufTtcbnZhciBwYXJzZUFsbFVuYXNzb2MgPSAodGFncykgPT4ge1xuICBjb25zdCBpZHggPSBmaW5kRmlyc3RQcm90b2NvbEJvdW5kYXJ5KHRhZ3MpO1xuICByZXR1cm4gcGFyc2VUYWdzMih0YWdzLnNsaWNlKDAsIGlkeCksIHRydWUpO1xufTtcbnZhciBwcm90byA9IChwMikgPT4gKHtcbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5SZW1vdmVGaXJzdEFyZzxmaW5kQWxsPn1cbiAgICovXG4gIGZpbmRBbGw6ICh0YWdzKSA9PiBmaW5kQWxsKHAyLCB0YWdzKSxcbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5SZW1vdmVGaXJzdEFyZzxmaW5kQWxsQnlOYW1lPn1cbiAgICovXG4gIGZpbmRBbGxCeU5hbWU6IChuYW1lLCB0YWdzKSA9PiBmaW5kQWxsQnlOYW1lKHAyLCBuYW1lLCB0YWdzKSxcbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5SZW1vdmVGaXJzdEFyZzxmaW5kQnlOYW1lPn1cbiAgICovXG4gIGZpbmRCeU5hbWU6IChuYW1lLCB0YWdzKSA9PiBmaW5kQnlOYW1lKHAyLCBuYW1lLCB0YWdzKSxcbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5SZW1vdmVGaXJzdEFyZzxjcmVhdGU+fVxuICAgKi9cbiAgY3JlYXRlOiAodGFncykgPT4gY3JlYXRlKHAyLCB0YWdzKSxcbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMnKS5SZW1vdmVGaXJzdEFyZzx1cGRhdGU+fVxuICAgKi9cbiAgdXBkYXRlOiAocFRhZ3MsIHRhZ3MpID0+IHVwZGF0ZShwMiwgcFRhZ3MsIHRhZ3MpLFxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi90eXBlcycpLlJlbW92ZUZpcnN0QXJnPGNvbmNhdD59XG4gICAqL1xuICBjb25jYXQ6IChwVGFncywgdGFncykgPT4gY29uY2F0MyhwMiwgcFRhZ3MsIHRhZ3MpLFxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi90eXBlcycpLlJlbW92ZUZpcnN0QXJnPHJlbW92ZUFsbD59XG4gICAqL1xuICByZW1vdmVBbGw6ICh0YWdzKSA9PiByZW1vdmVBbGwocDIsIHRhZ3MpLFxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi90eXBlcycpLlJlbW92ZUZpcnN0QXJnPHJlbW92ZUFsbEJ5TmFtZT59XG4gICAqL1xuICByZW1vdmVBbGxCeU5hbWU6IChuYW1lLCB0YWdzKSA9PiByZW1vdmVBbGxCeU5hbWUocDIsIG5hbWUsIHRhZ3MpLFxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi90eXBlcycpLlJlbW92ZUZpcnN0QXJnPHBhcnNlPn1cbiAgICovXG4gIHBhcnNlOiAodGFncykgPT4gcGFyc2UocDIsIHRhZ3MpLFxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi90eXBlcycpLlJlbW92ZUZpcnN0QXJnPHBhcnNlQWxsPn1cbiAgICovXG4gIHBhcnNlQWxsOiAodGFncykgPT4gcGFyc2VBbGwocDIsIHRhZ3MpLFxuICBjb25jYXRVbmFzc29jLFxuICBwYXJzZVVuYXNzb2MsXG4gIHBhcnNlQWxsVW5hc3NvY1xufSk7XG5cbi8vIHNyYy9saWIvbWVzc2FnZS91cGxvYWQtbWVzc2FnZS5qc1xudmFyIGFvUHJvdG8gPSBwcm90byhcImFvXCIpO1xudmFyIHJlbW92ZUFvUHJvdG9CeU5hbWUgPSBjdXJyeV9kZWZhdWx0KGFvUHJvdG8ucmVtb3ZlQWxsQnlOYW1lKTtcbnZhciBjb25jYXRBb1Byb3RvID0gY3VycnlfZGVmYXVsdChhb1Byb3RvLmNvbmNhdCk7XG52YXIgY29uY2F0VW5hc3NvYzIgPSBjdXJyeV9kZWZhdWx0KGFvUHJvdG8uY29uY2F0VW5hc3NvYyk7XG52YXIgdGFnU2NoZW1hMiA9IHoyLmFycmF5KHoyLm9iamVjdCh7XG4gIG5hbWU6IHoyLnN0cmluZygpLFxuICB2YWx1ZTogejIuc3RyaW5nKClcbn0pKTtcbmZ1bmN0aW9uIGJ1aWxkVGFnc1dpdGgoKSB7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgcmV0dXJuIG9mKGN0eC50YWdzKS5tYXAoZGVmYXVsdFRvX2RlZmF1bHQoW10pKS5tYXAocmVtb3ZlQW9Qcm90b0J5TmFtZShcIlZhcmlhbnRcIikpLm1hcChyZW1vdmVBb1Byb3RvQnlOYW1lKFwiVHlwZVwiKSkubWFwKGNvbmNhdEFvUHJvdG8oW1xuICAgICAgeyBuYW1lOiBcIlZhcmlhbnRcIiwgdmFsdWU6IFwiYW8uVE4uMVwiIH0sXG4gICAgICB7IG5hbWU6IFwiVHlwZVwiLCB2YWx1ZTogXCJNZXNzYWdlXCIgfVxuICAgIF0pKS5tYXAodGFnU2NoZW1hMi5wYXJzZSkubWFwKGFzc29jX2RlZmF1bHQoXCJ0YWdzXCIsIF9fZGVmYXVsdCwgY3R4KSk7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZERhdGFXaXRoKHsgbG9nZ2VyIH0pIHtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICByZXR1cm4gb2YoY3R4KS5jaGFpbihpZkVsc2VfZGVmYXVsdChcbiAgICAgIGFsd2F5c19kZWZhdWx0KGN0eC5kYXRhKSxcbiAgICAgIC8qKlxuICAgICAgICogZGF0YSBpcyBwcm92aWRlZCBhcyBpbnB1dCwgc28gZG8gbm90aGluZ1xuICAgICAgICovXG4gICAgICAoKSA9PiBSZXNvbHZlZChjdHgpLFxuICAgICAgLyoqXG4gICAgICAgKiBObyBkYXRhIGlzIHByb3ZpZGVkLCBzbyByZXBsYWNlIHdpdGggb25lIHNwYWNlXG4gICAgICAgKi9cbiAgICAgICgpID0+IFJlc29sdmVkKFwiIFwiKS5tYXAoYXNzb2NfZGVmYXVsdChcImRhdGFcIiwgX19kZWZhdWx0LCBjdHgpKS5tYXAoXG4gICAgICAgIChjdHgyKSA9PiBwaXBlKFxuICAgICAgICAgIHByb3BfZGVmYXVsdChcInRhZ3NcIiksXG4gICAgICAgICAgY29uY2F0VW5hc3NvYzIoW3sgbmFtZTogXCJDb250ZW50LVR5cGVcIiwgdmFsdWU6IFwidGV4dC9wbGFpblwiIH1dKSxcbiAgICAgICAgICBhc3NvY19kZWZhdWx0KFwidGFnc1wiLCBfX2RlZmF1bHQsIGN0eDIpXG4gICAgICAgICkoY3R4MilcbiAgICAgICkubWFwKGxvZ2dlci50YXAoJ2FkZGVkIHBzZXVkby1yYW5kb20gc3RyaW5nIGFzIG1lc3NhZ2UgXCJkYXRhXCInKSlcbiAgICApKS5tYXAoXG4gICAgICAoY3R4MikgPT4gcGlwZShcbiAgICAgICAgcHJvcF9kZWZhdWx0KFwidGFnc1wiKSxcbiAgICAgICAgY29uY2F0VW5hc3NvYzIoW3sgbmFtZTogXCJTREtcIiwgdmFsdWU6IFwiYW9jb25uZWN0XCIgfV0pLFxuICAgICAgICBhc3NvY19kZWZhdWx0KFwidGFnc1wiLCBfX2RlZmF1bHQsIGN0eDIpXG4gICAgICApKGN0eDIpXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwbG9hZE1lc3NhZ2VXaXRoKGVudikge1xuICBjb25zdCBidWlsZFRhZ3MgPSBidWlsZFRhZ3NXaXRoKGVudik7XG4gIGNvbnN0IGJ1aWxkRGF0YSA9IGJ1aWxkRGF0YVdpdGgoZW52KTtcbiAgY29uc3QgZGVwbG95TWVzc2FnZSA9IGRlcGxveU1lc3NhZ2VTY2hlbWEuaW1wbGVtZW50KGVudi5kZXBsb3lNZXNzYWdlKTtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICByZXR1cm4gb2YoY3R4KS5jaGFpbihidWlsZFRhZ3MpLmNoYWluKGJ1aWxkRGF0YSkuY2hhaW4oZnJvbVByb21pc2UoXG4gICAgICAoeyBpZCwgZGF0YSwgdGFncywgYW5jaG9yLCBzaWduZXIgfSkgPT4gZGVwbG95TWVzc2FnZSh7IHByb2Nlc3NJZDogaWQsIGRhdGEsIHRhZ3MsIGFuY2hvciwgc2lnbmVyOiBzaWduZXJTY2hlbWEuaW1wbGVtZW50KHNpZ25lcikgfSlcbiAgICApKS5tYXAoKHJlcykgPT4gYXNzb2NfZGVmYXVsdChcIm1lc3NhZ2VJZFwiLCByZXMubWVzc2FnZUlkLCBjdHgpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9tZXNzYWdlL2luZGV4LmpzXG5mdW5jdGlvbiBtZXNzYWdlV2l0aChlbnYpIHtcbiAgY29uc3QgdXBsb2FkTWVzc2FnZSA9IHVwbG9hZE1lc3NhZ2VXaXRoKGVudik7XG4gIHJldHVybiAoeyBwcm9jZXNzOiBwcm9jZXNzMiwgZGF0YSwgdGFncywgYW5jaG9yLCBzaWduZXIgfSkgPT4ge1xuICAgIHJldHVybiBvZih7IGlkOiBwcm9jZXNzMiwgZGF0YSwgdGFncywgYW5jaG9yLCBzaWduZXIgfSkuY2hhaW4odXBsb2FkTWVzc2FnZSkubWFwKChjdHgpID0+IGN0eC5tZXNzYWdlSWQpLmJpbWFwKGVyckZyb20sIGlkZW50aXR5X2RlZmF1bHQpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL3NwYXduL3ZlcmlmeS1pbnB1dHMuanNcbnZhciBjaGVja1RhZyA9IChuYW1lLCBwcmVkLCBlcnIpID0+ICh0YWdzKSA9PiBwcmVkKHRhZ3NbbmFtZV0pID8gUmVzb2x2ZWQodGFncykgOiBSZWplY3RlZChgVGFnICcke25hbWV9JzogJHtlcnJ9YCk7XG5mdW5jdGlvbiB2ZXJpZnlNb2R1bGVXaXRoKHsgbG9hZFRyYW5zYWN0aW9uTWV0YSwgbG9nZ2VyIH0pIHtcbiAgbG9hZFRyYW5zYWN0aW9uTWV0YSA9IGZyb21Qcm9taXNlKGxvYWRUcmFuc2FjdGlvbk1ldGFTY2hlbWEuaW1wbGVtZW50KGxvYWRUcmFuc2FjdGlvbk1ldGEpKTtcbiAgcmV0dXJuIChtb2R1bGUpID0+IG9mKG1vZHVsZSkuY2hhaW4obG9hZFRyYW5zYWN0aW9uTWV0YSkubWFwKHByb3BfZGVmYXVsdChcInRhZ3NcIikpLm1hcChwYXJzZVRhZ3MpLmNoYWluKGNoZWNrVGFnKFwiRGF0YS1Qcm90b2NvbFwiLCBlcU9ySW5jbHVkZXMoXCJhb1wiKSwgXCJ2YWx1ZSAnYW8nIHdhcyBub3QgZm91bmQgb24gbW9kdWxlXCIpKS5jaGFpbihjaGVja1RhZyhcIlR5cGVcIiwgZXFPckluY2x1ZGVzKFwiTW9kdWxlXCIpLCBcInZhbHVlICdNb2R1bGUnIHdhcyBub3QgZm91bmQgb24gbW9kdWxlXCIpKS5jaGFpbihjaGVja1RhZyhcIk1vZHVsZS1Gb3JtYXRcIiwgaXNOb3ROaWxfZGVmYXVsdCwgXCJ3YXMgbm90IGZvdW5kIG9uIG1vZHVsZVwiKSkuY2hhaW4oY2hlY2tUYWcoXCJJbnB1dC1FbmNvZGluZ1wiLCBpc05vdE5pbF9kZWZhdWx0LCBcIndhcyBub3QgZm91bmQgb24gbW9kdWxlXCIpKS5jaGFpbihjaGVja1RhZyhcIk91dHB1dC1FbmNvZGluZ1wiLCBpc05vdE5pbF9kZWZhdWx0LCBcIndhcyBub3QgZm91bmQgb24gbW9kdWxlXCIpKS5iaW1hcChcbiAgICBsb2dnZXIudGFwKFwiVmVyaWZ5aW5nIG1vZHVsZSBzb3VyY2UgZmFpbGVkOiAlc1wiKSxcbiAgICBsb2dnZXIudGFwKFwiVmVyaWZpZWQgbW9kdWxlIHNvdXJjZVwiKVxuICApO1xufVxuZnVuY3Rpb24gdmVyaWZ5U2NoZWR1bGVyV2l0aCh7IGxvZ2dlciwgdmFsaWRhdGVTY2hlZHVsZXIgfSkge1xuICB2YWxpZGF0ZVNjaGVkdWxlciA9IGZyb21Qcm9taXNlKHZhbGlkYXRlU2NoZWR1bGVyU2NoZW1hLmltcGxlbWVudCh2YWxpZGF0ZVNjaGVkdWxlcikpO1xuICByZXR1cm4gKHNjaGVkdWxlcikgPT4gb2Yoc2NoZWR1bGVyKS5jaGFpbihcbiAgICAoc2NoZWR1bGVyMikgPT4gdmFsaWRhdGVTY2hlZHVsZXIoc2NoZWR1bGVyMikuY2hhaW4oKGlzVmFsaWQyKSA9PiBpc1ZhbGlkMiA/IFJlc29sdmVkKHNjaGVkdWxlcjIpIDogUmVqZWN0ZWQoYFZhbGlkIFNjaGVkdWxlci1Mb2NhdGlvbiBvd25lZCBieSAke3NjaGVkdWxlcjJ9IG5vdCBmb3VuZGApKVxuICApLmJpbWFwKFxuICAgIGxvZ2dlci50YXAoXCJWZXJpZnlpbmcgc2NoZWR1bGVyIGZhaWxlZDogJXNcIiksXG4gICAgbG9nZ2VyLnRhcChcIlZlcmlmaWVkIHNjaGVkdWxlclwiKVxuICApO1xufVxuZnVuY3Rpb24gdmVyaWZ5U2lnbmVyV2l0aCh7IGxvZ2dlciB9KSB7XG4gIHJldHVybiAoc2lnbmVyKSA9PiBvZihzaWduZXIpLm1hcChsb2dnZXIudGFwKFwiQ2hlY2tpbmcgZm9yIHNpZ25lclwiKSkuY2hhaW4oKHNpZ25lcjIpID0+IHNpZ25lcjIgPyBSZXNvbHZlZChzaWduZXIyKSA6IFJlamVjdGVkKFwic2lnbmVyIG5vdCBmb3VuZFwiKSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlJbnB1dHNXaXRoKGVudikge1xuICBjb25zdCBsb2dnZXIgPSBlbnYubG9nZ2VyLmNoaWxkKFwidmVyaWZ5SW5wdXRcIik7XG4gIGVudiA9IHsgLi4uZW52LCBsb2dnZXIgfTtcbiAgY29uc3QgdmVyaWZ5TW9kdWxlID0gdmVyaWZ5TW9kdWxlV2l0aChlbnYpO1xuICBjb25zdCB2ZXJpZnlTY2hlZHVsZXIgPSB2ZXJpZnlTY2hlZHVsZXJXaXRoKGVudik7XG4gIGNvbnN0IHZlcmlmeVNpZ25lciA9IHZlcmlmeVNpZ25lcldpdGgoZW52KTtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICByZXR1cm4gb2YoY3R4KS5jaGFpbigoY3R4MikgPT4gdmVyaWZ5TW9kdWxlKGN0eDIubW9kdWxlKS5tYXAoKCkgPT4gY3R4MikpLmNoYWluKChjdHgyKSA9PiB2ZXJpZnlTY2hlZHVsZXIoY3R4Mi5zY2hlZHVsZXIpKS5tYXAoKCkgPT4gY3R4KS5jaGFpbigoY3R4MikgPT4gdmVyaWZ5U2lnbmVyKGN0eDIuc2lnbmVyKS5tYXAoKCkgPT4gY3R4MikpLmJpbWFwKFxuICAgICAgbG9nZ2VyLnRhcChcIkVycm9yIHdoZW4gdmVyaWZ5IGlucHV0OiAlc1wiKSxcbiAgICAgIGxvZ2dlci50YXAoXCJTdWNjZXNzZnVsbHkgdmVyaWZpZWQgaW5wdXRzXCIpXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9zcGF3bi91cGxvYWQtcHJvY2Vzcy5qc1xudmFyIGFvUHJvdG8yID0gcHJvdG8oXCJhb1wiKTtcbnZhciByZW1vdmVBb1Byb3RvQnlOYW1lMiA9IGN1cnJ5X2RlZmF1bHQoYW9Qcm90bzIucmVtb3ZlQWxsQnlOYW1lKTtcbnZhciBjb25jYXRBb1Byb3RvMiA9IGN1cnJ5X2RlZmF1bHQoYW9Qcm90bzIuY29uY2F0KTtcbnZhciBjb25jYXRVbmFzc29jMyA9IGN1cnJ5X2RlZmF1bHQoYW9Qcm90bzIuY29uY2F0VW5hc3NvYyk7XG52YXIgdGFnU2NoZW1hMyA9IHoyLmFycmF5KHoyLm9iamVjdCh7XG4gIG5hbWU6IHoyLnN0cmluZygpLFxuICB2YWx1ZTogejIuc3RyaW5nKClcbn0pKTtcbmZ1bmN0aW9uIGJ1aWxkVGFnc1dpdGgyKCkge1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHJldHVybiBvZihjdHgpLm1hcChwcm9wX2RlZmF1bHQoXCJ0YWdzXCIpKS5tYXAoZGVmYXVsdFRvX2RlZmF1bHQoW10pKS5tYXAocmVtb3ZlQW9Qcm90b0J5TmFtZTIoXCJWYXJpYW50XCIpKS5tYXAocmVtb3ZlQW9Qcm90b0J5TmFtZTIoXCJUeXBlXCIpKS5tYXAocmVtb3ZlQW9Qcm90b0J5TmFtZTIoXCJNb2R1bGVcIikpLm1hcChyZW1vdmVBb1Byb3RvQnlOYW1lMihcIlNjaGVkdWxlclwiKSkubWFwKGNvbmNhdEFvUHJvdG8yKFtcbiAgICAgIHsgbmFtZTogXCJWYXJpYW50XCIsIHZhbHVlOiBcImFvLlROLjFcIiB9LFxuICAgICAgeyBuYW1lOiBcIlR5cGVcIiwgdmFsdWU6IFwiUHJvY2Vzc1wiIH0sXG4gICAgICB7IG5hbWU6IFwiTW9kdWxlXCIsIHZhbHVlOiBjdHgubW9kdWxlIH0sXG4gICAgICB7IG5hbWU6IFwiU2NoZWR1bGVyXCIsIHZhbHVlOiBjdHguc2NoZWR1bGVyIH1cbiAgICBdKSkubWFwKHRhZ1NjaGVtYTMucGFyc2UpLm1hcChhc3NvY19kZWZhdWx0KFwidGFnc1wiLCBfX2RlZmF1bHQsIGN0eCkpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREYXRhV2l0aDIoeyBsb2dnZXIgfSkge1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHJldHVybiBvZihjdHgpLmNoYWluKGlmRWxzZV9kZWZhdWx0KFxuICAgICAgYWx3YXlzX2RlZmF1bHQoY3R4LmRhdGEpLFxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhIGlzIHByb3ZpZGVkIGFzIGlucHV0LCBzbyBkbyBub3RoaW5nXG4gICAgICAgKi9cbiAgICAgICgpID0+IFJlc29sdmVkKGN0eCksXG4gICAgICAvKipcbiAgICAgICAqIE5vIGRhdGEgaXMgcHJvdmlkZWQsIHNvIHJlcGxhY2Ugd2l0aCBvbmUgc3BhY2VcbiAgICAgICAqL1xuICAgICAgKCkgPT4gUmVzb2x2ZWQoXCIgXCIpLm1hcChhc3NvY19kZWZhdWx0KFwiZGF0YVwiLCBfX2RlZmF1bHQsIGN0eCkpLm1hcChcbiAgICAgICAgKGN0eDIpID0+IHBpcGUoXG4gICAgICAgICAgcHJvcF9kZWZhdWx0KFwidGFnc1wiKSxcbiAgICAgICAgICBjb25jYXRVbmFzc29jMyhbeyBuYW1lOiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJ0ZXh0L3BsYWluXCIgfV0pLFxuICAgICAgICAgIGFzc29jX2RlZmF1bHQoXCJ0YWdzXCIsIF9fZGVmYXVsdCwgY3R4MilcbiAgICAgICAgKShjdHgyKVxuICAgICAgKS5tYXAobG9nZ2VyLnRhcCgnYWRkZWQgcHNldWRvLXJhbmRvbSBzdHJpbmcgYXMgcHJvY2VzcyBcImRhdGFcIicpKVxuICAgICkpLm1hcChcbiAgICAgIChjdHgyKSA9PiBwaXBlKFxuICAgICAgICBwcm9wX2RlZmF1bHQoXCJ0YWdzXCIpLFxuICAgICAgICBjb25jYXRVbmFzc29jMyhbeyBuYW1lOiBcIlNES1wiLCB2YWx1ZTogXCJhb2Nvbm5lY3RcIiB9XSksXG4gICAgICAgIGFzc29jX2RlZmF1bHQoXCJ0YWdzXCIsIF9fZGVmYXVsdCwgY3R4MilcbiAgICAgICkoY3R4MilcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gdXBsb2FkUHJvY2Vzc1dpdGgoZW52KSB7XG4gIGNvbnN0IGxvZ2dlciA9IGVudi5sb2dnZXIuY2hpbGQoXCJ1cGxvYWRQcm9jZXNzXCIpO1xuICBlbnYgPSB7IC4uLmVudiwgbG9nZ2VyIH07XG4gIGNvbnN0IGJ1aWxkVGFncyA9IGJ1aWxkVGFnc1dpdGgyKGVudik7XG4gIGNvbnN0IGJ1aWxkRGF0YSA9IGJ1aWxkRGF0YVdpdGgyKGVudik7XG4gIGNvbnN0IGRlcGxveVByb2Nlc3MgPSBkZXBsb3lQcm9jZXNzU2NoZW1hLmltcGxlbWVudChlbnYuZGVwbG95UHJvY2Vzcyk7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgcmV0dXJuIG9mKGN0eCkuY2hhaW4oYnVpbGRUYWdzKS5jaGFpbihidWlsZERhdGEpLmNoYWluKGZyb21Qcm9taXNlKFxuICAgICAgKHsgZGF0YSwgdGFncywgc2lnbmVyIH0pID0+IGRlcGxveVByb2Nlc3MoeyBkYXRhLCB0YWdzLCBzaWduZXI6IHNpZ25lclNjaGVtYS5pbXBsZW1lbnQoc2lnbmVyKSB9KVxuICAgICkpLm1hcCgocmVzKSA9PiBhc3NvY19kZWZhdWx0KFwicHJvY2Vzc0lkXCIsIHJlcy5wcm9jZXNzSWQsIGN0eCkpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL3NwYXduL2luZGV4LmpzXG5mdW5jdGlvbiBzcGF3bldpdGgoZW52KSB7XG4gIGNvbnN0IHZlcmlmeUlucHV0cyA9IHZlcmlmeUlucHV0c1dpdGgoZW52KTtcbiAgY29uc3QgdXBsb2FkUHJvY2VzcyA9IHVwbG9hZFByb2Nlc3NXaXRoKGVudik7XG4gIHJldHVybiAoeyBtb2R1bGUsIHNjaGVkdWxlciwgc2lnbmVyLCB0YWdzLCBkYXRhIH0pID0+IHtcbiAgICByZXR1cm4gb2YoeyBtb2R1bGUsIHNjaGVkdWxlciwgc2lnbmVyLCB0YWdzLCBkYXRhIH0pLmNoYWluKHZlcmlmeUlucHV0cykuY2hhaW4odXBsb2FkUHJvY2VzcykubWFwKChjdHgpID0+IGN0eC5wcm9jZXNzSWQpLmJpbWFwKGVyckZyb20sIGlkZW50aXR5X2RlZmF1bHQpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL21vbml0b3IvdXBsb2FkLW1vbml0b3IuanNcbmZ1bmN0aW9uIHVwbG9hZE1vbml0b3JXaXRoKGVudikge1xuICBjb25zdCBkZXBsb3lNb25pdG9yID0gZGVwbG95TW9uaXRvclNjaGVtYS5pbXBsZW1lbnQoZW52LmRlcGxveU1vbml0b3IpO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHJldHVybiBvZihjdHgpLmNoYWluKGZyb21Qcm9taXNlKFxuICAgICAgKHsgaWQsIHNpZ25lciB9KSA9PiBkZXBsb3lNb25pdG9yKHtcbiAgICAgICAgcHJvY2Vzc0lkOiBpZCxcbiAgICAgICAgc2lnbmVyOiBzaWduZXJTY2hlbWEuaW1wbGVtZW50KHNpZ25lciksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBObyB0YWdzIG9yIGRhdGEgY2FuIGJlIHByb3ZpZGVkIHJpZ2h0IG5vdyxcbiAgICAgICAgICpcbiAgICAgICAgICogc28ganVzdCBzZXQgZGF0YSB0byBzaW5nbGUgc3BhY2UgYW5kIHNldCB0YWdzIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhOiBcIiBcIixcbiAgICAgICAgdGFnczogW11cbiAgICAgIH0pXG4gICAgKSkubWFwKChyZXMpID0+IGFzc29jX2RlZmF1bHQoXCJtb25pdG9ySWRcIiwgcmVzLm1lc3NhZ2VJZCwgY3R4KSk7XG4gIH07XG59XG5cbi8vIHNyYy9saWIvbW9uaXRvci9pbmRleC5qc1xuZnVuY3Rpb24gbW9uaXRvcldpdGgoZW52KSB7XG4gIGNvbnN0IHVwbG9hZE1vbml0b3IgPSB1cGxvYWRNb25pdG9yV2l0aChlbnYpO1xuICByZXR1cm4gKHsgcHJvY2VzczogcHJvY2VzczIsIHNpZ25lciB9KSA9PiBvZih7IGlkOiBwcm9jZXNzMiwgc2lnbmVyIH0pLmNoYWluKHVwbG9hZE1vbml0b3IpLm1hcCgoY3R4KSA9PiBjdHgubW9uaXRvcklkKS5iaW1hcChlcnJGcm9tLCBpZGVudGl0eV9kZWZhdWx0KS50b1Byb21pc2UoKTtcbn1cblxuLy8gc3JjL2xpYi91bm1vbml0b3IvdXBsb2FkLXVubW9uaXRvci5qc1xuZnVuY3Rpb24gdXBsb2FkVW5tb25pdG9yV2l0aChlbnYpIHtcbiAgY29uc3QgZGVwbG95VW5tb25pdG9yID0gZGVwbG95TW9uaXRvclNjaGVtYS5pbXBsZW1lbnQoZW52LmRlcGxveVVubW9uaXRvcik7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgcmV0dXJuIG9mKGN0eCkuY2hhaW4oZnJvbVByb21pc2UoXG4gICAgICAoeyBpZCwgc2lnbmVyIH0pID0+IGRlcGxveVVubW9uaXRvcih7XG4gICAgICAgIHByb2Nlc3NJZDogaWQsXG4gICAgICAgIHNpZ25lcjogc2lnbmVyU2NoZW1hLmltcGxlbWVudChzaWduZXIpLFxuICAgICAgICAvKipcbiAgICAgICAgICogTm8gdGFncyBvciBkYXRhIGNhbiBiZSBwcm92aWRlZCByaWdodCBub3csXG4gICAgICAgICAqXG4gICAgICAgICAqIHNvIGp1c3Qgc2V0IGRhdGEgdG8gc2luZ2xlIHNwYWNlIGFuZCBzZXQgdGFncyB0byBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YTogXCIgXCIsXG4gICAgICAgIHRhZ3M6IFtdXG4gICAgICB9KVxuICAgICkpLm1hcCgocmVzKSA9PiBhc3NvY19kZWZhdWx0KFwibW9uaXRvcklkXCIsIHJlcy5tZXNzYWdlSWQsIGN0eCkpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL3VubW9uaXRvci9pbmRleC5qc1xuZnVuY3Rpb24gdW5tb25pdG9yV2l0aChlbnYpIHtcbiAgY29uc3QgdXBsb2FkVW5tb25pdG9yID0gdXBsb2FkVW5tb25pdG9yV2l0aChlbnYpO1xuICByZXR1cm4gKHsgcHJvY2VzczogcHJvY2VzczIsIHNpZ25lciB9KSA9PiBvZih7IGlkOiBwcm9jZXNzMiwgc2lnbmVyIH0pLmNoYWluKHVwbG9hZFVubW9uaXRvcikubWFwKChjdHgpID0+IGN0eC5tb25pdG9ySWQpLmJpbWFwKGVyckZyb20sIGlkZW50aXR5X2RlZmF1bHQpLnRvUHJvbWlzZSgpO1xufVxuXG4vLyBzcmMvbGliL3Jlc3VsdHMvdmVyaWZ5LWlucHV0LmpzXG52YXIgaW5wdXRTY2hlbWEyID0gejIub2JqZWN0KHtcbiAgcHJvY2VzczogejIuc3RyaW5nKCkubWluKDEsIHsgbWVzc2FnZTogXCJwcm9jZXNzIGlkZW50aWZpZXIgaXMgcmVxdWlyZWRcIiB9KSxcbiAgZnJvbTogejIuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdG86IHoyLnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHNvcnQ6IHoyLmVudW0oW1wiQVNDXCIsIFwiREVTQ1wiXSkuZGVmYXVsdChcIkFTQ1wiKSxcbiAgbGltaXQ6IHoyLm51bWJlcigpLm9wdGlvbmFsKClcbn0pO1xuZnVuY3Rpb24gdmVyaWZ5SW5wdXRXaXRoMigpIHtcbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICByZXR1cm4gb2YoY3R4KS5tYXAoaW5wdXRTY2hlbWEyLnBhcnNlKS5tYXAoKCkgPT4gY3R4KTtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9yZXN1bHRzL3F1ZXJ5LmpzXG5mdW5jdGlvbiBxdWVyeVdpdGgoeyBxdWVyeVJlc3VsdHMgfSkge1xuICBxdWVyeVJlc3VsdHMgPSBmcm9tUHJvbWlzZShxdWVyeVJlc3VsdHNTY2hlbWEuaW1wbGVtZW50KHF1ZXJ5UmVzdWx0cykpO1xuICByZXR1cm4gKGN0eCkgPT4ge1xuICAgIHJldHVybiBvZih7IHByb2Nlc3M6IGN0eC5wcm9jZXNzLCBmcm9tOiBjdHguZnJvbSwgdG86IGN0eC50bywgc29ydDogY3R4LnNvcnQsIGxpbWl0OiBjdHgubGltaXQgfSkuY2hhaW4ocXVlcnlSZXN1bHRzKTtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9yZXN1bHRzL2luZGV4LmpzXG5mdW5jdGlvbiByZXN1bHRzV2l0aChlbnYpIHtcbiAgY29uc3QgdmVyaWZ5SW5wdXQgPSB2ZXJpZnlJbnB1dFdpdGgyKGVudik7XG4gIGNvbnN0IHF1ZXJ5ID0gcXVlcnlXaXRoKGVudik7XG4gIHJldHVybiAoeyBwcm9jZXNzOiBwcm9jZXNzMiwgZnJvbSwgdG8sIHNvcnQsIGxpbWl0IH0pID0+IHtcbiAgICByZXR1cm4gb2YoeyBwcm9jZXNzOiBwcm9jZXNzMiwgZnJvbSwgdG8sIHNvcnQsIGxpbWl0IH0pLmNoYWluKHZlcmlmeUlucHV0KS5jaGFpbihxdWVyeSkubWFwKFxuICAgICAgZW52LmxvZ2dlci50YXAoXG4gICAgICAgICdyZWFkUmVzdWx0cyByZXN1bHQgZm9yIG1lc3NhZ2UgXCIlc1wiOiAlTycsXG4gICAgICAgIHByb2Nlc3MyXG4gICAgICApXG4gICAgKS5tYXAoKHJlc3VsdDIpID0+IHJlc3VsdDIpLmJpbWFwKGVyckZyb20sIGlkZW50aXR5X2RlZmF1bHQpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2RyeXJ1bi92ZXJpZnktaW5wdXQuanNcbnZhciBpbnB1dFNjaGVtYTMgPSB6Mi5vYmplY3Qoe1xuICBJZDogejIuc3RyaW5nKCksXG4gIFRhcmdldDogejIuc3RyaW5nKCksXG4gIE93bmVyOiB6Mi5zdHJpbmcoKSxcbiAgQW5jaG9yOiB6Mi5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBEYXRhOiB6Mi5hbnkoKS5kZWZhdWx0KFwiMTIzNFwiKSxcbiAgVGFnczogejIuYXJyYXkoejIub2JqZWN0KHsgbmFtZTogejIuc3RyaW5nKCksIHZhbHVlOiB6Mi5zdHJpbmcoKSB9KSlcbn0pO1xuZnVuY3Rpb24gdmVyaWZ5SW5wdXRXaXRoMygpIHtcbiAgcmV0dXJuIChtc2cpID0+IHtcbiAgICByZXR1cm4gb2YobXNnKS5tYXAoaW5wdXRTY2hlbWEzLnBhcnNlKS5tYXAoKG0yKSA9PiB7XG4gICAgICBtMi5UYWdzID0gbTIuVGFncy5jb25jYXQoW1xuICAgICAgICB7IG5hbWU6IFwiRGF0YS1Qcm90b2NvbFwiLCB2YWx1ZTogXCJhb1wiIH0sXG4gICAgICAgIHsgbmFtZTogXCJUeXBlXCIsIHZhbHVlOiBcIk1lc3NhZ2VcIiB9LFxuICAgICAgICB7IG5hbWU6IFwiVmFyaWFudFwiLCB2YWx1ZTogXCJhby5UTi4xXCIgfVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gbTI7XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZHJ5cnVuL3J1bi5qc1xuZnVuY3Rpb24gcnVuV2l0aCh7IGRyeXJ1bkZldGNoIH0pIHtcbiAgcmV0dXJuIGZyb21Qcm9taXNlKGRyeXJ1blJlc3VsdFNjaGVtYS5pbXBsZW1lbnQoZHJ5cnVuRmV0Y2gpKTtcbn1cblxuLy8gc3JjL2xpYi9kcnlydW4vaW5kZXguanNcbmZ1bmN0aW9uIGRyeXJ1bldpdGgoZW52KSB7XG4gIGNvbnN0IHZlcmlmeUlucHV0ID0gdmVyaWZ5SW5wdXRXaXRoMyhlbnYpO1xuICBjb25zdCBkcnlydW4yID0gcnVuV2l0aChlbnYpO1xuICByZXR1cm4gKG1zZykgPT4gb2YobXNnKS5tYXAoY29udmVydCkuY2hhaW4odmVyaWZ5SW5wdXQpLmNoYWluKGRyeXJ1bjIpLnRvUHJvbWlzZSgpO1xufVxuZnVuY3Rpb24gY29udmVydCh7IHByb2Nlc3M6IHByb2Nlc3MyLCBkYXRhLCB0YWdzLCBhbmNob3IsIC4uLnJlc3QgfSkge1xuICByZXR1cm4ge1xuICAgIElkOiBcIjEyMzRcIixcbiAgICBPd25lcjogXCIxMjM0XCIsXG4gICAgLi4ucmVzdCxcbiAgICBUYXJnZXQ6IHByb2Nlc3MyLFxuICAgIERhdGE6IGRhdGEgfHwgXCIxMjM0XCIsXG4gICAgVGFnczogdGFncyB8fCBbXSxcbiAgICBBbmNob3I6IGFuY2hvciB8fCBcIjBcIlxuICB9O1xufVxuXG4vLyBzcmMvbGliL2Fzc2lnbi9zZW5kLWFzc2lnbi5qc1xuZnVuY3Rpb24gc2VuZEFzc2lnbldpdGgoZW52KSB7XG4gIGNvbnN0IGRlcGxveUFzc2lnbiA9IGRlcGxveUFzc2lnblNjaGVtYS5pbXBsZW1lbnQoZW52LmRlcGxveUFzc2lnbik7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgcmV0dXJuIG9mKGN0eCkuY2hhaW4oZnJvbVByb21pc2UoXG4gICAgICAoeyBwcm9jZXNzOiBwcm9jZXNzMiwgbWVzc2FnZTogbWVzc2FnZTIsIGJhc2VMYXllciwgZXhjbHVkZSB9KSA9PiBkZXBsb3lBc3NpZ24oeyBwcm9jZXNzOiBwcm9jZXNzMiwgbWVzc2FnZTogbWVzc2FnZTIsIGJhc2VMYXllciwgZXhjbHVkZSB9KVxuICAgICkpLm1hcCgocmVzKSA9PiBhc3NvY19kZWZhdWx0KFwiYXNzaWdubWVudElkXCIsIHJlcy5hc3NpZ25tZW50SWQsIGN0eCkpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2Fzc2lnbi9pbmRleC5qc1xuZnVuY3Rpb24gYXNzaWduV2l0aChlbnYpIHtcbiAgY29uc3Qgc2VuZEFzc2lnbiA9IHNlbmRBc3NpZ25XaXRoKGVudik7XG4gIHJldHVybiAoeyBwcm9jZXNzOiBwcm9jZXNzMiwgbWVzc2FnZTogbWVzc2FnZTIsIGJhc2VMYXllciwgZXhjbHVkZSB9KSA9PiB7XG4gICAgcmV0dXJuIG9mKHsgcHJvY2VzczogcHJvY2VzczIsIG1lc3NhZ2U6IG1lc3NhZ2UyLCBiYXNlTGF5ZXIsIGV4Y2x1ZGUgfSkuY2hhaW4oc2VuZEFzc2lnbikubWFwKChjdHgpID0+IGN0eC5hc3NpZ25tZW50SWQpLmJpbWFwKGVyckZyb20sIGlkZW50aXR5X2RlZmF1bHQpLnRvUHJvbWlzZSgpO1xuICB9O1xufVxuXG4vLyBzcmMvbGliL3NlcmlhbGl6ZUNyb24vaW5kZXguanNcbmZ1bmN0aW9uIHNlcmlhbGl6ZUNyb24oY3Jvbikge1xuICBmdW5jdGlvbiBwYXJzZUludGVydmFsKGludGVydmFsMiA9IFwiXCIpIHtcbiAgICBpZiAodHlwZW9mIGludGVydmFsMiAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiRW5jb3VudGVyZWQgRXJyb3Igc2VyaWFsaXppbmcgY3JvbjogaW52YWxpZCBpbnRlcnZhbFwiKTtcbiAgICBjb25zdCBbdmFsdWUsIHVuaXRdID0gaW50ZXJ2YWwyLnNwbGl0KFwiLVwiKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICBpZiAoIXZhbHVlIHx8ICF1bml0KSB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvdW50ZXJlZCBFcnJvciBzZXJpYWxpemluZyBjcm9uOiBpbnZhbGlkIGludGVydmFsXCIpO1xuICAgIGlmICghcGFyc2VJbnQodmFsdWUpIHx8IHBhcnNlSW50KHZhbHVlKSA8IDApIHRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIEVycm9yIHNlcmlhbGl6aW5nIGNyb246IGludmFsaWQgaW50ZXJ2YWwgdmFsdWVcIik7XG4gICAgY29uc3Qgc2luZ3VsYXJSZWdleCA9IC9eKG1pbGxpc2Vjb25kfHNlY29uZHxtaW51dGV8aG91cnxkYXl8bW9udGh8eWVhcnxibG9jaykkLztcbiAgICBjb25zdCBwbHVyYWxSZWdleCA9IC9eKG1pbGxpc2Vjb25kc3xzZWNvbmRzfG1pbnV0ZXN8aG91cnN8ZGF5c3xtb250aHN8eWVhcnN8YmxvY2tzKSQvO1xuICAgIGNvbnN0IHVuaXRTaW5ndWxhck1hdGNoID0gdW5pdC5tYXRjaChzaW5ndWxhclJlZ2V4KTtcbiAgICBjb25zdCB1bml0UGx1cmFsTWF0Y2ggPSB1bml0Lm1hdGNoKHBsdXJhbFJlZ2V4KTtcbiAgICBpZiAocGFyc2VJbnQodmFsdWUpID4gMSAmJiAhdW5pdFBsdXJhbE1hdGNoIHx8IHBhcnNlSW50KHZhbHVlKSA9PT0gMSAmJiAhdW5pdFNpbmd1bGFyTWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIEVycm9yIHNlcmlhbGl6aW5nIGNyb246IGludmFsaWQgaW50ZXJ2YWwgdHlwZVwiKTtcbiAgICByZXR1cm4gYCR7dmFsdWV9LSR7dW5pdH1gO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGFnczModGFnczIgPSBbXSkge1xuICAgIHJldHVybiBtYXBfZGVmYXVsdCgodGFnKSA9PiB7XG4gICAgICBpZiAoIXRhZy5uYW1lIHx8ICF0YWcudmFsdWUpIHRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIEVycm9yIHNlcmlhbGl6aW5nIGNyb246IGludmFsaWQgdGFnIHN0cnVjdHVyZVwiKTtcbiAgICAgIGlmICh0eXBlb2YgdGFnLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHRhZy52YWx1ZSAhPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiRW5jb3VudGVyZWQgRXJyb3Igc2VyaWFsaXppbmcgY3JvbjogaW52YWxpZCBpbnRlcnZhbCB0YWcgdHlwZXNcIik7XG4gICAgICByZXR1cm4geyBuYW1lOiBgQ3Jvbi1UYWctJHt0YWcubmFtZX1gLCB2YWx1ZTogdGFnLnZhbHVlIH07XG4gICAgfSwgdGFnczIpO1xuICB9XG4gIGNvbnN0IGludGVydmFsID0gcGFyc2VJbnRlcnZhbChjcm9uLmludGVydmFsKTtcbiAgY29uc3QgdGFncyA9IHBhcnNlVGFnczMoY3Jvbi50YWdzKTtcbiAgcmV0dXJuIFt7IG5hbWU6IFwiQ3Jvbi1JbnRlcnZhbFwiLCB2YWx1ZTogaW50ZXJ2YWwgfSwgLi4udGFnc107XG59XG5cbi8vIHNyYy9pbmRleC5jb21tb24uanNcbnZhciBERUZBVUxUX0dBVEVXQVlfVVJMID0gXCJodHRwczovL2Fyd2VhdmUubmV0XCI7XG52YXIgREVGQVVMVF9NVV9VUkwgPSBcImh0dHBzOi8vbXUuYW8tdGVzdG5ldC54eXpcIjtcbnZhciBERUZBVUxUX0NVX1VSTCA9IFwiaHR0cHM6Ly9jdS5hby10ZXN0bmV0Lnh5elwiO1xuZnVuY3Rpb24gY29ubmVjdCh7XG4gIEdSQVBIUUxfVVJMOiBHUkFQSFFMX1VSTDIsXG4gIEdSQVBIUUxfTUFYX1JFVFJJRVM6IEdSQVBIUUxfTUFYX1JFVFJJRVMyLFxuICBHUkFQSFFMX1JFVFJZX0JBQ0tPRkY6IEdSQVBIUUxfUkVUUllfQkFDS09GRjIsXG4gIEdBVEVXQVlfVVJMOiBHQVRFV0FZX1VSTDIgPSBERUZBVUxUX0dBVEVXQVlfVVJMLFxuICBNVV9VUkw6IE1VX1VSTDIgPSBERUZBVUxUX01VX1VSTCxcbiAgQ1VfVVJMOiBDVV9VUkwyID0gREVGQVVMVF9DVV9VUkxcbn0gPSB7fSkge1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoKTtcbiAgaWYgKCFHUkFQSFFMX1VSTDIpIEdSQVBIUUxfVVJMMiA9IGpvaW5VcmwoeyB1cmw6IEdBVEVXQVlfVVJMMiwgcGF0aDogXCIvZ3JhcGhxbFwiIH0pO1xuICBjb25zdCB7IHZhbGlkYXRlIH0gPSBlbih7IGNhY2hlU2l6ZTogMTAwLCBHUkFQSFFMX1VSTDogR1JBUEhRTF9VUkwyLCBHUkFQSFFMX01BWF9SRVRSSUVTOiBHUkFQSFFMX01BWF9SRVRSSUVTMiwgR1JBUEhRTF9SRVRSWV9CQUNLT0ZGOiBHUkFQSFFMX1JFVFJZX0JBQ0tPRkYyIH0pO1xuICBjb25zdCBwcm9jZXNzTWV0YUNhY2hlMiA9IGNyZWF0ZVByb2Nlc3NNZXRhQ2FjaGUoeyBNQVhfU0laRTogMjUgfSk7XG4gIGNvbnN0IHJlc3VsdExvZ2dlciA9IGxvZ2dlci5jaGlsZChcInJlc3VsdFwiKTtcbiAgY29uc3QgcmVzdWx0MiA9IHJlc3VsdFdpdGgoe1xuICAgIGxvYWRSZXN1bHQ6IGxvYWRSZXN1bHRXaXRoKHsgZmV0Y2gsIENVX1VSTDogQ1VfVVJMMiwgbG9nZ2VyOiByZXN1bHRMb2dnZXIgfSksXG4gICAgbG9nZ2VyOiByZXN1bHRMb2dnZXJcbiAgfSk7XG4gIGNvbnN0IG1lc3NhZ2VMb2dnZXIgPSBsb2dnZXIuY2hpbGQoXCJtZXNzYWdlXCIpO1xuICBjb25zdCBtZXNzYWdlMiA9IG1lc3NhZ2VXaXRoKHtcbiAgICBsb2FkUHJvY2Vzc01ldGE6IGxvYWRQcm9jZXNzTWV0YVdpdGgoe1xuICAgICAgZmV0Y2gsXG4gICAgICBjYWNoZTogcHJvY2Vzc01ldGFDYWNoZTIsXG4gICAgICBsb2dnZXI6IG1lc3NhZ2VMb2dnZXJcbiAgICB9KSxcbiAgICAvLyBsb2NhdGVTY2hlZHVsZXI6IGxvY2F0ZSxcbiAgICBkZXBsb3lNZXNzYWdlOiBkZXBsb3lNZXNzYWdlV2l0aCh7IGZldGNoLCBNVV9VUkw6IE1VX1VSTDIsIGxvZ2dlcjogbWVzc2FnZUxvZ2dlciB9KSxcbiAgICBsb2dnZXI6IG1lc3NhZ2VMb2dnZXJcbiAgfSk7XG4gIGNvbnN0IHNwYXduTG9nZ2VyID0gbG9nZ2VyLmNoaWxkKFwic3Bhd25cIik7XG4gIGNvbnN0IHNwYXduMiA9IHNwYXduV2l0aCh7XG4gICAgbG9hZFRyYW5zYWN0aW9uTWV0YTogbG9hZFRyYW5zYWN0aW9uTWV0YVdpdGgoeyBmZXRjaCwgR1JBUEhRTF9VUkw6IEdSQVBIUUxfVVJMMiwgbG9nZ2VyOiBzcGF3bkxvZ2dlciB9KSxcbiAgICB2YWxpZGF0ZVNjaGVkdWxlcjogdmFsaWRhdGUsXG4gICAgZGVwbG95UHJvY2VzczogZGVwbG95UHJvY2Vzc1dpdGgoeyBmZXRjaCwgTVVfVVJMOiBNVV9VUkwyLCBsb2dnZXI6IHNwYXduTG9nZ2VyIH0pLFxuICAgIGxvZ2dlcjogc3Bhd25Mb2dnZXJcbiAgfSk7XG4gIGNvbnN0IG1vbml0b3JMb2dnZXIgPSBsb2dnZXIuY2hpbGQoXCJtb25pdG9yXCIpO1xuICBjb25zdCBtb25pdG9yMiA9IG1vbml0b3JXaXRoKHtcbiAgICBsb2FkUHJvY2Vzc01ldGE6IGxvYWRQcm9jZXNzTWV0YVdpdGgoe1xuICAgICAgZmV0Y2gsXG4gICAgICBjYWNoZTogcHJvY2Vzc01ldGFDYWNoZTIsXG4gICAgICBsb2dnZXI6IG1vbml0b3JMb2dnZXJcbiAgICB9KSxcbiAgICAvLyBsb2NhdGVTY2hlZHVsZXI6IGxvY2F0ZSxcbiAgICBkZXBsb3lNb25pdG9yOiBkZXBsb3lNb25pdG9yV2l0aCh7IGZldGNoLCBNVV9VUkw6IE1VX1VSTDIsIGxvZ2dlcjogbW9uaXRvckxvZ2dlciB9KSxcbiAgICBsb2dnZXI6IG1vbml0b3JMb2dnZXJcbiAgfSk7XG4gIGNvbnN0IHVubW9uaXRvckxvZ2dlciA9IGxvZ2dlci5jaGlsZChcInVubW9uaXRvclwiKTtcbiAgY29uc3QgdW5tb25pdG9yMiA9IHVubW9uaXRvcldpdGgoe1xuICAgIGxvYWRQcm9jZXNzTWV0YTogbG9hZFByb2Nlc3NNZXRhV2l0aCh7XG4gICAgICBmZXRjaCxcbiAgICAgIGNhY2hlOiBwcm9jZXNzTWV0YUNhY2hlMixcbiAgICAgIGxvZ2dlcjogdW5tb25pdG9yTG9nZ2VyXG4gICAgfSksXG4gICAgLy8gbG9jYXRlU2NoZWR1bGVyOiBsb2NhdGUsXG4gICAgZGVwbG95VW5tb25pdG9yOiBkZXBsb3lVbm1vbml0b3JXaXRoKHsgZmV0Y2gsIE1VX1VSTDogTVVfVVJMMiwgbG9nZ2VyOiB1bm1vbml0b3JMb2dnZXIgfSksXG4gICAgbG9nZ2VyOiBtb25pdG9yTG9nZ2VyXG4gIH0pO1xuICBjb25zdCByZXN1bHRzTG9nZ2VyID0gbG9nZ2VyLmNoaWxkKFwicmVzdWx0c1wiKTtcbiAgY29uc3QgcmVzdWx0czIgPSByZXN1bHRzV2l0aCh7XG4gICAgcXVlcnlSZXN1bHRzOiBxdWVyeVJlc3VsdHNXaXRoKHsgZmV0Y2gsIENVX1VSTDogQ1VfVVJMMiwgbG9nZ2VyOiByZXN1bHRzTG9nZ2VyIH0pLFxuICAgIGxvZ2dlcjogcmVzdWx0c0xvZ2dlclxuICB9KTtcbiAgY29uc3QgZHJ5cnVuTG9nZ2VyID0gbG9nZ2VyLmNoaWxkKFwiZHJ5cnVuXCIpO1xuICBjb25zdCBkcnlydW4yID0gZHJ5cnVuV2l0aCh7XG4gICAgZHJ5cnVuRmV0Y2g6IGRyeXJ1bkZldGNoV2l0aCh7IGZldGNoLCBDVV9VUkw6IENVX1VSTDIsIGxvZ2dlcjogZHJ5cnVuTG9nZ2VyIH0pLFxuICAgIGxvZ2dlcjogZHJ5cnVuTG9nZ2VyXG4gIH0pO1xuICBjb25zdCBhc3NpZ25Mb2dnZXIgPSBsb2dnZXIuY2hpbGQoXCJhc3NpZ25cIik7XG4gIGNvbnN0IGFzc2lnbjIgPSBhc3NpZ25XaXRoKHtcbiAgICBkZXBsb3lBc3NpZ246IGRlcGxveUFzc2lnbldpdGgoe1xuICAgICAgZmV0Y2gsXG4gICAgICBNVV9VUkw6IE1VX1VSTDIsXG4gICAgICBsb2dnZXI6IGFzc2lnbkxvZ2dlclxuICAgIH0pLFxuICAgIGxvZ2dlcjogbWVzc2FnZUxvZ2dlclxuICB9KTtcbiAgcmV0dXJuIHsgcmVzdWx0OiByZXN1bHQyLCByZXN1bHRzOiByZXN1bHRzMiwgbWVzc2FnZTogbWVzc2FnZTIsIHNwYXduOiBzcGF3bjIsIG1vbml0b3I6IG1vbml0b3IyLCB1bm1vbml0b3I6IHVubW9uaXRvcjIsIGRyeXJ1bjogZHJ5cnVuMiwgYXNzaWduOiBhc3NpZ24yIH07XG59XG5cbi8vIHNyYy9jbGllbnQvYnJvd3Nlci93YWxsZXQuanNcbnZhciB3YWxsZXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQod2FsbGV0X2V4cG9ydHMsIHtcbiAgY3JlYXRlRGF0YUl0ZW1TaWduZXI6ICgpID0+IGNyZWF0ZURhdGFJdGVtU2lnbmVyXG59KTtcbnZhciBpbXBvcnRfYnVmZmVyID0gX190b0VTTShyZXF1aXJlX2J1ZmZlcigpLCAxKTtcblxuLy8gbm9kZV9tb2R1bGVzL3dhcnAtYXJidW5kbGVzL2J1aWxkL3dlYi9lc20vYnVuZGxlLmpzXG52YXIgYnVuZGxlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGJ1bmRsZV9leHBvcnRzLCB7XG4gIEFWU0NUYXA6ICgpID0+ICQyLFxuICBBcndlYXZlU2lnbmVyOiAoKSA9PiBOMixcbiAgRGF0YUl0ZW06ICgpID0+IF8yLFxuICBNQVhfVEFHX0JZVEVTOiAoKSA9PiB0dDIsXG4gIE1JTl9CSU5BUllfU0laRTogKCkgPT4gZ3IyLFxuICBTSUdfQ09ORklHOiAoKSA9PiBQMixcbiAgU2lnbmF0dXJlQ29uZmlnOiAoKSA9PiBCLFxuICBTaWduZXI6ICgpID0+IG90MixcbiAgY3JlYXRlRGF0YTogKCkgPT4gZ2UyLFxuICBkZWZhdWx0OiAoKSA9PiB3bjIsXG4gIGRlc2VyaWFsaXplVGFnczogKCkgPT4gUSxcbiAgaW5kZXhUb1R5cGU6ICgpID0+IHd0MixcbiAgc2VyaWFsaXplVGFnczogKCkgPT4gZHQyLFxuICB0YWdzRXhjZWVkTGltaXQ6ICgpID0+IGpyMixcbiAgd2FycGFyYnVuZGxlczogKCkgPT4gZG4yXG59KTtcbnZhciB4cjIgPSBPYmplY3QuY3JlYXRlO1xudmFyIGl0MiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBtcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEJyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIEVyMiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBicjIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFQyID0gKGUsIHQpID0+ICgpID0+ICh0IHx8IGUoKHQgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIHQpLCB0LmV4cG9ydHMpO1xudmFyIEFyMiA9IChlLCB0KSA9PiB7XG4gIGZvciAodmFyIHIxOCBpbiB0KSBpdDIoZSwgcjE4LCB7IGdldDogdFtyMThdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBUcjIgPSAoZSwgdCwgcjE4LCBuKSA9PiB7XG4gIGlmICh0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSBmb3IgKGxldCBpIG9mIEJyMih0KSkgIWJyMi5jYWxsKGUsIGkpICYmIGkgIT09IHIxOCAmJiBpdDIoZSwgaSwgeyBnZXQ6ICgpID0+IHRbaV0sIGVudW1lcmFibGU6ICEobiA9IG1yMih0LCBpKSkgfHwgbi5lbnVtZXJhYmxlIH0pO1xuICByZXR1cm4gZTtcbn07XG52YXIgQyA9IChlLCB0LCByMTgpID0+IChyMTggPSBlICE9IG51bGwgPyB4cjIoRXIyKGUpKSA6IHt9LCBUcjIodCB8fCAhZSB8fCAhZS5fX2VzTW9kdWxlID8gaXQyKHIxOCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IGUsIGVudW1lcmFibGU6IHRydWUgfSkgOiByMTgsIGUpKTtcbnZhciBSdDIgPSBUMigoc3QyKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3QyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgZnVuY3Rpb24gSXIyKGUpIHtcbiAgICB2YXIgdCA9IDQsIHIxOCA9IGUubGVuZ3RoLCBuID0gcjE4ICUgdDtcbiAgICBpZiAoIW4pIHJldHVybiBlO1xuICAgIHZhciBpID0gcjE4LCBvID0gdCAtIG4sIHMgPSByMTggKyBvLCB1ID0gQnVmZmVyLmFsbG9jKHMpO1xuICAgIGZvciAodS53cml0ZShlKTsgby0tOyApIHUud3JpdGUoXCI9XCIsIGkrKyk7XG4gICAgcmV0dXJuIHUudG9TdHJpbmcoKTtcbiAgfVxuICBzdDIuZGVmYXVsdCA9IElyMjtcbn0pO1xudmFyIER0MiA9IFQyKChodDIpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShodDIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB2YXIgU3IyID0gUnQyKCk7XG4gIGZ1bmN0aW9uIEN0MihlLCB0KSB7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IFwidXRmOFwiKSwgQnVmZmVyLmlzQnVmZmVyKGUpID8gYXQyKGUudG9TdHJpbmcoXCJiYXNlNjRcIikpIDogYXQyKEJ1ZmZlci5mcm9tKGUsIHQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbiAgfVxuICBmdW5jdGlvbiBVcjIoZSwgdCkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSBcInV0ZjhcIiksIEJ1ZmZlci5mcm9tKHV0MihlKSwgXCJiYXNlNjRcIikudG9TdHJpbmcodCk7XG4gIH1cbiAgZnVuY3Rpb24gdXQyKGUpIHtcbiAgICByZXR1cm4gZSA9IGUudG9TdHJpbmcoKSwgU3IyLmRlZmF1bHQoZSkucmVwbGFjZSgvXFwtL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgfVxuICBmdW5jdGlvbiBhdDIoZSkge1xuICAgIHJldHVybiBlLnJlcGxhY2UoLz0vZywgXCJcIikucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEZyMihlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHV0MihlKSwgXCJiYXNlNjRcIik7XG4gIH1cbiAgdmFyIE8gPSBDdDI7XG4gIE8uZW5jb2RlID0gQ3QyO1xuICBPLmRlY29kZSA9IFVyMjtcbiAgTy50b0Jhc2U2NCA9IHV0MjtcbiAgTy5mcm9tQmFzZTY0ID0gYXQyO1xuICBPLnRvQnVmZmVyID0gRnIyO1xuICBodDIuZGVmYXVsdCA9IE87XG59KTtcbnZhciB6MyA9IFQyKChtZTIsIFYpID0+IHtcbiAgVi5leHBvcnRzID0gRHQyKCkuZGVmYXVsdDtcbiAgVi5leHBvcnRzLmRlZmF1bHQgPSBWLmV4cG9ydHM7XG59KTtcbnZhciBjdDIgPSBUMigoSjIpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIEoyLmJ5dGVMZW5ndGggPSBfcjI7XG4gIEoyLnRvQnl0ZUFycmF5ID0gQ3IyO1xuICBKMi5mcm9tQnl0ZUFycmF5ID0gTnIyO1xuICB2YXIgYjIgPSBbXSwgbTIgPSBbXSwgTHIyID0gdHlwZW9mIFVpbnQ4QXJyYXkgPCBcInVcIiA/IFVpbnQ4QXJyYXkgOiBBcnJheSwgZnQyID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIGZvciAoRDIgPSAwLCBQdDIgPSBmdDIubGVuZ3RoOyBEMiA8IFB0MjsgKytEMikgYjJbRDJdID0gZnQyW0QyXSwgbTJbZnQyLmNoYXJDb2RlQXQoRDIpXSA9IEQyO1xuICB2YXIgRDIsIFB0MjtcbiAgbTJbXCItXCIuY2hhckNvZGVBdCgwKV0gPSA2MjtcbiAgbTJbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSA2MztcbiAgZnVuY3Rpb24gTnQyKGUpIHtcbiAgICB2YXIgdCA9IGUubGVuZ3RoO1xuICAgIGlmICh0ICUgNCA+IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7XG4gICAgdmFyIHIxOCA9IGUuaW5kZXhPZihcIj1cIik7XG4gICAgcjE4ID09PSAtMSAmJiAocjE4ID0gdCk7XG4gICAgdmFyIG4gPSByMTggPT09IHQgPyAwIDogNCAtIHIxOCAlIDQ7XG4gICAgcmV0dXJuIFtyMTgsIG5dO1xuICB9XG4gIGZ1bmN0aW9uIF9yMihlKSB7XG4gICAgdmFyIHQgPSBOdDIoZSksIHIxOCA9IHRbMF0sIG4gPSB0WzFdO1xuICAgIHJldHVybiAocjE4ICsgbikgKiAzIC8gNCAtIG47XG4gIH1cbiAgZnVuY3Rpb24gUnIyKGUsIHQsIHIxOCkge1xuICAgIHJldHVybiAodCArIHIxOCkgKiAzIC8gNCAtIHIxODtcbiAgfVxuICBmdW5jdGlvbiBDcjIoZSkge1xuICAgIHZhciB0LCByMTggPSBOdDIoZSksIG4gPSByMThbMF0sIGkgPSByMThbMV0sIG8gPSBuZXcgTHIyKFJyMihlLCBuLCBpKSksIHMgPSAwLCB1ID0gaSA+IDAgPyBuIC0gNCA6IG4sIGg7XG4gICAgZm9yIChoID0gMDsgaCA8IHU7IGggKz0gNCkgdCA9IG0yW2UuY2hhckNvZGVBdChoKV0gPDwgMTggfCBtMltlLmNoYXJDb2RlQXQoaCArIDEpXSA8PCAxMiB8IG0yW2UuY2hhckNvZGVBdChoICsgMildIDw8IDYgfCBtMltlLmNoYXJDb2RlQXQoaCArIDMpXSwgb1tzKytdID0gdCA+PiAxNiAmIDI1NSwgb1tzKytdID0gdCA+PiA4ICYgMjU1LCBvW3MrK10gPSB0ICYgMjU1O1xuICAgIHJldHVybiBpID09PSAyICYmICh0ID0gbTJbZS5jaGFyQ29kZUF0KGgpXSA8PCAyIHwgbTJbZS5jaGFyQ29kZUF0KGggKyAxKV0gPj4gNCwgb1tzKytdID0gdCAmIDI1NSksIGkgPT09IDEgJiYgKHQgPSBtMltlLmNoYXJDb2RlQXQoaCldIDw8IDEwIHwgbTJbZS5jaGFyQ29kZUF0KGggKyAxKV0gPDwgNCB8IG0yW2UuY2hhckNvZGVBdChoICsgMildID4+IDIsIG9bcysrXSA9IHQgPj4gOCAmIDI1NSwgb1tzKytdID0gdCAmIDI1NSksIG87XG4gIH1cbiAgZnVuY3Rpb24gRHIyKGUpIHtcbiAgICByZXR1cm4gYjJbZSA+PiAxOCAmIDYzXSArIGIyW2UgPj4gMTIgJiA2M10gKyBiMltlID4+IDYgJiA2M10gKyBiMltlICYgNjNdO1xuICB9XG4gIGZ1bmN0aW9uIFByMihlLCB0LCByMTgpIHtcbiAgICBmb3IgKHZhciBuLCBpID0gW10sIG8gPSB0OyBvIDwgcjE4OyBvICs9IDMpIG4gPSAoZVtvXSA8PCAxNiAmIDE2NzExNjgwKSArIChlW28gKyAxXSA8PCA4ICYgNjUyODApICsgKGVbbyArIDJdICYgMjU1KSwgaS5wdXNoKERyMihuKSk7XG4gICAgcmV0dXJuIGkuam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBOcjIoZSkge1xuICAgIGZvciAodmFyIHQsIHIxOCA9IGUubGVuZ3RoLCBuID0gcjE4ICUgMywgaSA9IFtdLCBvID0gMTYzODMsIHMgPSAwLCB1ID0gcjE4IC0gbjsgcyA8IHU7IHMgKz0gbykgaS5wdXNoKFByMihlLCBzLCBzICsgbyA+IHUgPyB1IDogcyArIG8pKTtcbiAgICByZXR1cm4gbiA9PT0gMSA/ICh0ID0gZVtyMTggLSAxXSwgaS5wdXNoKGIyW3QgPj4gMl0gKyBiMlt0IDw8IDQgJiA2M10gKyBcIj09XCIpKSA6IG4gPT09IDIgJiYgKHQgPSAoZVtyMTggLSAyXSA8PCA4KSArIGVbcjE4IC0gMV0sIGkucHVzaChiMlt0ID4+IDEwXSArIGIyW3QgPj4gNCAmIDYzXSArIGIyW3QgPDwgMiAmIDYzXSArIFwiPVwiKSksIGkuam9pbihcIlwiKTtcbiAgfVxufSk7XG52YXIgcHQyID0gVDIoKGcyKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZzIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBnMi5iNjRVcmxEZWNvZGUgPSBnMi5iNjRVcmxFbmNvZGUgPSBnMi5idWZmZXJUb2I2NFVybCA9IGcyLmJ1ZmZlclRvYjY0ID0gZzIuYjY0VXJsVG9CdWZmZXIgPSBnMi5zdHJpbmdUb0I2NFVybCA9IGcyLnN0cmluZ1RvQnVmZmVyID0gZzIuYnVmZmVyVG9TdHJpbmcgPSBnMi5iNjRVcmxUb1N0cmluZyA9IGcyLmNvbmNhdEJ1ZmZlcnMgPSB2b2lkIDA7XG4gIHZhciBrdDIgPSBjdDIoKTtcbiAgZnVuY3Rpb24ga3IyKGUpIHtcbiAgICBsZXQgdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB0ICs9IGVbaV0uYnl0ZUxlbmd0aDtcbiAgICBsZXQgcjE4ID0gbmV3IFVpbnQ4QXJyYXkodCksIG4gPSAwO1xuICAgIHIxOC5zZXQobmV3IFVpbnQ4QXJyYXkoZVswXSksIG4pLCBuICs9IGVbMF0uYnl0ZUxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGUubGVuZ3RoOyBpKyspIHIxOC5zZXQobmV3IFVpbnQ4QXJyYXkoZVtpXSksIG4pLCBuICs9IGVbaV0uYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gcjE4O1xuICB9XG4gIGcyLmNvbmNhdEJ1ZmZlcnMgPSBrcjI7XG4gIGZ1bmN0aW9uIE1yMihlKSB7XG4gICAgbGV0IHQgPSAkdDIoZSk7XG4gICAgcmV0dXJuIE10Mih0KTtcbiAgfVxuICBnMi5iNjRVcmxUb1N0cmluZyA9IE1yMjtcbiAgZnVuY3Rpb24gTXQyKGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiwgeyBmYXRhbDogdHJ1ZSB9KS5kZWNvZGUoZSk7XG4gIH1cbiAgZzIuYnVmZmVyVG9TdHJpbmcgPSBNdDI7XG4gIGZ1bmN0aW9uIE90MihlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShlKTtcbiAgfVxuICBnMi5zdHJpbmdUb0J1ZmZlciA9IE90MjtcbiAgZnVuY3Rpb24gT3IyKGUpIHtcbiAgICByZXR1cm4gSHQyKE90MihlKSk7XG4gIH1cbiAgZzIuc3RyaW5nVG9CNjRVcmwgPSBPcjI7XG4gIGZ1bmN0aW9uICR0MihlKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGt0Mi50b0J5dGVBcnJheShxdDIoZSkpKTtcbiAgfVxuICBnMi5iNjRVcmxUb0J1ZmZlciA9ICR0MjtcbiAgZnVuY3Rpb24gS3QyKGUpIHtcbiAgICByZXR1cm4ga3QyLmZyb21CeXRlQXJyYXkobmV3IFVpbnQ4QXJyYXkoZSkpO1xuICB9XG4gIGcyLmJ1ZmZlclRvYjY0ID0gS3QyO1xuICBmdW5jdGlvbiBIdDIoZSkge1xuICAgIHJldHVybiBqdDIoS3QyKGUpKTtcbiAgfVxuICBnMi5idWZmZXJUb2I2NFVybCA9IEh0MjtcbiAgZnVuY3Rpb24ganQyKGUpIHtcbiAgICByZXR1cm4gZS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFw9L2csIFwiXCIpO1xuICB9XG4gIGcyLmI2NFVybEVuY29kZSA9IGp0MjtcbiAgZnVuY3Rpb24gcXQyKGUpIHtcbiAgICBlID0gZS5yZXBsYWNlKC9cXC0vZywgXCIrXCIpLnJlcGxhY2UoL1xcXy9nLCBcIi9cIik7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIGUubGVuZ3RoICUgNCA9PSAwID8gdCA9IDAgOiB0ID0gNCAtIGUubGVuZ3RoICUgNCwgZS5jb25jYXQoXCI9XCIucmVwZWF0KHQpKTtcbiAgfVxuICBnMi5iNjRVcmxEZWNvZGUgPSBxdDI7XG59KTtcbnZhciBZdCA9IFQyKChndDIpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShndDIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB2YXIgRjMgPSBwdDIoKSwgbHQyID0gY2xhc3Mge1xuICAgIGtleUxlbmd0aCA9IDQwOTY7XG4gICAgcHVibGljRXhwb25lbnQgPSA2NTUzNztcbiAgICBoYXNoQWxnb3JpdGhtID0gXCJzaGEyNTZcIjtcbiAgICBkcml2ZXI7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBpZiAoIXRoaXMuZGV0ZWN0V2ViQ3J5cHRvKCkpIHRocm93IG5ldyBFcnJvcihcIlN1YnRsZUNyeXB0byBub3QgYXZhaWxhYmxlIVwiKTtcbiAgICAgIHRoaXMuZHJpdmVyID0gY3J5cHRvLnN1YnRsZTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVKV0soKSB7XG4gICAgICBsZXQgdCA9IGF3YWl0IHRoaXMuZHJpdmVyLmdlbmVyYXRlS2V5KHsgbmFtZTogXCJSU0EtUFNTXCIsIG1vZHVsdXNMZW5ndGg6IDQwOTYsIHB1YmxpY0V4cG9uZW50OiBuZXcgVWludDhBcnJheShbMSwgMCwgMV0pLCBoYXNoOiB7IG5hbWU6IFwiU0hBLTI1NlwiIH0gfSwgdHJ1ZSwgW1wic2lnblwiXSksIHIxOCA9IGF3YWl0IHRoaXMuZHJpdmVyLmV4cG9ydEtleShcImp3a1wiLCB0LnByaXZhdGVLZXkpO1xuICAgICAgcmV0dXJuIHsga3R5OiByMTgua3R5LCBlOiByMTguZSwgbjogcjE4Lm4sIGQ6IHIxOC5kLCBwOiByMTgucCwgcTogcjE4LnEsIGRwOiByMTguZHAsIGRxOiByMTguZHEsIHFpOiByMTgucWkgfTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbih0LCByMTgsIHsgc2FsdExlbmd0aDogbiB9ID0ge30pIHtcbiAgICAgIGxldCBpID0gYXdhaXQgdGhpcy5kcml2ZXIuc2lnbih7IG5hbWU6IFwiUlNBLVBTU1wiLCBzYWx0TGVuZ3RoOiAzMiB9LCBhd2FpdCB0aGlzLmp3a1RvQ3J5cHRvS2V5KHQpLCByMTgpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGkpO1xuICAgIH1cbiAgICBhc3luYyBoYXNoKHQsIHIxOCA9IFwiU0hBLTI1NlwiKSB7XG4gICAgICBsZXQgbiA9IGF3YWl0IHRoaXMuZHJpdmVyLmRpZ2VzdChyMTgsIHQpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG4pO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkodCwgcjE4LCBuKSB7XG4gICAgICBsZXQgaSA9IHsga3R5OiBcIlJTQVwiLCBlOiBcIkFRQUJcIiwgbjogdCB9LCBvID0gYXdhaXQgdGhpcy5qd2tUb1B1YmxpY0NyeXB0b0tleShpKSwgcyA9IGF3YWl0IHRoaXMuZHJpdmVyLmRpZ2VzdChcIlNIQS0yNTZcIiwgcjE4KSwgdSA9IGF3YWl0IHRoaXMuZHJpdmVyLnZlcmlmeSh7IG5hbWU6IFwiUlNBLVBTU1wiLCBzYWx0TGVuZ3RoOiAwIH0sIG8sIG4sIHIxOCksIGggPSBhd2FpdCB0aGlzLmRyaXZlci52ZXJpZnkoeyBuYW1lOiBcIlJTQS1QU1NcIiwgc2FsdExlbmd0aDogMzIgfSwgbywgbiwgcjE4KSwgcDIgPSBhd2FpdCB0aGlzLmRyaXZlci52ZXJpZnkoeyBuYW1lOiBcIlJTQS1QU1NcIiwgc2FsdExlbmd0aDogTWF0aC5jZWlsKChvLmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIC0gMSkgLyA4KSAtIHMuYnl0ZUxlbmd0aCAtIDIgfSwgbywgbiwgcjE4KTtcbiAgICAgIHJldHVybiB1IHx8IGggfHwgcDI7XG4gICAgfVxuICAgIGFzeW5jIGp3a1RvQ3J5cHRvS2V5KHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyaXZlci5pbXBvcnRLZXkoXCJqd2tcIiwgdCwgeyBuYW1lOiBcIlJTQS1QU1NcIiwgaGFzaDogeyBuYW1lOiBcIlNIQS0yNTZcIiB9IH0sIGZhbHNlLCBbXCJzaWduXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgandrVG9QdWJsaWNDcnlwdG9LZXkodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJpdmVyLmltcG9ydEtleShcImp3a1wiLCB0LCB7IG5hbWU6IFwiUlNBLVBTU1wiLCBoYXNoOiB7IG5hbWU6IFwiU0hBLTI1NlwiIH0gfSwgZmFsc2UsIFtcInZlcmlmeVwiXSk7XG4gICAgfVxuICAgIGRldGVjdFdlYkNyeXB0bygpIHtcbiAgICAgIGlmICh0eXBlb2YgY3J5cHRvID4gXCJ1XCIpIHJldHVybiBmYWxzZTtcbiAgICAgIGxldCB0ID0gY3J5cHRvPy5zdWJ0bGU7XG4gICAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBbXCJnZW5lcmF0ZUtleVwiLCBcImltcG9ydEtleVwiLCBcImV4cG9ydEtleVwiLCBcImRpZ2VzdFwiLCBcInNpZ25cIl0uZXZlcnkoKG4pID0+IHR5cGVvZiB0W25dID09IFwiZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQodCwgcjE4LCBuKSB7XG4gICAgICBsZXQgaSA9IGF3YWl0IHRoaXMuZHJpdmVyLmltcG9ydEtleShcInJhd1wiLCB0eXBlb2YgcjE4ID09IFwic3RyaW5nXCIgPyBGMy5zdHJpbmdUb0J1ZmZlcihyMTgpIDogcjE4LCB7IG5hbWU6IFwiUEJLREYyXCIsIGxlbmd0aDogMzIgfSwgZmFsc2UsIFtcImRlcml2ZUtleVwiXSksIG8gPSBhd2FpdCB0aGlzLmRyaXZlci5kZXJpdmVLZXkoeyBuYW1lOiBcIlBCS0RGMlwiLCBzYWx0OiBuID8gRjMuc3RyaW5nVG9CdWZmZXIobikgOiBGMy5zdHJpbmdUb0J1ZmZlcihcInNhbHRcIiksIGl0ZXJhdGlvbnM6IDFlNSwgaGFzaDogXCJTSEEtMjU2XCIgfSwgaSwgeyBuYW1lOiBcIkFFUy1DQkNcIiwgbGVuZ3RoOiAyNTYgfSwgZmFsc2UsIFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdKSwgcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocyk7XG4gICAgICBsZXQgdSA9IGF3YWl0IHRoaXMuZHJpdmVyLmVuY3J5cHQoeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXY6IHMgfSwgbywgdCk7XG4gICAgICByZXR1cm4gRjMuY29uY2F0QnVmZmVycyhbcywgdV0pO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KHQsIHIxOCwgbikge1xuICAgICAgbGV0IGkgPSBhd2FpdCB0aGlzLmRyaXZlci5pbXBvcnRLZXkoXCJyYXdcIiwgdHlwZW9mIHIxOCA9PSBcInN0cmluZ1wiID8gRjMuc3RyaW5nVG9CdWZmZXIocjE4KSA6IHIxOCwgeyBuYW1lOiBcIlBCS0RGMlwiLCBsZW5ndGg6IDMyIH0sIGZhbHNlLCBbXCJkZXJpdmVLZXlcIl0pLCBvID0gYXdhaXQgdGhpcy5kcml2ZXIuZGVyaXZlS2V5KHsgbmFtZTogXCJQQktERjJcIiwgc2FsdDogbiA/IEYzLnN0cmluZ1RvQnVmZmVyKG4pIDogRjMuc3RyaW5nVG9CdWZmZXIoXCJzYWx0XCIpLCBpdGVyYXRpb25zOiAxZTUsIGhhc2g6IFwiU0hBLTI1NlwiIH0sIGksIHsgbmFtZTogXCJBRVMtQ0JDXCIsIGxlbmd0aDogMjU2IH0sIGZhbHNlLCBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSksIHMgPSB0LnNsaWNlKDAsIDE2KSwgdSA9IGF3YWl0IHRoaXMuZHJpdmVyLmRlY3J5cHQoeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXY6IHMgfSwgbywgdC5zbGljZSgxNikpO1xuICAgICAgcmV0dXJuIEYzLmNvbmNhdEJ1ZmZlcnMoW3VdKTtcbiAgICB9XG4gIH07XG4gIGd0Mi5kZWZhdWx0ID0gbHQyO1xufSk7XG52YXIgenQyID0gVDIoKG10MikgPT4ge1xuICBtdDIucmVhZCA9IGZ1bmN0aW9uKGUsIHQsIHIxOCwgbiwgaSkge1xuICAgIHZhciBvLCBzLCB1ID0gaSAqIDggLSBuIC0gMSwgaCA9ICgxIDw8IHUpIC0gMSwgcDIgPSBoID4+IDEsIGYyID0gLTcsIGMyID0gcjE4ID8gaSAtIDEgOiAwLCBVMiA9IHIxOCA/IC0xIDogMSwgbCA9IGVbdCArIGMyXTtcbiAgICBmb3IgKGMyICs9IFUyLCBvID0gbCAmICgxIDw8IC1mMikgLSAxLCBsID4+PSAtZjIsIGYyICs9IHU7IGYyID4gMDsgbyA9IG8gKiAyNTYgKyBlW3QgKyBjMl0sIGMyICs9IFUyLCBmMiAtPSA4KSA7XG4gICAgZm9yIChzID0gbyAmICgxIDw8IC1mMikgLSAxLCBvID4+PSAtZjIsIGYyICs9IG47IGYyID4gMDsgcyA9IHMgKiAyNTYgKyBlW3QgKyBjMl0sIGMyICs9IFUyLCBmMiAtPSA4KSA7XG4gICAgaWYgKG8gPT09IDApIG8gPSAxIC0gcDI7XG4gICAgZWxzZSB7XG4gICAgICBpZiAobyA9PT0gaCkgcmV0dXJuIHMgPyBOYU4gOiAobCA/IC0xIDogMSkgKiAoMSAvIDApO1xuICAgICAgcyA9IHMgKyBNYXRoLnBvdygyLCBuKSwgbyA9IG8gLSBwMjtcbiAgICB9XG4gICAgcmV0dXJuIChsID8gLTEgOiAxKSAqIHMgKiBNYXRoLnBvdygyLCBvIC0gbik7XG4gIH07XG4gIG10Mi53cml0ZSA9IGZ1bmN0aW9uKGUsIHQsIHIxOCwgbiwgaSwgbykge1xuICAgIHZhciBzLCB1LCBoLCBwMiA9IG8gKiA4IC0gaSAtIDEsIGYyID0gKDEgPDwgcDIpIC0gMSwgYzIgPSBmMiA+PiAxLCBVMiA9IGkgPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwLCBsID0gbiA/IDAgOiBvIC0gMSwgUjIgPSBuID8gMSA6IC0xLCBHMiA9IHQgPCAwIHx8IHQgPT09IDAgJiYgMSAvIHQgPCAwID8gMSA6IDA7XG4gICAgZm9yICh0ID0gTWF0aC5hYnModCksIGlzTmFOKHQpIHx8IHQgPT09IDEgLyAwID8gKHUgPSBpc05hTih0KSA/IDEgOiAwLCBzID0gZjIpIDogKHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKHQpIC8gTWF0aC5MTjIpLCB0ICogKGggPSBNYXRoLnBvdygyLCAtcykpIDwgMSAmJiAocy0tLCBoICo9IDIpLCBzICsgYzIgPj0gMSA/IHQgKz0gVTIgLyBoIDogdCArPSBVMiAqIE1hdGgucG93KDIsIDEgLSBjMiksIHQgKiBoID49IDIgJiYgKHMrKywgaCAvPSAyKSwgcyArIGMyID49IGYyID8gKHUgPSAwLCBzID0gZjIpIDogcyArIGMyID49IDEgPyAodSA9ICh0ICogaCAtIDEpICogTWF0aC5wb3coMiwgaSksIHMgPSBzICsgYzIpIDogKHUgPSB0ICogTWF0aC5wb3coMiwgYzIgLSAxKSAqIE1hdGgucG93KDIsIGkpLCBzID0gMCkpOyBpID49IDg7IGVbcjE4ICsgbF0gPSB1ICYgMjU1LCBsICs9IFIyLCB1IC89IDI1NiwgaSAtPSA4KSA7XG4gICAgZm9yIChzID0gcyA8PCBpIHwgdSwgcDIgKz0gaTsgcDIgPiAwOyBlW3IxOCArIGxdID0gcyAmIDI1NSwgbCArPSBSMiwgcyAvPSAyNTYsIHAyIC09IDgpIDtcbiAgICBlW3IxOCArIGwgLSBSMl0gfD0gRzIgKiAxMjg7XG4gIH07XG59KTtcbnZhciBudDIgPSBUMigocTIpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBCdDIgPSBjdDIoKSwgSDIgPSB6dDIoKSwgSnQgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIikgOiBudWxsO1xuICBxMi5CdWZmZXIgPSBhO1xuICBxMi5TbG93QnVmZmVyID0gVnIyO1xuICBxMi5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuICB2YXIgcnQyID0gMjE0NzQ4MzY0NztcbiAgcTIua01heExlbmd0aCA9IHJ0MjtcbiAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID0gcXIyKCk7XG4gICFhLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgPCBcInVcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKTtcbiAgZnVuY3Rpb24gcXIyKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZSA9IG5ldyBVaW50OEFycmF5KDEpLCB0ID0geyBmb286IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gNDI7XG4gICAgICB9IH07XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIFVpbnQ4QXJyYXkucHJvdG90eXBlKSwgT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIHQpLCBlLmZvbygpID09PSA0MjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLCBcInBhcmVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGEuaXNCdWZmZXIodGhpcykpIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgfSB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLCBcIm9mZnNldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGEuaXNCdWZmZXIodGhpcykpIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7XG4gIH0gfSk7XG4gIGZ1bmN0aW9uIFMoZSkge1xuICAgIGlmIChlID4gcnQyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7XG4gICAgbGV0IHQgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIGEucHJvdG90eXBlKSwgdDtcbiAgfVxuICBmdW5jdGlvbiBhKGUsIHQsIHIxOCkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKTtcbiAgICAgIHJldHVybiBUdDIoZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjIoZSwgdCwgcjE4KTtcbiAgfVxuICBhLnBvb2xTaXplID0gODE5MjtcbiAgZnVuY3Rpb24gdHIyKGUsIHQsIHIxOCkge1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gWXIyKGUsIHQpO1xuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpIHJldHVybiB2cjIoZSk7XG4gICAgaWYgKGUgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIGUpO1xuICAgIGlmIChBKGUsIEFycmF5QnVmZmVyKSB8fCBlICYmIEEoZS5idWZmZXIsIEFycmF5QnVmZmVyKSB8fCB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPCBcInVcIiAmJiAoQShlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHwgZSAmJiBBKGUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSByZXR1cm4gYnQyKGUsIHQsIHIxOCk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyk7XG4gICAgbGV0IG4gPSBlLnZhbHVlT2YgJiYgZS52YWx1ZU9mKCk7XG4gICAgaWYgKG4gIT0gbnVsbCAmJiBuICE9PSBlKSByZXR1cm4gYS5mcm9tKG4sIHQsIHIxOCk7XG4gICAgbGV0IGkgPSBXcjIoZSk7XG4gICAgaWYgKGkpIHJldHVybiBpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiYgdHlwZW9mIGVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBhLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLCB0LCByMTgpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIiArIHR5cGVvZiBlKTtcbiAgfVxuICBhLmZyb20gPSBmdW5jdGlvbihlLCB0LCByMTgpIHtcbiAgICByZXR1cm4gdHIyKGUsIHQsIHIxOCk7XG4gIH07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihhLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYSwgVWludDhBcnJheSk7XG4gIGZ1bmN0aW9uIHJyMihlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKTtcbiAgICBpZiAoZSA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtcbiAgfVxuICBmdW5jdGlvbiBHcjIoZSwgdCwgcjE4KSB7XG4gICAgcmV0dXJuIHJyMihlKSwgZSA8PSAwID8gUyhlKSA6IHQgIT09IHZvaWQgMCA/IHR5cGVvZiByMTggPT0gXCJzdHJpbmdcIiA/IFMoZSkuZmlsbCh0LCByMTgpIDogUyhlKS5maWxsKHQpIDogUyhlKTtcbiAgfVxuICBhLmFsbG9jID0gZnVuY3Rpb24oZSwgdCwgcjE4KSB7XG4gICAgcmV0dXJuIEdyMihlLCB0LCByMTgpO1xuICB9O1xuICBmdW5jdGlvbiBUdDIoZSkge1xuICAgIHJldHVybiBycjIoZSksIFMoZSA8IDAgPyAwIDogSXQyKGUpIHwgMCk7XG4gIH1cbiAgYS5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gVHQyKGUpO1xuICB9O1xuICBhLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gVHQyKGUpO1xuICB9O1xuICBmdW5jdGlvbiBZcjIoZSwgdCkge1xuICAgIGlmICgodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCB0ID09PSBcIlwiKSAmJiAodCA9IFwidXRmOFwiKSwgIWEuaXNFbmNvZGluZyh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgdCk7XG4gICAgbGV0IHIxOCA9IGVyMihlLCB0KSB8IDAsIG4gPSBTKHIxOCksIGkgPSBuLndyaXRlKGUsIHQpO1xuICAgIHJldHVybiBpICE9PSByMTggJiYgKG4gPSBuLnNsaWNlKDAsIGkpKSwgbjtcbiAgfVxuICBmdW5jdGlvbiBFdDIoZSkge1xuICAgIGxldCB0ID0gZS5sZW5ndGggPCAwID8gMCA6IEl0MihlLmxlbmd0aCkgfCAwLCByMTggPSBTKHQpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdDsgbiArPSAxKSByMThbbl0gPSBlW25dICYgMjU1O1xuICAgIHJldHVybiByMTg7XG4gIH1cbiAgZnVuY3Rpb24gdnIyKGUpIHtcbiAgICBpZiAoQShlLCBVaW50OEFycmF5KSkge1xuICAgICAgbGV0IHQgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICAgIHJldHVybiBidDIodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIEV0MihlKTtcbiAgfVxuICBmdW5jdGlvbiBidDIoZSwgdCwgcjE4KSB7XG4gICAgaWYgKHQgPCAwIHx8IGUuYnl0ZUxlbmd0aCA8IHQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpO1xuICAgIGlmIChlLmJ5dGVMZW5ndGggPCB0ICsgKHIxOCB8fCAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7XG4gICAgbGV0IG47XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiByMTggPT09IHZvaWQgMCA/IG4gPSBuZXcgVWludDhBcnJheShlKSA6IHIxOCA9PT0gdm9pZCAwID8gbiA9IG5ldyBVaW50OEFycmF5KGUsIHQpIDogbiA9IG5ldyBVaW50OEFycmF5KGUsIHQsIHIxOCksIE9iamVjdC5zZXRQcm90b3R5cGVPZihuLCBhLnByb3RvdHlwZSksIG47XG4gIH1cbiAgZnVuY3Rpb24gV3IyKGUpIHtcbiAgICBpZiAoYS5pc0J1ZmZlcihlKSkge1xuICAgICAgbGV0IHQgPSBJdDIoZS5sZW5ndGgpIHwgMCwgcjE4ID0gUyh0KTtcbiAgICAgIHJldHVybiByMTgubGVuZ3RoID09PSAwIHx8IGUuY29weShyMTgsIDAsIDAsIHQpLCByMTg7XG4gICAgfVxuICAgIGlmIChlLmxlbmd0aCAhPT0gdm9pZCAwKSByZXR1cm4gdHlwZW9mIGUubGVuZ3RoICE9IFwibnVtYmVyXCIgfHwgVXQyKGUubGVuZ3RoKSA/IFMoMCkgOiBFdDIoZSk7XG4gICAgaWYgKGUudHlwZSA9PT0gXCJCdWZmZXJcIiAmJiBBcnJheS5pc0FycmF5KGUuZGF0YSkpIHJldHVybiBFdDIoZS5kYXRhKTtcbiAgfVxuICBmdW5jdGlvbiBJdDIoZSkge1xuICAgIGlmIChlID49IHJ0MikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIgKyBydDIudG9TdHJpbmcoMTYpICsgXCIgYnl0ZXNcIik7XG4gICAgcmV0dXJuIGUgfCAwO1xuICB9XG4gIGZ1bmN0aW9uIFZyMihlKSB7XG4gICAgcmV0dXJuICtlICE9IGUgJiYgKGUgPSAwKSwgYS5hbGxvYygrZSk7XG4gIH1cbiAgYS5pc0J1ZmZlciA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCAhPSBudWxsICYmIHQuX2lzQnVmZmVyID09PSB0cnVlICYmIHQgIT09IGEucHJvdG90eXBlO1xuICB9O1xuICBhLmNvbXBhcmUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICBpZiAoQSh0LCBVaW50OEFycmF5KSAmJiAodCA9IGEuZnJvbSh0LCB0Lm9mZnNldCwgdC5ieXRlTGVuZ3RoKSksIEEocjE4LCBVaW50OEFycmF5KSAmJiAocjE4ID0gYS5mcm9tKHIxOCwgcjE4Lm9mZnNldCwgcjE4LmJ5dGVMZW5ndGgpKSwgIWEuaXNCdWZmZXIodCkgfHwgIWEuaXNCdWZmZXIocjE4KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpO1xuICAgIGlmICh0ID09PSByMTgpIHJldHVybiAwO1xuICAgIGxldCBuID0gdC5sZW5ndGgsIGkgPSByMTgubGVuZ3RoO1xuICAgIGZvciAobGV0IG8gPSAwLCBzID0gTWF0aC5taW4obiwgaSk7IG8gPCBzOyArK28pIGlmICh0W29dICE9PSByMThbb10pIHtcbiAgICAgIG4gPSB0W29dLCBpID0gcjE4W29dO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBuIDwgaSA/IC0xIDogaSA8IG4gPyAxIDogMDtcbiAgfTtcbiAgYS5pc0VuY29kaW5nID0gZnVuY3Rpb24odCkge1xuICAgIHN3aXRjaCAoU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGEuY29uY2F0ID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICBpZiAodC5sZW5ndGggPT09IDApIHJldHVybiBhLmFsbG9jKDApO1xuICAgIGxldCBuO1xuICAgIGlmIChyMTggPT09IHZvaWQgMCkgZm9yIChyMTggPSAwLCBuID0gMDsgbiA8IHQubGVuZ3RoOyArK24pIHIxOCArPSB0W25dLmxlbmd0aDtcbiAgICBsZXQgaSA9IGEuYWxsb2NVbnNhZmUocjE4KSwgbyA9IDA7XG4gICAgZm9yIChuID0gMDsgbiA8IHQubGVuZ3RoOyArK24pIHtcbiAgICAgIGxldCBzID0gdFtuXTtcbiAgICAgIGlmIChBKHMsIFVpbnQ4QXJyYXkpKSBvICsgcy5sZW5ndGggPiBpLmxlbmd0aCA/IChhLmlzQnVmZmVyKHMpIHx8IChzID0gYS5mcm9tKHMpKSwgcy5jb3B5KGksIG8pKSA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGksIHMsIG8pO1xuICAgICAgZWxzZSBpZiAoYS5pc0J1ZmZlcihzKSkgcy5jb3B5KGksIG8pO1xuICAgICAgZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICAgIG8gKz0gcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuICBmdW5jdGlvbiBlcjIoZSwgdCkge1xuICAgIGlmIChhLmlzQnVmZmVyKGUpKSByZXR1cm4gZS5sZW5ndGg7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlKSB8fCBBKGUsIEFycmF5QnVmZmVyKSkgcmV0dXJuIGUuYnl0ZUxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlKTtcbiAgICBsZXQgcjE4ID0gZS5sZW5ndGgsIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWU7XG4gICAgaWYgKCFuICYmIHIxOCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgbGV0IGkgPSBmYWxzZTtcbiAgICBmb3IgKDsgOyApIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgIHJldHVybiByMTg7XG4gICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIHJldHVybiBBdDIoZSkubGVuZ3RoO1xuICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICByZXR1cm4gcjE4ICogMjtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIHIxOCA+Pj4gMTtcbiAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgcmV0dXJuIGNyMihlKS5sZW5ndGg7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaSkgcmV0dXJuIG4gPyAtMSA6IEF0MihlKS5sZW5ndGg7XG4gICAgICAgIHQgPSAoXCJcIiArIHQpLnRvTG93ZXJDYXNlKCksIGkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhLmJ5dGVMZW5ndGggPSBlcjI7XG4gIGZ1bmN0aW9uIHpyMihlLCB0LCByMTgpIHtcbiAgICBsZXQgbiA9IGZhbHNlO1xuICAgIGlmICgodCA9PT0gdm9pZCAwIHx8IHQgPCAwKSAmJiAodCA9IDApLCB0ID4gdGhpcy5sZW5ndGggfHwgKChyMTggPT09IHZvaWQgMCB8fCByMTggPiB0aGlzLmxlbmd0aCkgJiYgKHIxOCA9IHRoaXMubGVuZ3RoKSwgcjE4IDw9IDApIHx8IChyMTggPj4+PSAwLCB0ID4+Pj0gMCwgcjE4IDw9IHQpKSByZXR1cm4gXCJcIjtcbiAgICBmb3IgKGUgfHwgKGUgPSBcInV0ZjhcIik7IDsgKSBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIG9lKHRoaXMsIHQsIHIxOCk7XG4gICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIHJldHVybiBpcjIodGhpcywgdCwgcjE4KTtcbiAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICByZXR1cm4gbmUyKHRoaXMsIHQsIHIxOCk7XG4gICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgIHJldHVybiBpZTIodGhpcywgdCwgcjE4KTtcbiAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgcmV0dXJuIHJlMih0aGlzLCB0LCByMTgpO1xuICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICByZXR1cm4gc2UyKHRoaXMsIHQsIHIxOCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgZSk7XG4gICAgICAgIGUgPSAoZSArIFwiXCIpLnRvTG93ZXJDYXNlKCksIG4gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuICBmdW5jdGlvbiBrMihlLCB0LCByMTgpIHtcbiAgICBsZXQgbiA9IGVbdF07XG4gICAgZVt0XSA9IGVbcjE4XSwgZVtyMThdID0gbjtcbiAgfVxuICBhLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgdCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0ICUgMiAhPT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtcbiAgICBmb3IgKGxldCByMTggPSAwOyByMTggPCB0OyByMTggKz0gMikgazIodGhpcywgcjE4LCByMTggKyAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgYS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHQgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodCAlIDQgIT09IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7XG4gICAgZm9yIChsZXQgcjE4ID0gMDsgcjE4IDwgdDsgcjE4ICs9IDQpIGsyKHRoaXMsIHIxOCwgcjE4ICsgMyksIGsyKHRoaXMsIHIxOCArIDEsIHIxOCArIDIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBhLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgdCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0ICUgOCAhPT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtcbiAgICBmb3IgKGxldCByMTggPSAwOyByMTggPCB0OyByMTggKz0gOCkgazIodGhpcywgcjE4LCByMTggKyA3KSwgazIodGhpcywgcjE4ICsgMSwgcjE4ICsgNiksIGsyKHRoaXMsIHIxOCArIDIsIHIxOCArIDUpLCBrMih0aGlzLCByMTggKyAzLCByMTggKyA0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgdCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiB0ID09PSAwID8gXCJcIiA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyBpcjIodGhpcywgMCwgdCkgOiB6cjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgYS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBhLnByb3RvdHlwZS50b1N0cmluZztcbiAgYS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24odCkge1xuICAgIGlmICghYS5pc0J1ZmZlcih0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gICAgcmV0dXJuIHRoaXMgPT09IHQgPyB0cnVlIDogYS5jb21wYXJlKHRoaXMsIHQpID09PSAwO1xuICB9O1xuICBhLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHQgPSBcIlwiLCByMTggPSBxMi5JTlNQRUNUX01BWF9CWVRFUztcbiAgICByZXR1cm4gdCA9IHRoaXMudG9TdHJpbmcoXCJoZXhcIiwgMCwgcjE4KS5yZXBsYWNlKC8oLnsyfSkvZywgXCIkMSBcIikudHJpbSgpLCB0aGlzLmxlbmd0aCA+IHIxOCAmJiAodCArPSBcIiAuLi4gXCIpLCBcIjxCdWZmZXIgXCIgKyB0ICsgXCI+XCI7XG4gIH07XG4gIEp0ICYmIChhLnByb3RvdHlwZVtKdF0gPSBhLnByb3RvdHlwZS5pbnNwZWN0KTtcbiAgYS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKHQsIHIxOCwgbiwgaSwgbykge1xuICAgIGlmIChBKHQsIFVpbnQ4QXJyYXkpICYmICh0ID0gYS5mcm9tKHQsIHQub2Zmc2V0LCB0LmJ5dGVMZW5ndGgpKSwgIWEuaXNCdWZmZXIodCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB0KTtcbiAgICBpZiAocjE4ID09PSB2b2lkIDAgJiYgKHIxOCA9IDApLCBuID09PSB2b2lkIDAgJiYgKG4gPSB0ID8gdC5sZW5ndGggOiAwKSwgaSA9PT0gdm9pZCAwICYmIChpID0gMCksIG8gPT09IHZvaWQgMCAmJiAobyA9IHRoaXMubGVuZ3RoKSwgcjE4IDwgMCB8fCBuID4gdC5sZW5ndGggfHwgaSA8IDAgfHwgbyA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICBpZiAoaSA+PSBvICYmIHIxOCA+PSBuKSByZXR1cm4gMDtcbiAgICBpZiAoaSA+PSBvKSByZXR1cm4gLTE7XG4gICAgaWYgKHIxOCA+PSBuKSByZXR1cm4gMTtcbiAgICBpZiAocjE4ID4+Pj0gMCwgbiA+Pj49IDAsIGkgPj4+PSAwLCBvID4+Pj0gMCwgdGhpcyA9PT0gdCkgcmV0dXJuIDA7XG4gICAgbGV0IHMgPSBvIC0gaSwgdSA9IG4gLSByMTgsIGggPSBNYXRoLm1pbihzLCB1KSwgcDIgPSB0aGlzLnNsaWNlKGksIG8pLCBmMiA9IHQuc2xpY2UocjE4LCBuKTtcbiAgICBmb3IgKGxldCBjMiA9IDA7IGMyIDwgaDsgKytjMikgaWYgKHAyW2MyXSAhPT0gZjJbYzJdKSB7XG4gICAgICBzID0gcDJbYzJdLCB1ID0gZjJbYzJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzIDwgdSA/IC0xIDogdSA8IHMgPyAxIDogMDtcbiAgfTtcbiAgZnVuY3Rpb24gbnIyKGUsIHQsIHIxOCwgbiwgaSkge1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0eXBlb2YgcjE4ID09IFwic3RyaW5nXCIgPyAobiA9IHIxOCwgcjE4ID0gMCkgOiByMTggPiAyMTQ3NDgzNjQ3ID8gcjE4ID0gMjE0NzQ4MzY0NyA6IHIxOCA8IC0yMTQ3NDgzNjQ4ICYmIChyMTggPSAtMjE0NzQ4MzY0OCksIHIxOCA9ICtyMTgsIFV0MihyMTgpICYmIChyMTggPSBpID8gMCA6IGUubGVuZ3RoIC0gMSksIHIxOCA8IDAgJiYgKHIxOCA9IGUubGVuZ3RoICsgcjE4KSwgcjE4ID49IGUubGVuZ3RoKSB7XG4gICAgICBpZiAoaSkgcmV0dXJuIC0xO1xuICAgICAgcjE4ID0gZS5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSBpZiAocjE4IDwgMCkgaWYgKGkpIHIxOCA9IDA7XG4gICAgZWxzZSByZXR1cm4gLTE7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBhLmZyb20odCwgbikpLCBhLmlzQnVmZmVyKHQpKSByZXR1cm4gdC5sZW5ndGggPT09IDAgPyAtMSA6IFh0MihlLCB0LCByMTgsIG4sIGkpO1xuICAgIGlmICh0eXBlb2YgdCA9PSBcIm51bWJlclwiKSByZXR1cm4gdCA9IHQgJiAyNTUsIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09IFwiZnVuY3Rpb25cIiA/IGkgPyBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSwgdCwgcjE4KSA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSwgdCwgcjE4KSA6IFh0MihlLCBbdF0sIHIxOCwgbiwgaSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKTtcbiAgfVxuICBmdW5jdGlvbiBYdDIoZSwgdCwgcjE4LCBuLCBpKSB7XG4gICAgbGV0IG8gPSAxLCBzID0gZS5sZW5ndGgsIHUgPSB0Lmxlbmd0aDtcbiAgICBpZiAobiAhPT0gdm9pZCAwICYmIChuID0gU3RyaW5nKG4pLnRvTG93ZXJDYXNlKCksIG4gPT09IFwidWNzMlwiIHx8IG4gPT09IFwidWNzLTJcIiB8fCBuID09PSBcInV0ZjE2bGVcIiB8fCBuID09PSBcInV0Zi0xNmxlXCIpKSB7XG4gICAgICBpZiAoZS5sZW5ndGggPCAyIHx8IHQubGVuZ3RoIDwgMikgcmV0dXJuIC0xO1xuICAgICAgbyA9IDIsIHMgLz0gMiwgdSAvPSAyLCByMTggLz0gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaChmMiwgYzIpIHtcbiAgICAgIHJldHVybiBvID09PSAxID8gZjJbYzJdIDogZjIucmVhZFVJbnQxNkJFKGMyICogbyk7XG4gICAgfVxuICAgIGxldCBwMjtcbiAgICBpZiAoaSkge1xuICAgICAgbGV0IGYyID0gLTE7XG4gICAgICBmb3IgKHAyID0gcjE4OyBwMiA8IHM7IHAyKyspIGlmIChoKGUsIHAyKSA9PT0gaCh0LCBmMiA9PT0gLTEgPyAwIDogcDIgLSBmMikpIHtcbiAgICAgICAgaWYgKGYyID09PSAtMSAmJiAoZjIgPSBwMiksIHAyIC0gZjIgKyAxID09PSB1KSByZXR1cm4gZjIgKiBvO1xuICAgICAgfSBlbHNlIGYyICE9PSAtMSAmJiAocDIgLT0gcDIgLSBmMiksIGYyID0gLTE7XG4gICAgfSBlbHNlIGZvciAocjE4ICsgdSA+IHMgJiYgKHIxOCA9IHMgLSB1KSwgcDIgPSByMTg7IHAyID49IDA7IHAyLS0pIHtcbiAgICAgIGxldCBmMiA9IHRydWU7XG4gICAgICBmb3IgKGxldCBjMiA9IDA7IGMyIDwgdTsgYzIrKykgaWYgKGgoZSwgcDIgKyBjMikgIT09IGgodCwgYzIpKSB7XG4gICAgICAgIGYyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGYyKSByZXR1cm4gcDI7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBhLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2YodCwgcjE4LCBuKSAhPT0gLTE7XG4gIH07XG4gIGEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gbnIyKHRoaXMsIHQsIHIxOCwgbiwgdHJ1ZSk7XG4gIH07XG4gIGEucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgcmV0dXJuIG5yMih0aGlzLCB0LCByMTgsIG4sIGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gSnIyKGUsIHQsIHIxOCwgbikge1xuICAgIHIxOCA9IE51bWJlcihyMTgpIHx8IDA7XG4gICAgbGV0IGkgPSBlLmxlbmd0aCAtIHIxODtcbiAgICBuID8gKG4gPSBOdW1iZXIobiksIG4gPiBpICYmIChuID0gaSkpIDogbiA9IGk7XG4gICAgbGV0IG8gPSB0Lmxlbmd0aDtcbiAgICBuID4gbyAvIDIgJiYgKG4gPSBvIC8gMik7XG4gICAgbGV0IHM7XG4gICAgZm9yIChzID0gMDsgcyA8IG47ICsrcykge1xuICAgICAgbGV0IHUgPSBwYXJzZUludCh0LnN1YnN0cihzICogMiwgMiksIDE2KTtcbiAgICAgIGlmIChVdDIodSkpIHJldHVybiBzO1xuICAgICAgZVtyMTggKyBzXSA9IHU7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIGZ1bmN0aW9uIFhyMihlLCB0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gZXQyKEF0Mih0LCBlLmxlbmd0aCAtIHIxOCksIGUsIHIxOCwgbik7XG4gIH1cbiAgZnVuY3Rpb24gWnIyKGUsIHQsIHIxOCwgbikge1xuICAgIHJldHVybiBldDIoZmUyKHQpLCBlLCByMTgsIG4pO1xuICB9XG4gIGZ1bmN0aW9uIFFyMihlLCB0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gZXQyKGNyMih0KSwgZSwgcjE4LCBuKTtcbiAgfVxuICBmdW5jdGlvbiB0ZTIoZSwgdCwgcjE4LCBuKSB7XG4gICAgcmV0dXJuIGV0MihjZTIodCwgZS5sZW5ndGggLSByMTgpLCBlLCByMTgsIG4pO1xuICB9XG4gIGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24odCwgcjE4LCBuLCBpKSB7XG4gICAgaWYgKHIxOCA9PT0gdm9pZCAwKSBpID0gXCJ1dGY4XCIsIG4gPSB0aGlzLmxlbmd0aCwgcjE4ID0gMDtcbiAgICBlbHNlIGlmIChuID09PSB2b2lkIDAgJiYgdHlwZW9mIHIxOCA9PSBcInN0cmluZ1wiKSBpID0gcjE4LCBuID0gdGhpcy5sZW5ndGgsIHIxOCA9IDA7XG4gICAgZWxzZSBpZiAoaXNGaW5pdGUocjE4KSkgcjE4ID0gcjE4ID4+PiAwLCBpc0Zpbml0ZShuKSA/IChuID0gbiA+Pj4gMCwgaSA9PT0gdm9pZCAwICYmIChpID0gXCJ1dGY4XCIpKSA6IChpID0gbiwgbiA9IHZvaWQgMCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgICBsZXQgbyA9IHRoaXMubGVuZ3RoIC0gcjE4O1xuICAgIGlmICgobiA9PT0gdm9pZCAwIHx8IG4gPiBvKSAmJiAobiA9IG8pLCB0Lmxlbmd0aCA+IDAgJiYgKG4gPCAwIHx8IHIxOCA8IDApIHx8IHIxOCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO1xuICAgIGkgfHwgKGkgPSBcInV0ZjhcIik7XG4gICAgbGV0IHMgPSBmYWxzZTtcbiAgICBmb3IgKDsgOyApIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICByZXR1cm4gSnIyKHRoaXMsIHQsIHIxOCwgbik7XG4gICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIHJldHVybiBYcjIodGhpcywgdCwgcjE4LCBuKTtcbiAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICByZXR1cm4gWnIyKHRoaXMsIHQsIHIxOCwgbik7XG4gICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgIHJldHVybiBRcjIodGhpcywgdCwgcjE4LCBuKTtcbiAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgcmV0dXJuIHRlMih0aGlzLCB0LCByMTgsIG4pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHMpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIGkpO1xuICAgICAgICBpID0gKFwiXCIgKyBpKS50b0xvd2VyQ2FzZSgpLCBzID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiQnVmZmVyXCIsIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKSB9O1xuICB9O1xuICBmdW5jdGlvbiByZTIoZSwgdCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPT09IDAgJiYgcjE4ID09PSBlLmxlbmd0aCA/IEJ0Mi5mcm9tQnl0ZUFycmF5KGUpIDogQnQyLmZyb21CeXRlQXJyYXkoZS5zbGljZSh0LCByMTgpKTtcbiAgfVxuICBmdW5jdGlvbiBpcjIoZSwgdCwgcjE4KSB7XG4gICAgcjE4ID0gTWF0aC5taW4oZS5sZW5ndGgsIHIxOCk7XG4gICAgbGV0IG4gPSBbXSwgaSA9IHQ7XG4gICAgZm9yICg7IGkgPCByMTg7ICkge1xuICAgICAgbGV0IG8gPSBlW2ldLCBzID0gbnVsbCwgdSA9IG8gPiAyMzkgPyA0IDogbyA+IDIyMyA/IDMgOiBvID4gMTkxID8gMiA6IDE7XG4gICAgICBpZiAoaSArIHUgPD0gcjE4KSB7XG4gICAgICAgIGxldCBoLCBwMiwgZjIsIGMyO1xuICAgICAgICBzd2l0Y2ggKHUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBvIDwgMTI4ICYmIChzID0gbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoID0gZVtpICsgMV0sIChoICYgMTkyKSA9PT0gMTI4ICYmIChjMiA9IChvICYgMzEpIDw8IDYgfCBoICYgNjMsIGMyID4gMTI3ICYmIChzID0gYzIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGggPSBlW2kgKyAxXSwgcDIgPSBlW2kgKyAyXSwgKGggJiAxOTIpID09PSAxMjggJiYgKHAyICYgMTkyKSA9PT0gMTI4ICYmIChjMiA9IChvICYgMTUpIDw8IDEyIHwgKGggJiA2MykgPDwgNiB8IHAyICYgNjMsIGMyID4gMjA0NyAmJiAoYzIgPCA1NTI5NiB8fCBjMiA+IDU3MzQzKSAmJiAocyA9IGMyKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBoID0gZVtpICsgMV0sIHAyID0gZVtpICsgMl0sIGYyID0gZVtpICsgM10sIChoICYgMTkyKSA9PT0gMTI4ICYmIChwMiAmIDE5MikgPT09IDEyOCAmJiAoZjIgJiAxOTIpID09PSAxMjggJiYgKGMyID0gKG8gJiAxNSkgPDwgMTggfCAoaCAmIDYzKSA8PCAxMiB8IChwMiAmIDYzKSA8PCA2IHwgZjIgJiA2MywgYzIgPiA2NTUzNSAmJiBjMiA8IDExMTQxMTIgJiYgKHMgPSBjMikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzID09PSBudWxsID8gKHMgPSA2NTUzMywgdSA9IDEpIDogcyA+IDY1NTM1ICYmIChzIC09IDY1NTM2LCBuLnB1c2gocyA+Pj4gMTAgJiAxMDIzIHwgNTUyOTYpLCBzID0gNTYzMjAgfCBzICYgMTAyMyksIG4ucHVzaChzKSwgaSArPSB1O1xuICAgIH1cbiAgICByZXR1cm4gZWUyKG4pO1xuICB9XG4gIHZhciBadDIgPSA0MDk2O1xuICBmdW5jdGlvbiBlZTIoZSkge1xuICAgIGxldCB0ID0gZS5sZW5ndGg7XG4gICAgaWYgKHQgPD0gWnQyKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGUpO1xuICAgIGxldCByMTggPSBcIlwiLCBuID0gMDtcbiAgICBmb3IgKDsgbiA8IHQ7ICkgcjE4ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBlLnNsaWNlKG4sIG4gKz0gWnQyKSk7XG4gICAgcmV0dXJuIHIxODtcbiAgfVxuICBmdW5jdGlvbiBuZTIoZSwgdCwgcjE4KSB7XG4gICAgbGV0IG4gPSBcIlwiO1xuICAgIHIxOCA9IE1hdGgubWluKGUubGVuZ3RoLCByMTgpO1xuICAgIGZvciAobGV0IGkgPSB0OyBpIDwgcjE4OyArK2kpIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlW2ldICYgMTI3KTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBpZTIoZSwgdCwgcjE4KSB7XG4gICAgbGV0IG4gPSBcIlwiO1xuICAgIHIxOCA9IE1hdGgubWluKGUubGVuZ3RoLCByMTgpO1xuICAgIGZvciAobGV0IGkgPSB0OyBpIDwgcjE4OyArK2kpIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlW2ldKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBmdW5jdGlvbiBvZShlLCB0LCByMTgpIHtcbiAgICBsZXQgbiA9IGUubGVuZ3RoO1xuICAgICghdCB8fCB0IDwgMCkgJiYgKHQgPSAwKSwgKCFyMTggfHwgcjE4IDwgMCB8fCByMTggPiBuKSAmJiAocjE4ID0gbik7XG4gICAgbGV0IGkgPSBcIlwiO1xuICAgIGZvciAobGV0IG8gPSB0OyBvIDwgcjE4OyArK28pIGkgKz0gcGUyW2Vbb11dO1xuICAgIHJldHVybiBpO1xuICB9XG4gIGZ1bmN0aW9uIHNlMihlLCB0LCByMTgpIHtcbiAgICBsZXQgbiA9IGUuc2xpY2UodCwgcjE4KSwgaSA9IFwiXCI7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuLmxlbmd0aCAtIDE7IG8gKz0gMikgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5bb10gKyBuW28gKyAxXSAqIDI1Nik7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgYS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICBsZXQgbiA9IHRoaXMubGVuZ3RoO1xuICAgIHQgPSB+fnQsIHIxOCA9IHIxOCA9PT0gdm9pZCAwID8gbiA6IH5+cjE4LCB0IDwgMCA/ICh0ICs9IG4sIHQgPCAwICYmICh0ID0gMCkpIDogdCA+IG4gJiYgKHQgPSBuKSwgcjE4IDwgMCA/IChyMTggKz0gbiwgcjE4IDwgMCAmJiAocjE4ID0gMCkpIDogcjE4ID4gbiAmJiAocjE4ID0gbiksIHIxOCA8IHQgJiYgKHIxOCA9IHQpO1xuICAgIGxldCBpID0gdGhpcy5zdWJhcnJheSh0LCByMTgpO1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YoaSwgYS5wcm90b3R5cGUpLCBpO1xuICB9O1xuICBmdW5jdGlvbiB5MihlLCB0LCByMTgpIHtcbiAgICBpZiAoZSAlIDEgIT09IDAgfHwgZSA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO1xuICAgIGlmIChlICsgdCA+IHIxOCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO1xuICB9XG4gIGEucHJvdG90eXBlLnJlYWRVaW50TEUgPSBhLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgdCA9IHQgPj4+IDAsIHIxOCA9IHIxOCA+Pj4gMCwgbiB8fCB5Mih0LCByMTgsIHRoaXMubGVuZ3RoKTtcbiAgICBsZXQgaSA9IHRoaXNbdF0sIG8gPSAxLCBzID0gMDtcbiAgICBmb3IgKDsgKytzIDwgcjE4ICYmIChvICo9IDI1Nik7ICkgaSArPSB0aGlzW3QgKyBzXSAqIG87XG4gICAgcmV0dXJuIGk7XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRVaW50QkUgPSBhLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgdCA9IHQgPj4+IDAsIHIxOCA9IHIxOCA+Pj4gMCwgbiB8fCB5Mih0LCByMTgsIHRoaXMubGVuZ3RoKTtcbiAgICBsZXQgaSA9IHRoaXNbdCArIC0tcjE4XSwgbyA9IDE7XG4gICAgZm9yICg7IHIxOCA+IDAgJiYgKG8gKj0gMjU2KTsgKSBpICs9IHRoaXNbdCArIC0tcjE4XSAqIG87XG4gICAgcmV0dXJuIGk7XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRVaW50OCA9IGEucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKHQsIHIxOCkge1xuICAgIHJldHVybiB0ID0gdCA+Pj4gMCwgcjE4IHx8IHkyKHQsIDEsIHRoaXMubGVuZ3RoKSwgdGhpc1t0XTtcbiAgfTtcbiAgYS5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gYS5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgMiwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdIHwgdGhpc1t0ICsgMV0gPDwgODtcbiAgfTtcbiAgYS5wcm90b3R5cGUucmVhZFVpbnQxNkJFID0gYS5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgMiwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdIDw8IDggfCB0aGlzW3QgKyAxXTtcbiAgfTtcbiAgYS5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gYS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1t0XSB8IHRoaXNbdCArIDFdIDw8IDggfCB0aGlzW3QgKyAyXSA8PCAxNikgKyB0aGlzW3QgKyAzXSAqIDE2Nzc3MjE2O1xuICB9O1xuICBhLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPSBhLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICByZXR1cm4gdCA9IHQgPj4+IDAsIHIxOCB8fCB5Mih0LCA0LCB0aGlzLmxlbmd0aCksIHRoaXNbdF0gKiAxNjc3NzIxNiArICh0aGlzW3QgKyAxXSA8PCAxNiB8IHRoaXNbdCArIDJdIDw8IDggfCB0aGlzW3QgKyAzXSk7XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IEwoZnVuY3Rpb24odCkge1xuICAgIHQgPSB0ID4+PiAwLCBqMih0LCBcIm9mZnNldFwiKTtcbiAgICBsZXQgcjE4ID0gdGhpc1t0XSwgbiA9IHRoaXNbdCArIDddO1xuICAgIChyMTggPT09IHZvaWQgMCB8fCBuID09PSB2b2lkIDApICYmIFcodCwgdGhpcy5sZW5ndGggLSA4KTtcbiAgICBsZXQgaSA9IHIxOCArIHRoaXNbKyt0XSAqIDIgKiogOCArIHRoaXNbKyt0XSAqIDIgKiogMTYgKyB0aGlzWysrdF0gKiAyICoqIDI0LCBvID0gdGhpc1srK3RdICsgdGhpc1srK3RdICogMiAqKiA4ICsgdGhpc1srK3RdICogMiAqKiAxNiArIG4gKiAyICoqIDI0O1xuICAgIHJldHVybiBCaWdJbnQoaSkgKyAoQmlnSW50KG8pIDw8IEJpZ0ludCgzMikpO1xuICB9KTtcbiAgYS5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gTChmdW5jdGlvbih0KSB7XG4gICAgdCA9IHQgPj4+IDAsIGoyKHQsIFwib2Zmc2V0XCIpO1xuICAgIGxldCByMTggPSB0aGlzW3RdLCBuID0gdGhpc1t0ICsgN107XG4gICAgKHIxOCA9PT0gdm9pZCAwIHx8IG4gPT09IHZvaWQgMCkgJiYgVyh0LCB0aGlzLmxlbmd0aCAtIDgpO1xuICAgIGxldCBpID0gcjE4ICogMiAqKiAyNCArIHRoaXNbKyt0XSAqIDIgKiogMTYgKyB0aGlzWysrdF0gKiAyICoqIDggKyB0aGlzWysrdF0sIG8gPSB0aGlzWysrdF0gKiAyICoqIDI0ICsgdGhpc1srK3RdICogMiAqKiAxNiArIHRoaXNbKyt0XSAqIDIgKiogOCArIG47XG4gICAgcmV0dXJuIChCaWdJbnQoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobyk7XG4gIH0pO1xuICBhLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICB0ID0gdCA+Pj4gMCwgcjE4ID0gcjE4ID4+PiAwLCBuIHx8IHkyKHQsIHIxOCwgdGhpcy5sZW5ndGgpO1xuICAgIGxldCBpID0gdGhpc1t0XSwgbyA9IDEsIHMgPSAwO1xuICAgIGZvciAoOyArK3MgPCByMTggJiYgKG8gKj0gMjU2KTsgKSBpICs9IHRoaXNbdCArIHNdICogbztcbiAgICByZXR1cm4gbyAqPSAxMjgsIGkgPj0gbyAmJiAoaSAtPSBNYXRoLnBvdygyLCA4ICogcjE4KSksIGk7XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHQgPSB0ID4+PiAwLCByMTggPSByMTggPj4+IDAsIG4gfHwgeTIodCwgcjE4LCB0aGlzLmxlbmd0aCk7XG4gICAgbGV0IGkgPSByMTgsIG8gPSAxLCBzID0gdGhpc1t0ICsgLS1pXTtcbiAgICBmb3IgKDsgaSA+IDAgJiYgKG8gKj0gMjU2KTsgKSBzICs9IHRoaXNbdCArIC0taV0gKiBvO1xuICAgIHJldHVybiBvICo9IDEyOCwgcyA+PSBvICYmIChzIC09IE1hdGgucG93KDIsIDggKiByMTgpKSwgcztcbiAgfTtcbiAgYS5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICByZXR1cm4gdCA9IHQgPj4+IDAsIHIxOCB8fCB5Mih0LCAxLCB0aGlzLmxlbmd0aCksIHRoaXNbdF0gJiAxMjggPyAoMjU1IC0gdGhpc1t0XSArIDEpICogLTEgOiB0aGlzW3RdO1xuICB9O1xuICBhLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uKHQsIHIxOCkge1xuICAgIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIGxldCBuID0gdGhpc1t0XSB8IHRoaXNbdCArIDFdIDw8IDg7XG4gICAgcmV0dXJuIG4gJiAzMjc2OCA/IG4gfCA0Mjk0OTAxNzYwIDogbjtcbiAgfTtcbiAgYS5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICB0ID0gdCA+Pj4gMCwgcjE4IHx8IHkyKHQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICBsZXQgbiA9IHRoaXNbdCArIDFdIHwgdGhpc1t0XSA8PCA4O1xuICAgIHJldHVybiBuICYgMzI3NjggPyBuIHwgNDI5NDkwMTc2MCA6IG47XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdIHwgdGhpc1t0ICsgMV0gPDwgOCB8IHRoaXNbdCArIDJdIDw8IDE2IHwgdGhpc1t0ICsgM10gPDwgMjQ7XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24odCwgcjE4KSB7XG4gICAgcmV0dXJuIHQgPSB0ID4+PiAwLCByMTggfHwgeTIodCwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdIDw8IDI0IHwgdGhpc1t0ICsgMV0gPDwgMTYgfCB0aGlzW3QgKyAyXSA8PCA4IHwgdGhpc1t0ICsgM107XG4gIH07XG4gIGEucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gTChmdW5jdGlvbih0KSB7XG4gICAgdCA9IHQgPj4+IDAsIGoyKHQsIFwib2Zmc2V0XCIpO1xuICAgIGxldCByMTggPSB0aGlzW3RdLCBuID0gdGhpc1t0ICsgN107XG4gICAgKHIxOCA9PT0gdm9pZCAwIHx8IG4gPT09IHZvaWQgMCkgJiYgVyh0LCB0aGlzLmxlbmd0aCAtIDgpO1xuICAgIGxldCBpID0gdGhpc1t0ICsgNF0gKyB0aGlzW3QgKyA1XSAqIDIgKiogOCArIHRoaXNbdCArIDZdICogMiAqKiAxNiArIChuIDw8IDI0KTtcbiAgICByZXR1cm4gKEJpZ0ludChpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChyMTggKyB0aGlzWysrdF0gKiAyICoqIDggKyB0aGlzWysrdF0gKiAyICoqIDE2ICsgdGhpc1srK3RdICogMiAqKiAyNCk7XG4gIH0pO1xuICBhLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IEwoZnVuY3Rpb24odCkge1xuICAgIHQgPSB0ID4+PiAwLCBqMih0LCBcIm9mZnNldFwiKTtcbiAgICBsZXQgcjE4ID0gdGhpc1t0XSwgbiA9IHRoaXNbdCArIDddO1xuICAgIChyMTggPT09IHZvaWQgMCB8fCBuID09PSB2b2lkIDApICYmIFcodCwgdGhpcy5sZW5ndGggLSA4KTtcbiAgICBsZXQgaSA9IChyMTggPDwgMjQpICsgdGhpc1srK3RdICogMiAqKiAxNiArIHRoaXNbKyt0XSAqIDIgKiogOCArIHRoaXNbKyt0XTtcbiAgICByZXR1cm4gKEJpZ0ludChpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludCh0aGlzWysrdF0gKiAyICoqIDI0ICsgdGhpc1srK3RdICogMiAqKiAxNiArIHRoaXNbKyt0XSAqIDIgKiogOCArIG4pO1xuICB9KTtcbiAgYS5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICByZXR1cm4gdCA9IHQgPj4+IDAsIHIxOCB8fCB5Mih0LCA0LCB0aGlzLmxlbmd0aCksIEgyLnJlYWQodGhpcywgdCwgdHJ1ZSwgMjMsIDQpO1xuICB9O1xuICBhLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uKHQsIHIxOCkge1xuICAgIHJldHVybiB0ID0gdCA+Pj4gMCwgcjE4IHx8IHkyKHQsIDQsIHRoaXMubGVuZ3RoKSwgSDIucmVhZCh0aGlzLCB0LCBmYWxzZSwgMjMsIDQpO1xuICB9O1xuICBhLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICByZXR1cm4gdCA9IHQgPj4+IDAsIHIxOCB8fCB5Mih0LCA4LCB0aGlzLmxlbmd0aCksIEgyLnJlYWQodGhpcywgdCwgdHJ1ZSwgNTIsIDgpO1xuICB9O1xuICBhLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbih0LCByMTgpIHtcbiAgICByZXR1cm4gdCA9IHQgPj4+IDAsIHIxOCB8fCB5Mih0LCA4LCB0aGlzLmxlbmd0aCksIEgyLnJlYWQodGhpcywgdCwgZmFsc2UsIDUyLCA4KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDIoZSwgdCwgcjE4LCBuLCBpLCBvKSB7XG4gICAgaWYgKCFhLmlzQnVmZmVyKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICBpZiAodCA+IGkgfHwgdCA8IG8pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIGlmIChyMTggKyBuID4gZS5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICB9XG4gIGEucHJvdG90eXBlLndyaXRlVWludExFID0gYS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbih0LCByMTgsIG4sIGkpIHtcbiAgICBpZiAodCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gPSBuID4+PiAwLCAhaSkge1xuICAgICAgbGV0IHUgPSBNYXRoLnBvdygyLCA4ICogbikgLSAxO1xuICAgICAgZDIodGhpcywgdCwgcjE4LCBuLCB1LCAwKTtcbiAgICB9XG4gICAgbGV0IG8gPSAxLCBzID0gMDtcbiAgICBmb3IgKHRoaXNbcjE4XSA9IHQgJiAyNTU7ICsrcyA8IG4gJiYgKG8gKj0gMjU2KTsgKSB0aGlzW3IxOCArIHNdID0gdCAvIG8gJiAyNTU7XG4gICAgcmV0dXJuIHIxOCArIG47XG4gIH07XG4gIGEucHJvdG90eXBlLndyaXRlVWludEJFID0gYS5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbih0LCByMTgsIG4sIGkpIHtcbiAgICBpZiAodCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gPSBuID4+PiAwLCAhaSkge1xuICAgICAgbGV0IHUgPSBNYXRoLnBvdygyLCA4ICogbikgLSAxO1xuICAgICAgZDIodGhpcywgdCwgcjE4LCBuLCB1LCAwKTtcbiAgICB9XG4gICAgbGV0IG8gPSBuIC0gMSwgcyA9IDE7XG4gICAgZm9yICh0aGlzW3IxOCArIG9dID0gdCAmIDI1NTsgLS1vID49IDAgJiYgKHMgKj0gMjU2KTsgKSB0aGlzW3IxOCArIG9dID0gdCAvIHMgJiAyNTU7XG4gICAgcmV0dXJuIHIxOCArIG47XG4gIH07XG4gIGEucHJvdG90eXBlLndyaXRlVWludDggPSBhLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgcmV0dXJuIHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCBuIHx8IGQyKHRoaXMsIHQsIHIxOCwgMSwgMjU1LCAwKSwgdGhpc1tyMThdID0gdCAmIDI1NSwgcjE4ICsgMTtcbiAgfTtcbiAgYS5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9IGEucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gfHwgZDIodGhpcywgdCwgcjE4LCAyLCA2NTUzNSwgMCksIHRoaXNbcjE4XSA9IHQgJiAyNTUsIHRoaXNbcjE4ICsgMV0gPSB0ID4+PiA4LCByMTggKyAyO1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID0gYS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiB0ID0gK3QsIHIxOCA9IHIxOCA+Pj4gMCwgbiB8fCBkMih0aGlzLCB0LCByMTgsIDIsIDY1NTM1LCAwKSwgdGhpc1tyMThdID0gdCA+Pj4gOCwgdGhpc1tyMTggKyAxXSA9IHQgJiAyNTUsIHIxOCArIDI7XG4gIH07XG4gIGEucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBhLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgcmV0dXJuIHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCBuIHx8IGQyKHRoaXMsIHQsIHIxOCwgNCwgNDI5NDk2NzI5NSwgMCksIHRoaXNbcjE4ICsgM10gPSB0ID4+PiAyNCwgdGhpc1tyMTggKyAyXSA9IHQgPj4+IDE2LCB0aGlzW3IxOCArIDFdID0gdCA+Pj4gOCwgdGhpc1tyMThdID0gdCAmIDI1NSwgcjE4ICsgNDtcbiAgfTtcbiAgYS5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IGEucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gfHwgZDIodGhpcywgdCwgcjE4LCA0LCA0Mjk0OTY3Mjk1LCAwKSwgdGhpc1tyMThdID0gdCA+Pj4gMjQsIHRoaXNbcjE4ICsgMV0gPSB0ID4+PiAxNiwgdGhpc1tyMTggKyAyXSA9IHQgPj4+IDgsIHRoaXNbcjE4ICsgM10gPSB0ICYgMjU1LCByMTggKyA0O1xuICB9O1xuICBmdW5jdGlvbiBvcjIoZSwgdCwgcjE4LCBuLCBpKSB7XG4gICAgZnIyKHQsIG4sIGksIGUsIHIxOCwgNyk7XG4gICAgbGV0IG8gPSBOdW1iZXIodCAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgZVtyMTgrK10gPSBvLCBvID0gbyA+PiA4LCBlW3IxOCsrXSA9IG8sIG8gPSBvID4+IDgsIGVbcjE4KytdID0gbywgbyA9IG8gPj4gOCwgZVtyMTgrK10gPSBvO1xuICAgIGxldCBzID0gTnVtYmVyKHQgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgcmV0dXJuIGVbcjE4KytdID0gcywgcyA9IHMgPj4gOCwgZVtyMTgrK10gPSBzLCBzID0gcyA+PiA4LCBlW3IxOCsrXSA9IHMsIHMgPSBzID4+IDgsIGVbcjE4KytdID0gcywgcjE4O1xuICB9XG4gIGZ1bmN0aW9uIHNyMihlLCB0LCByMTgsIG4sIGkpIHtcbiAgICBmcjIodCwgbiwgaSwgZSwgcjE4LCA3KTtcbiAgICBsZXQgbyA9IE51bWJlcih0ICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICBlW3IxOCArIDddID0gbywgbyA9IG8gPj4gOCwgZVtyMTggKyA2XSA9IG8sIG8gPSBvID4+IDgsIGVbcjE4ICsgNV0gPSBvLCBvID0gbyA+PiA4LCBlW3IxOCArIDRdID0gbztcbiAgICBsZXQgcyA9IE51bWJlcih0ID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoNDI5NDk2NzI5NSkpO1xuICAgIHJldHVybiBlW3IxOCArIDNdID0gcywgcyA9IHMgPj4gOCwgZVtyMTggKyAyXSA9IHMsIHMgPSBzID4+IDgsIGVbcjE4ICsgMV0gPSBzLCBzID0gcyA+PiA4LCBlW3IxOF0gPSBzLCByMTggKyA4O1xuICB9XG4gIGEucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBMKGZ1bmN0aW9uKHQsIHIxOCA9IDApIHtcbiAgICByZXR1cm4gb3IyKHRoaXMsIHQsIHIxOCwgQmlnSW50KDApLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpO1xuICB9KTtcbiAgYS5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IEwoZnVuY3Rpb24odCwgcjE4ID0gMCkge1xuICAgIHJldHVybiBzcjIodGhpcywgdCwgcjE4LCBCaWdJbnQoMCksIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gIH0pO1xuICBhLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24odCwgcjE4LCBuLCBpKSB7XG4gICAgaWYgKHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCAhaSkge1xuICAgICAgbGV0IGggPSBNYXRoLnBvdygyLCA4ICogbiAtIDEpO1xuICAgICAgZDIodGhpcywgdCwgcjE4LCBuLCBoIC0gMSwgLWgpO1xuICAgIH1cbiAgICBsZXQgbyA9IDAsIHMgPSAxLCB1ID0gMDtcbiAgICBmb3IgKHRoaXNbcjE4XSA9IHQgJiAyNTU7ICsrbyA8IG4gJiYgKHMgKj0gMjU2KTsgKSB0IDwgMCAmJiB1ID09PSAwICYmIHRoaXNbcjE4ICsgbyAtIDFdICE9PSAwICYmICh1ID0gMSksIHRoaXNbcjE4ICsgb10gPSAodCAvIHMgPj4gMCkgLSB1ICYgMjU1O1xuICAgIHJldHVybiByMTggKyBuO1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24odCwgcjE4LCBuLCBpKSB7XG4gICAgaWYgKHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCAhaSkge1xuICAgICAgbGV0IGggPSBNYXRoLnBvdygyLCA4ICogbiAtIDEpO1xuICAgICAgZDIodGhpcywgdCwgcjE4LCBuLCBoIC0gMSwgLWgpO1xuICAgIH1cbiAgICBsZXQgbyA9IG4gLSAxLCBzID0gMSwgdSA9IDA7XG4gICAgZm9yICh0aGlzW3IxOCArIG9dID0gdCAmIDI1NTsgLS1vID49IDAgJiYgKHMgKj0gMjU2KTsgKSB0IDwgMCAmJiB1ID09PSAwICYmIHRoaXNbcjE4ICsgbyArIDFdICE9PSAwICYmICh1ID0gMSksIHRoaXNbcjE4ICsgb10gPSAodCAvIHMgPj4gMCkgLSB1ICYgMjU1O1xuICAgIHJldHVybiByMTggKyBuO1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gfHwgZDIodGhpcywgdCwgcjE4LCAxLCAxMjcsIC0xMjgpLCB0IDwgMCAmJiAodCA9IDI1NSArIHQgKyAxKSwgdGhpc1tyMThdID0gdCAmIDI1NSwgcjE4ICsgMTtcbiAgfTtcbiAgYS5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odCwgcjE4LCBuKSB7XG4gICAgcmV0dXJuIHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCBuIHx8IGQyKHRoaXMsIHQsIHIxOCwgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbcjE4XSA9IHQgJiAyNTUsIHRoaXNbcjE4ICsgMV0gPSB0ID4+PiA4LCByMTggKyAyO1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gfHwgZDIodGhpcywgdCwgcjE4LCAyLCAzMjc2NywgLTMyNzY4KSwgdGhpc1tyMThdID0gdCA+Pj4gOCwgdGhpc1tyMTggKyAxXSA9IHQgJiAyNTUsIHIxOCArIDI7XG4gIH07XG4gIGEucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiB0ID0gK3QsIHIxOCA9IHIxOCA+Pj4gMCwgbiB8fCBkMih0aGlzLCB0LCByMTgsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KSwgdGhpc1tyMThdID0gdCAmIDI1NSwgdGhpc1tyMTggKyAxXSA9IHQgPj4+IDgsIHRoaXNbcjE4ICsgMl0gPSB0ID4+PiAxNiwgdGhpc1tyMTggKyAzXSA9IHQgPj4+IDI0LCByMTggKyA0O1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIG4gfHwgZDIodGhpcywgdCwgcjE4LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCksIHQgPCAwICYmICh0ID0gNDI5NDk2NzI5NSArIHQgKyAxKSwgdGhpc1tyMThdID0gdCA+Pj4gMjQsIHRoaXNbcjE4ICsgMV0gPSB0ID4+PiAxNiwgdGhpc1tyMTggKyAyXSA9IHQgPj4+IDgsIHRoaXNbcjE4ICsgM10gPSB0ICYgMjU1LCByMTggKyA0O1xuICB9O1xuICBhLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBMKGZ1bmN0aW9uKHQsIHIxOCA9IDApIHtcbiAgICByZXR1cm4gb3IyKHRoaXMsIHQsIHIxOCwgLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSwgQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKTtcbiAgfSk7XG4gIGEucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IEwoZnVuY3Rpb24odCwgcjE4ID0gMCkge1xuICAgIHJldHVybiBzcjIodGhpcywgdCwgcjE4LCAtQmlnSW50KFwiMHg4MDAwMDAwMDAwMDAwMDAwXCIpLCBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIikpO1xuICB9KTtcbiAgZnVuY3Rpb24gYXIyKGUsIHQsIHIxOCwgbiwgaSwgbykge1xuICAgIGlmIChyMTggKyBuID4gZS5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIGlmIChyMTggPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgfVxuICBmdW5jdGlvbiB1cjIoZSwgdCwgcjE4LCBuLCBpKSB7XG4gICAgcmV0dXJuIHQgPSArdCwgcjE4ID0gcjE4ID4+PiAwLCBpIHx8IGFyMihlLCB0LCByMTgsIDQsIDM0MDI4MjM0NjYzODUyODg2ZTIyLCAtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpLCBIMi53cml0ZShlLCB0LCByMTgsIG4sIDIzLCA0KSwgcjE4ICsgNDtcbiAgfVxuICBhLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbih0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gdXIyKHRoaXMsIHQsIHIxOCwgdHJ1ZSwgbik7XG4gIH07XG4gIGEucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiB1cjIodGhpcywgdCwgcjE4LCBmYWxzZSwgbik7XG4gIH07XG4gIGZ1bmN0aW9uIGhyMihlLCB0LCByMTgsIG4sIGkpIHtcbiAgICByZXR1cm4gdCA9ICt0LCByMTggPSByMTggPj4+IDAsIGkgfHwgYXIyKGUsIHQsIHIxOCwgOCwgMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCAtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKSwgSDIud3JpdGUoZSwgdCwgcjE4LCBuLCA1MiwgOCksIHIxOCArIDg7XG4gIH1cbiAgYS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiBocjIodGhpcywgdCwgcjE4LCB0cnVlLCBuKTtcbiAgfTtcbiAgYS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKHQsIHIxOCwgbikge1xuICAgIHJldHVybiBocjIodGhpcywgdCwgcjE4LCBmYWxzZSwgbik7XG4gIH07XG4gIGEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0LCByMTgsIG4sIGkpIHtcbiAgICBpZiAoIWEuaXNCdWZmZXIodCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7XG4gICAgaWYgKG4gfHwgKG4gPSAwKSwgIWkgJiYgaSAhPT0gMCAmJiAoaSA9IHRoaXMubGVuZ3RoKSwgcjE4ID49IHQubGVuZ3RoICYmIChyMTggPSB0Lmxlbmd0aCksIHIxOCB8fCAocjE4ID0gMCksIGkgPiAwICYmIGkgPCBuICYmIChpID0gbiksIGkgPT09IG4gfHwgdC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIGlmIChyMTggPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7XG4gICAgaWYgKG4gPCAwIHx8IG4gPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIGlmIChpIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICBpID4gdGhpcy5sZW5ndGggJiYgKGkgPSB0aGlzLmxlbmd0aCksIHQubGVuZ3RoIC0gcjE4IDwgaSAtIG4gJiYgKGkgPSB0Lmxlbmd0aCAtIHIxOCArIG4pO1xuICAgIGxldCBvID0gaSAtIG47XG4gICAgcmV0dXJuIHRoaXMgPT09IHQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT0gXCJmdW5jdGlvblwiID8gdGhpcy5jb3B5V2l0aGluKHIxOCwgbiwgaSkgOiBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0LCB0aGlzLnN1YmFycmF5KG4sIGkpLCByMTgpLCBvO1xuICB9O1xuICBhLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odCwgcjE4LCBuLCBpKSB7XG4gICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgcjE4ID09IFwic3RyaW5nXCIgPyAoaSA9IHIxOCwgcjE4ID0gMCwgbiA9IHRoaXMubGVuZ3RoKSA6IHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKGkgPSBuLCBuID0gdGhpcy5sZW5ndGgpLCBpICE9PSB2b2lkIDAgJiYgdHlwZW9mIGkgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICBpZiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiAhYS5pc0VuY29kaW5nKGkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIgKyBpKTtcbiAgICAgIGlmICh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsZXQgcyA9IHQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgKGkgPT09IFwidXRmOFwiICYmIHMgPCAxMjggfHwgaSA9PT0gXCJsYXRpbjFcIikgJiYgKHQgPSBzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgdHlwZW9mIHQgPT0gXCJudW1iZXJcIiA/IHQgPSB0ICYgMjU1IDogdHlwZW9mIHQgPT0gXCJib29sZWFuXCIgJiYgKHQgPSBOdW1iZXIodCkpO1xuICAgIGlmIChyMTggPCAwIHx8IHRoaXMubGVuZ3RoIDwgcjE4IHx8IHRoaXMubGVuZ3RoIDwgbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7XG4gICAgaWYgKG4gPD0gcjE4KSByZXR1cm4gdGhpcztcbiAgICByMTggPSByMTggPj4+IDAsIG4gPSBuID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IG4gPj4+IDAsIHQgfHwgKHQgPSAwKTtcbiAgICBsZXQgbztcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJudW1iZXJcIikgZm9yIChvID0gcjE4OyBvIDwgbjsgKytvKSB0aGlzW29dID0gdDtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBzID0gYS5pc0J1ZmZlcih0KSA/IHQgOiBhLmZyb20odCwgaSksIHUgPSBzLmxlbmd0aDtcbiAgICAgIGlmICh1ID09PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdCArICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKTtcbiAgICAgIGZvciAobyA9IDA7IG8gPCBuIC0gcjE4OyArK28pIHRoaXNbbyArIHIxOF0gPSBzW28gJSB1XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHZhciBLMiA9IHt9O1xuICBmdW5jdGlvbiBTdDIoZSwgdCwgcjE4KSB7XG4gICAgSzJbZV0gPSBjbGFzcyBleHRlbmRzIHIxOCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IHZhbHVlOiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSksIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7ZX1dYCwgdGhpcy5zdGFjaywgZGVsZXRlIHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICAgIGdldCBjb2RlKCkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHNldCBjb2RlKGkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGksIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2V9XTogJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFN0MihcIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EU1wiLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgPyBgJHtlfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgIDogXCJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzXCI7XG4gIH0sIFJhbmdlRXJyb3IpO1xuICBTdDIoXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke2V9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB0fWA7XG4gIH0sIFR5cGVFcnJvcik7XG4gIFN0MihcIkVSUl9PVVRfT0ZfUkFOR0VcIiwgZnVuY3Rpb24oZSwgdCwgcjE4KSB7XG4gICAgbGV0IG4gPSBgVGhlIHZhbHVlIG9mIFwiJHtlfVwiIGlzIG91dCBvZiByYW5nZS5gLCBpID0gcjE4O1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHIxOCkgJiYgTWF0aC5hYnMocjE4KSA+IDIgKiogMzIgPyBpID0gUXQyKFN0cmluZyhyMTgpKSA6IHR5cGVvZiByMTggPT0gXCJiaWdpbnRcIiAmJiAoaSA9IFN0cmluZyhyMTgpLCAocjE4ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgcjE4IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpICYmIChpID0gUXQyKGkpKSwgaSArPSBcIm5cIiksIG4gKz0gYCBJdCBtdXN0IGJlICR7dH0uIFJlY2VpdmVkICR7aX1gLCBuO1xuICB9LCBSYW5nZUVycm9yKTtcbiAgZnVuY3Rpb24gUXQyKGUpIHtcbiAgICBsZXQgdCA9IFwiXCIsIHIxOCA9IGUubGVuZ3RoLCBuID0gZVswXSA9PT0gXCItXCIgPyAxIDogMDtcbiAgICBmb3IgKDsgcjE4ID49IG4gKyA0OyByMTggLT0gMykgdCA9IGBfJHtlLnNsaWNlKHIxOCAtIDMsIHIxOCl9JHt0fWA7XG4gICAgcmV0dXJuIGAke2Uuc2xpY2UoMCwgcjE4KX0ke3R9YDtcbiAgfVxuICBmdW5jdGlvbiBhZTIoZSwgdCwgcjE4KSB7XG4gICAgajIodCwgXCJvZmZzZXRcIiksIChlW3RdID09PSB2b2lkIDAgfHwgZVt0ICsgcjE4XSA9PT0gdm9pZCAwKSAmJiBXKHQsIGUubGVuZ3RoIC0gKHIxOCArIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBmcjIoZSwgdCwgcjE4LCBuLCBpLCBvKSB7XG4gICAgaWYgKGUgPiByMTggfHwgZSA8IHQpIHtcbiAgICAgIGxldCBzID0gdHlwZW9mIHQgPT0gXCJiaWdpbnRcIiA/IFwiblwiIDogXCJcIiwgdTtcbiAgICAgIHRocm93IG8gPiAzID8gdCA9PT0gMCB8fCB0ID09PSBCaWdJbnQoMCkgPyB1ID0gYD49IDAke3N9IGFuZCA8IDIke3N9ICoqICR7KG8gKyAxKSAqIDh9JHtzfWAgOiB1ID0gYD49IC0oMiR7c30gKiogJHsobyArIDEpICogOCAtIDF9JHtzfSkgYW5kIDwgMiAqKiAkeyhvICsgMSkgKiA4IC0gMX0ke3N9YCA6IHUgPSBgPj0gJHt0fSR7c30gYW5kIDw9ICR7cjE4fSR7c31gLCBuZXcgSzIuRVJSX09VVF9PRl9SQU5HRShcInZhbHVlXCIsIHUsIGUpO1xuICAgIH1cbiAgICBhZTIobiwgaSwgbyk7XG4gIH1cbiAgZnVuY3Rpb24gajIoZSwgdCkge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgSzIuRVJSX0lOVkFMSURfQVJHX1RZUEUodCwgXCJudW1iZXJcIiwgZSk7XG4gIH1cbiAgZnVuY3Rpb24gVyhlLCB0LCByMTgpIHtcbiAgICB0aHJvdyBNYXRoLmZsb29yKGUpICE9PSBlID8gKGoyKGUsIHIxOCksIG5ldyBLMi5FUlJfT1VUX09GX1JBTkdFKHIxOCB8fCBcIm9mZnNldFwiLCBcImFuIGludGVnZXJcIiwgZSkpIDogdCA8IDAgPyBuZXcgSzIuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCkgOiBuZXcgSzIuRVJSX09VVF9PRl9SQU5HRShyMTggfHwgXCJvZmZzZXRcIiwgYD49ICR7cjE4ID8gMSA6IDB9IGFuZCA8PSAke3R9YCwgZSk7XG4gIH1cbiAgdmFyIHVlMiA9IC9bXisvMC05QS1aYS16LV9dL2c7XG4gIGZ1bmN0aW9uIGhlMihlKSB7XG4gICAgaWYgKGUgPSBlLnNwbGl0KFwiPVwiKVswXSwgZSA9IGUudHJpbSgpLnJlcGxhY2UodWUyLCBcIlwiKSwgZS5sZW5ndGggPCAyKSByZXR1cm4gXCJcIjtcbiAgICBmb3IgKDsgZS5sZW5ndGggJSA0ICE9PSAwOyApIGUgPSBlICsgXCI9XCI7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gQXQyKGUsIHQpIHtcbiAgICB0ID0gdCB8fCAxIC8gMDtcbiAgICBsZXQgcjE4LCBuID0gZS5sZW5ndGgsIGkgPSBudWxsLCBvID0gW107XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBuOyArK3MpIHtcbiAgICAgIGlmIChyMTggPSBlLmNoYXJDb2RlQXQocyksIHIxOCA+IDU1Mjk1ICYmIHIxOCA8IDU3MzQ0KSB7XG4gICAgICAgIGlmICghaSkge1xuICAgICAgICAgIGlmIChyMTggPiA1NjMxOSkge1xuICAgICAgICAgICAgKHQgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHMgKyAxID09PSBuKSB7XG4gICAgICAgICAgICAodCAtPSAzKSA+IC0xICYmIG8ucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gcjE4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyMTggPCA1NjMyMCkge1xuICAgICAgICAgICh0IC09IDMpID4gLTEgJiYgby5wdXNoKDIzOSwgMTkxLCAxODkpLCBpID0gcjE4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHIxOCA9IChpIC0gNTUyOTYgPDwgMTAgfCByMTggLSA1NjMyMCkgKyA2NTUzNjtcbiAgICAgIH0gZWxzZSBpICYmICh0IC09IDMpID4gLTEgJiYgby5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgaWYgKGkgPSBudWxsLCByMTggPCAxMjgpIHtcbiAgICAgICAgaWYgKCh0IC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgIG8ucHVzaChyMTgpO1xuICAgICAgfSBlbHNlIGlmIChyMTggPCAyMDQ4KSB7XG4gICAgICAgIGlmICgodCAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICBvLnB1c2gocjE4ID4+IDYgfCAxOTIsIHIxOCAmIDYzIHwgMTI4KTtcbiAgICAgIH0gZWxzZSBpZiAocjE4IDwgNjU1MzYpIHtcbiAgICAgICAgaWYgKCh0IC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgIG8ucHVzaChyMTggPj4gMTIgfCAyMjQsIHIxOCA+PiA2ICYgNjMgfCAxMjgsIHIxOCAmIDYzIHwgMTI4KTtcbiAgICAgIH0gZWxzZSBpZiAocjE4IDwgMTExNDExMikge1xuICAgICAgICBpZiAoKHQgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgICAgby5wdXNoKHIxOCA+PiAxOCB8IDI0MCwgcjE4ID4+IDEyICYgNjMgfCAxMjgsIHIxOCA+PiA2ICYgNjMgfCAxMjgsIHIxOCAmIDYzIHwgMTI4KTtcbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIGZlMihlKSB7XG4gICAgbGV0IHQgPSBbXTtcbiAgICBmb3IgKGxldCByMTggPSAwOyByMTggPCBlLmxlbmd0aDsgKytyMTgpIHQucHVzaChlLmNoYXJDb2RlQXQocjE4KSAmIDI1NSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gY2UyKGUsIHQpIHtcbiAgICBsZXQgcjE4LCBuLCBpLCBvID0gW107XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aCAmJiAhKCh0IC09IDIpIDwgMCk7ICsrcykgcjE4ID0gZS5jaGFyQ29kZUF0KHMpLCBuID0gcjE4ID4+IDgsIGkgPSByMTggJSAyNTYsIG8ucHVzaChpKSwgby5wdXNoKG4pO1xuICAgIHJldHVybiBvO1xuICB9XG4gIGZ1bmN0aW9uIGNyMihlKSB7XG4gICAgcmV0dXJuIEJ0Mi50b0J5dGVBcnJheShoZTIoZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGV0MihlLCB0LCByMTgsIG4pIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbiAmJiAhKGkgKyByMTggPj0gdC5sZW5ndGggfHwgaSA+PSBlLmxlbmd0aCk7ICsraSkgdFtpICsgcjE4XSA9IGVbaV07XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZnVuY3Rpb24gQShlLCB0KSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiB0IHx8IGUgIT0gbnVsbCAmJiBlLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgZS5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiYgZS5jb25zdHJ1Y3Rvci5uYW1lID09PSB0Lm5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gVXQyKGUpIHtcbiAgICByZXR1cm4gZSAhPT0gZTtcbiAgfVxuICB2YXIgcGUyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGUgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgdCA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IHIxOCA9IDA7IHIxOCA8IDE2OyArK3IxOCkge1xuICAgICAgbGV0IG4gPSByMTggKiAxNjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkgdFtuICsgaV0gPSBlW3IxOF0gKyBlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSgpO1xuICBmdW5jdGlvbiBMKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJpZ0ludCA+IFwidVwiID8gbGUyIDogZTtcbiAgfVxuICBmdW5jdGlvbiBsZTIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbn0pO1xudmFyIHByMiA9IFQyKChKZTIsIEZ0MikgPT4ge1xuICB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyAod2luZG93Lmdsb2JhbCA9IHdpbmRvdywgZ2xvYmFsLmZldGNoID0gd2luZG93LmZldGNoLCBGdDIuZXhwb3J0cyA9IHsgQnVmZmVyOiBudDIoKS5CdWZmZXIsIENyeXB0bzogd2luZG93LmNyeXB0byB9KSA6IEZ0Mi5leHBvcnRzID0geyBCdWZmZXI6IG50MigpLkJ1ZmZlciwgQ3J5cHRvOiBjcnlwdG8gfTtcbn0pO1xudmFyIEx0MiA9IHt9O1xuQXIyKEx0MiwgeyBBVlNDVGFwOiAoKSA9PiAkMiwgQXJ3ZWF2ZVNpZ25lcjogKCkgPT4gTjIsIERhdGFJdGVtOiAoKSA9PiBfMiwgTUFYX1RBR19CWVRFUzogKCkgPT4gdHQyLCBNSU5fQklOQVJZX1NJWkU6ICgpID0+IGdyMiwgU0lHX0NPTkZJRzogKCkgPT4gUDIsIFNpZ25hdHVyZUNvbmZpZzogKCkgPT4gQiwgU2lnbmVyOiAoKSA9PiBvdDIsIGNyZWF0ZURhdGE6ICgpID0+IGdlMiwgZGVzZXJpYWxpemVUYWdzOiAoKSA9PiBRLCBpbmRleFRvVHlwZTogKCkgPT4gd3QyLCBzZXJpYWxpemVUYWdzOiAoKSA9PiBkdDIsIHRhZ3NFeGNlZWRMaW1pdDogKCkgPT4ganIyIH0pO1xudmFyIG90MiA9IGNsYXNzIHtcbiAgc2lnbmVyO1xuICBwdWJsaWNLZXk7XG4gIHNpZ25hdHVyZVR5cGU7XG4gIHNpZ25hdHVyZUxlbmd0aDtcbiAgb3duZXJMZW5ndGg7XG4gIHBlbTtcbiAgc3RhdGljIHZlcmlmeSh0LCByMTgsIG4sIGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBpbXBsZW1lbnQgdmVyaWZ5IG1ldGhvZCBvbiBjaGlsZFwiKTtcbiAgfVxufTtcbnZhciB2dDIgPSBDKHozKCksIDEpO1xudmFyIHcyID0gQyhwdDIoKSwgMSk7XG5hc3luYyBmdW5jdGlvbiBYMihlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgbGV0IGkgPSAoMCwgdzIuY29uY2F0QnVmZmVycykoWygwLCB3Mi5zdHJpbmdUb0J1ZmZlcikoXCJsaXN0XCIpLCAoMCwgdzIuc3RyaW5nVG9CdWZmZXIpKGUubGVuZ3RoLnRvU3RyaW5nKCkpXSk7XG4gICAgcmV0dXJuIGF3YWl0IEd0MihlLCBhd2FpdCB4MigpLmhhc2goaSwgXCJTSEEtMzg0XCIpKTtcbiAgfVxuICBsZXQgdCA9IGUsIHIxOCA9ICgwLCB3Mi5jb25jYXRCdWZmZXJzKShbKDAsIHcyLnN0cmluZ1RvQnVmZmVyKShcImJsb2JcIiksICgwLCB3Mi5zdHJpbmdUb0J1ZmZlcikodC5ieXRlTGVuZ3RoLnRvU3RyaW5nKCkpXSksIG4gPSAoMCwgdzIuY29uY2F0QnVmZmVycykoW2F3YWl0IHgyKCkuaGFzaChyMTgsIFwiU0hBLTM4NFwiKSwgYXdhaXQgeDIoKS5oYXNoKHQsIFwiU0hBLTM4NFwiKV0pO1xuICByZXR1cm4gYXdhaXQgeDIoKS5oYXNoKG4sIFwiU0hBLTM4NFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEd0MihlLCB0KSB7XG4gIGlmIChlLmxlbmd0aCA8IDEpIHJldHVybiB0O1xuICBsZXQgcjE4ID0gKDAsIHcyLmNvbmNhdEJ1ZmZlcnMpKFt0LCBhd2FpdCBYMihlWzBdKV0pLCBuID0gYXdhaXQgeDIoKS5oYXNoKHIxOCwgXCJTSEEtMzg0XCIpO1xuICByZXR1cm4gYXdhaXQgR3QyKGUuc2xpY2UoMSksIG4pO1xufVxudmFyIFoyID0gQyhZdCgpLCAxKTtcbnZhciAkcjIgPSBaMi5kZWZhdWx0LmRlZmF1bHQgPyBaMi5kZWZhdWx0LmRlZmF1bHQgOiBaMi5kZWZhdWx0O1xudmFyIHl0MiA9IGNsYXNzIGV4dGVuZHMgJHIyIHtcbiAgZ2V0UHVibGljS2V5KHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkXCIpO1xuICB9XG59O1xudmFyIEtyMjtcbmZ1bmN0aW9uIHgyKCkge1xuICByZXR1cm4gS3IyID8/PSBuZXcgeXQyKCk7XG59XG52YXIgQjtcbihmdW5jdGlvbihlKSB7XG4gIGVbZS5BUldFQVZFID0gMV0gPSBcIkFSV0VBVkVcIiwgZVtlLkVEMjU1MTkgPSAyXSA9IFwiRUQyNTUxOVwiLCBlW2UuRVRIRVJFVU0gPSAzXSA9IFwiRVRIRVJFVU1cIiwgZVtlLlNPTEFOQSA9IDRdID0gXCJTT0xBTkFcIiwgZVtlLklOSkVDVEVEQVBUT1MgPSA1XSA9IFwiSU5KRUNURURBUFRPU1wiLCBlW2UuTVVMVElBUFRPUyA9IDZdID0gXCJNVUxUSUFQVE9TXCIsIGVbZS5UWVBFREVUSEVSRVVNID0gN10gPSBcIlRZUEVERVRIRVJFVU1cIjtcbn0pKEIgfHwgKEIgPSB7fSkpO1xudmFyIFAyID0geyBbQi5BUldFQVZFXTogeyBzaWdMZW5ndGg6IDUxMiwgcHViTGVuZ3RoOiA1MTIsIHNpZ05hbWU6IFwiYXJ3ZWF2ZVwiIH0sIFtCLkVEMjU1MTldOiB7IHNpZ0xlbmd0aDogNjQsIHB1Ykxlbmd0aDogMzIsIHNpZ05hbWU6IFwiZWQyNTUxOVwiIH0sIFtCLkVUSEVSRVVNXTogeyBzaWdMZW5ndGg6IDY1LCBwdWJMZW5ndGg6IDY1LCBzaWdOYW1lOiBcImV0aGVyZXVtXCIgfSwgW0IuU09MQU5BXTogeyBzaWdMZW5ndGg6IDY0LCBwdWJMZW5ndGg6IDMyLCBzaWdOYW1lOiBcInNvbGFuYVwiIH0sIFtCLklOSkVDVEVEQVBUT1NdOiB7IHNpZ0xlbmd0aDogNjQsIHB1Ykxlbmd0aDogMzIsIHNpZ05hbWU6IFwiaW5qZWN0ZWRBcHRvc1wiIH0sIFtCLk1VTFRJQVBUT1NdOiB7IHNpZ0xlbmd0aDogNjQgKiAzMiArIDQsIHB1Ykxlbmd0aDogMzIgKiAzMiArIDEsIHNpZ05hbWU6IFwibXVsdGlBcHRvc1wiIH0sIFtCLlRZUEVERVRIRVJFVU1dOiB7IHNpZ0xlbmd0aDogNjUsIHB1Ykxlbmd0aDogNDIsIHNpZ05hbWU6IFwidHlwZWRFdGhlcmV1bVwiIH0gfTtcbnZhciBOMiA9IGNsYXNzIHtcbiAgc2lnbmF0dXJlVHlwZSA9IDE7XG4gIG93bmVyTGVuZ3RoID0gUDJbMV0ucHViTGVuZ3RoO1xuICBzaWduYXR1cmVMZW5ndGggPSBQMlsxXS5zaWdMZW5ndGg7XG4gIGp3aztcbiAgcGs7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLnBrID0gdC5uLCB0aGlzLmp3ayA9IHQ7XG4gIH1cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gdnQyLmRlZmF1bHQudG9CdWZmZXIodGhpcy5wayk7XG4gIH1cbiAgc2lnbih0KSB7XG4gICAgcmV0dXJuIHgyKCkuc2lnbih0aGlzLmp3aywgdCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHZlcmlmeSh0LCByMTgsIG4pIHtcbiAgICByZXR1cm4gYXdhaXQgeDIoKS52ZXJpZnkodCwgcjE4LCBuKTtcbiAgfVxufTtcbnZhciB3dDIgPSB7IDE6IE4yIH07XG52YXIgRTIgPSBDKHozKCksIDEpO1xuYXN5bmMgZnVuY3Rpb24gdihlKSB7XG4gIHJldHVybiBYMihbKDAsIHcyLnN0cmluZ1RvQnVmZmVyKShcImRhdGFpdGVtXCIpLCAoMCwgdzIuc3RyaW5nVG9CdWZmZXIpKFwiMVwiKSwgKDAsIHcyLnN0cmluZ1RvQnVmZmVyKShlLnNpZ25hdHVyZVR5cGUudG9TdHJpbmcoKSksIGUucmF3T3duZXIsIGUucmF3VGFyZ2V0LCBlLnJhd0FuY2hvciwgZS5yYXdUYWdzLCBlLnJhd0RhdGFdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEhyMihlLCB0KSB7XG4gIGxldCByMTggPSBhd2FpdCB2KGUpLCBuID0gYXdhaXQgdC5zaWduKHIxOCksIGkgPSBhd2FpdCB4MigpLmhhc2gobik7XG4gIHJldHVybiB7IHNpZ25hdHVyZTogQnVmZmVyLmZyb20obiksIGlkOiBCdWZmZXIuZnJvbShpKSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gV3QyKGUsIHQpIHtcbiAgbGV0IHsgc2lnbmF0dXJlOiByMTgsIGlkOiBuIH0gPSBhd2FpdCBIcjIoZSwgdCk7XG4gIHJldHVybiBlLmdldFJhdygpLnNldChyMTgsIDIpLCBuO1xufVxudmFyICQyID0gY2xhc3Mge1xuICBidWY7XG4gIHBvcztcbiAgY29uc3RydWN0b3IodCA9IEJ1ZmZlci5hbGxvYyh0dDIpLCByMTggPSAwKSB7XG4gICAgdGhpcy5idWYgPSB0LCB0aGlzLnBvcyA9IHIxODtcbiAgfVxuICB3cml0ZVRhZ3ModCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0KSkgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbXVzdCBiZSBhcnJheVwiKTtcbiAgICBsZXQgcjE4ID0gdC5sZW5ndGgsIG47XG4gICAgaWYgKHIxOCkgZm9yICh0aGlzLndyaXRlTG9uZyhyMTgpLCBuID0gMDsgbiA8IHIxODsgbisrKSB7XG4gICAgICBsZXQgaSA9IHRbbl07XG4gICAgICBpZiAoaT8ubmFtZSA9PT0gdm9pZCAwIHx8IGk/LnZhbHVlID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YWcgZm9ybWF0IGZvciAke2l9LCBleHBlY3RlZCB7bmFtZTpzdHJpbmcsIHZhbHVlOiBzdHJpbmd9YCk7XG4gICAgICB0aGlzLndyaXRlU3RyaW5nKGkubmFtZSksIHRoaXMud3JpdGVTdHJpbmcoaS52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMud3JpdGVMb25nKDApO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIGxldCB0ID0gQnVmZmVyLmFsbG9jKHRoaXMucG9zKTtcbiAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmJ1Zi5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgdGFnIGJ5dGVzICgke3RoaXMucG9zfSA+ICR7dGhpcy5idWYubGVuZ3RofSlgKTtcbiAgICByZXR1cm4gdGhpcy5idWYuY29weSh0LCAwLCAwLCB0aGlzLnBvcyksIHQ7XG4gIH1cbiAgdGFnc0V4Y2VlZExpbWl0KCkge1xuICAgIHJldHVybiB0aGlzLnBvcyA+IHRoaXMuYnVmLmxlbmd0aDtcbiAgfVxuICB3cml0ZUxvbmcodCkge1xuICAgIGxldCByMTggPSB0aGlzLmJ1ZiwgbiwgaTtcbiAgICBpZiAodCA+PSAtMTA3Mzc0MTgyNCAmJiB0IDwgMTA3Mzc0MTgyNCkge1xuICAgICAgaSA9IHQgPj0gMCA/IHQgPDwgMSA6IH50IDw8IDEgfCAxO1xuICAgICAgZG9cbiAgICAgICAgcjE4W3RoaXMucG9zXSA9IGkgJiAxMjcsIGkgPj49IDc7XG4gICAgICB3aGlsZSAoaSAmJiAocjE4W3RoaXMucG9zKytdIHw9IDEyOCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gdCA+PSAwID8gdCAqIDIgOiAtdCAqIDIgLSAxO1xuICAgICAgZG9cbiAgICAgICAgcjE4W3RoaXMucG9zXSA9IG4gJiAxMjcsIG4gLz0gMTI4O1xuICAgICAgd2hpbGUgKG4gPj0gMSAmJiAocjE4W3RoaXMucG9zKytdIHw9IDEyOCkpO1xuICAgIH1cbiAgICB0aGlzLnBvcysrLCB0aGlzLmJ1ZiA9IHIxODtcbiAgfVxuICB3cml0ZVN0cmluZyh0KSB7XG4gICAgbGV0IHIxOCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHQpLCBuID0gdGhpcy5idWY7XG4gICAgdGhpcy53cml0ZUxvbmcocjE4KTtcbiAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLnBvcyArPSByMTgsICEodGhpcy5wb3MgPiBuLmxlbmd0aCkpIHtcbiAgICAgIGlmIChyMTggPiA2NCkgdGhpcy5idWYud3JpdGUodCwgdGhpcy5wb3MgLSByMTgsIHIxOCwgXCJ1dGY4XCIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBvLCBzLCB1LCBoO1xuICAgICAgICBmb3IgKG8gPSAwLCBzID0gcjE4OyBvIDwgczsgbysrKSB1ID0gdC5jaGFyQ29kZUF0KG8pLCB1IDwgMTI4ID8gbltpKytdID0gdSA6IHUgPCAyMDQ4ID8gKG5baSsrXSA9IHUgPj4gNiB8IDE5MiwgbltpKytdID0gdSAmIDYzIHwgMTI4KSA6ICh1ICYgNjQ1MTIpID09PSA1NTI5NiAmJiAoKGggPSB0LmNoYXJDb2RlQXQobyArIDEpKSAmIDY0NTEyKSA9PT0gNTYzMjAgPyAodSA9IDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApICsgKGggJiAxMDIzKSwgbysrLCBuW2krK10gPSB1ID4+IDE4IHwgMjQwLCBuW2krK10gPSB1ID4+IDEyICYgNjMgfCAxMjgsIG5baSsrXSA9IHUgPj4gNiAmIDYzIHwgMTI4LCBuW2krK10gPSB1ICYgNjMgfCAxMjgpIDogKG5baSsrXSA9IHUgPj4gMTIgfCAyMjQsIG5baSsrXSA9IHUgPj4gNiAmIDYzIHwgMTI4LCBuW2krK10gPSB1ICYgNjMgfCAxMjgpO1xuICAgICAgfVxuICAgICAgdGhpcy5idWYgPSBuO1xuICAgIH1cbiAgfVxuICByZWFkTG9uZygpIHtcbiAgICBsZXQgdCA9IDAsIHIxOCA9IDAsIG4gPSB0aGlzLmJ1ZiwgaSwgbywgcywgdTtcbiAgICBkb1xuICAgICAgaSA9IG5bdGhpcy5wb3MrK10sIG8gPSBpICYgMTI4LCB0IHw9IChpICYgMTI3KSA8PCByMTgsIHIxOCArPSA3O1xuICAgIHdoaWxlIChvICYmIHIxOCA8IDI4KTtcbiAgICBpZiAobykge1xuICAgICAgcyA9IHQsIHUgPSAyNjg0MzU0NTY7XG4gICAgICBkb1xuICAgICAgICBpID0gblt0aGlzLnBvcysrXSwgcyArPSAoaSAmIDEyNykgKiB1LCB1ICo9IDEyODtcbiAgICAgIHdoaWxlIChpICYgMTI4KTtcbiAgICAgIHJldHVybiAocyAlIDIgPyAtKHMgKyAxKSA6IHMpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHQgPj4gMSBeIC0odCAmIDEpO1xuICB9XG4gIHNraXBMb25nKCkge1xuICAgIGxldCB0ID0gdGhpcy5idWY7XG4gICAgZm9yICg7IHRbdGhpcy5wb3MrK10gJiAxMjg7ICkgO1xuICB9XG4gIHJlYWRUYWdzKCkge1xuICAgIGxldCB0ID0gW10sIHIxODtcbiAgICBmb3IgKDsgcjE4ID0gdGhpcy5yZWFkTG9uZygpOyApIGZvciAocjE4IDwgMCAmJiAocjE4ID0gLXIxOCwgdGhpcy5za2lwTG9uZygpKTsgcjE4LS07ICkge1xuICAgICAgbGV0IG4gPSB0aGlzLnJlYWRTdHJpbmcoKSwgaSA9IHRoaXMucmVhZFN0cmluZygpO1xuICAgICAgdC5wdXNoKHsgbmFtZTogbiwgdmFsdWU6IGkgfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIHJlYWRTdHJpbmcoKSB7XG4gICAgbGV0IHQgPSB0aGlzLnJlYWRMb25nKCksIHIxOCA9IHRoaXMucG9zLCBuID0gdGhpcy5idWY7XG4gICAgaWYgKHRoaXMucG9zICs9IHQsICEodGhpcy5wb3MgPiBuLmxlbmd0aCkpIHJldHVybiB0aGlzLmJ1Zi5zbGljZShyMTgsIHIxOCArIHQpLnRvU3RyaW5nKCk7XG4gIH1cbn07XG5mdW5jdGlvbiBkdDIoZSkge1xuICBsZXQgdCA9IG5ldyAkMigpO1xuICByZXR1cm4gdC53cml0ZVRhZ3MoZSksIHQudG9CdWZmZXIoKTtcbn1cbmZ1bmN0aW9uIGpyMihlKSB7XG4gIGxldCB0ID0gbmV3ICQyKCk7XG4gIHJldHVybiB0LndyaXRlVGFncyhlKSwgdC50YWdzRXhjZWVkTGltaXQoKTtcbn1cbmZ1bmN0aW9uIFEoZSkge1xuICByZXR1cm4gbmV3ICQyKGUpLnJlYWRUYWdzKCk7XG59XG5mdW5jdGlvbiBJKGUpIHtcbiAgbGV0IHQgPSAwO1xuICBmb3IgKGxldCByMTggPSBlLmxlbmd0aCAtIDE7IHIxOCA+PSAwOyByMTgtLSkgdCA9IHQgKiAyNTYgKyBlW3IxOF07XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gVnQyKGUpIHtcbiAgaWYgKGUgPiAoMiBeIDMyIC0gMSkpIHRocm93IG5ldyBFcnJvcihcIlNob3J0IHRvbyBsb25nXCIpO1xuICBsZXQgdCA9IFswLCAwXTtcbiAgZm9yIChsZXQgcjE4ID0gMDsgcjE4IDwgdC5sZW5ndGg7IHIxOCsrKSB7XG4gICAgbGV0IG4gPSBlICYgMjU1O1xuICAgIHRbcjE4XSA9IG4sIGUgPSAoZSAtIG4pIC8gMjU2O1xuICB9XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odCk7XG59XG5mdW5jdGlvbiB4dDIoZSkge1xuICBsZXQgdCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgZm9yIChsZXQgcjE4ID0gMDsgcjE4IDwgdC5sZW5ndGg7IHIxOCsrKSB7XG4gICAgbGV0IG4gPSBlICYgMjU1O1xuICAgIHRbcjE4XSA9IG4sIGUgPSAoZSAtIG4pIC8gMjU2O1xuICB9XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odCk7XG59XG52YXIgbHIyID0gQyhwcjIoKSwgMSk7XG52YXIgTTIgPSBDKG50MigpLCAxKTtcbnZhciB0dDIgPSA0MDk2O1xudmFyIGdyMiA9IDgwO1xudmFyIF8yID0gY2xhc3Mge1xuICBiaW5hcnk7XG4gIF9pZDtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuYmluYXJ5ID0gdDtcbiAgfVxuICBzdGF0aWMgaXNEYXRhSXRlbSh0KSB7XG4gICAgcmV0dXJuIHQuYmluYXJ5ICE9PSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHNpZ25hdHVyZVR5cGUoKSB7XG4gICAgbGV0IHQgPSBJKHRoaXMuYmluYXJ5LnN1YmFycmF5KDAsIDIpKTtcbiAgICBpZiAoQj8uW3RdICE9PSB2b2lkIDApIHJldHVybiB0O1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc2lnbmF0dXJlIHR5cGU6IFwiICsgdCk7XG4gIH1cbiAgYXN5bmMgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gXzIudmVyaWZ5KHRoaXMuYmluYXJ5KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIChhc3luYyAoKSA9PiBFMi5kZWZhdWx0LmVuY29kZShhd2FpdCB0aGlzLnJhd0lkKSkoKTtcbiAgfVxuICBzZXQgaWQodCkge1xuICAgIHRoaXMuX2lkID0gRTIuZGVmYXVsdC50b0J1ZmZlcih0KTtcbiAgfVxuICBnZXQgcmF3SWQoKSB7XG4gICAgcmV0dXJuIChhc3luYyAoKSA9PiBNMi5CdWZmZXIuZnJvbShhd2FpdCBscjIuQ3J5cHRvLnN1YnRsZS5kaWdlc3QoXCJTSEEtMjU2XCIsIHRoaXMucmF3U2lnbmF0dXJlKSkpKCk7XG4gIH1cbiAgc2V0IHJhd0lkKHQpIHtcbiAgICB0aGlzLl9pZCA9IHQ7XG4gIH1cbiAgZ2V0IHJhd1NpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5iaW5hcnkuc3ViYXJyYXkoMiwgMiArIHRoaXMuc2lnbmF0dXJlTGVuZ3RoKTtcbiAgfVxuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIHJldHVybiBFMi5kZWZhdWx0LmVuY29kZSh0aGlzLnJhd1NpZ25hdHVyZSk7XG4gIH1cbiAgc2V0IHJhd093bmVyKHQpIHtcbiAgICBpZiAodC5ieXRlTGVuZ3RoICE9IHRoaXMub3duZXJMZW5ndGgpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmF3IG93bmVyIChwdWJrZXkpIHRvIGJlICR7dGhpcy5vd25lckxlbmd0aH0gYnl0ZXMsIGdvdCAke3QuYnl0ZUxlbmd0aH0gYnl0ZXMuYCk7XG4gICAgdGhpcy5iaW5hcnkuc2V0KHQsIDIgKyB0aGlzLnNpZ25hdHVyZUxlbmd0aCk7XG4gIH1cbiAgZ2V0IHJhd093bmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJpbmFyeS5zdWJhcnJheSgyICsgdGhpcy5zaWduYXR1cmVMZW5ndGgsIDIgKyB0aGlzLnNpZ25hdHVyZUxlbmd0aCArIHRoaXMub3duZXJMZW5ndGgpO1xuICB9XG4gIGdldCBzaWduYXR1cmVMZW5ndGgoKSB7XG4gICAgcmV0dXJuIFAyW3RoaXMuc2lnbmF0dXJlVHlwZV0uc2lnTGVuZ3RoO1xuICB9XG4gIGdldCBvd25lcigpIHtcbiAgICByZXR1cm4gRTIuZGVmYXVsdC5lbmNvZGUodGhpcy5yYXdPd25lcik7XG4gIH1cbiAgZ2V0IG93bmVyTGVuZ3RoKCkge1xuICAgIHJldHVybiBQMlt0aGlzLnNpZ25hdHVyZVR5cGVdLnB1Ykxlbmd0aDtcbiAgfVxuICBnZXQgcmF3VGFyZ2V0KCkge1xuICAgIGxldCB0ID0gdGhpcy5nZXRUYXJnZXRTdGFydCgpO1xuICAgIHJldHVybiB0aGlzLmJpbmFyeVt0XSA9PSAxID8gdGhpcy5iaW5hcnkuc3ViYXJyYXkodCArIDEsIHQgKyAzMykgOiBNMi5CdWZmZXIuYWxsb2MoMCk7XG4gIH1cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gRTIuZGVmYXVsdC5lbmNvZGUodGhpcy5yYXdUYXJnZXQpO1xuICB9XG4gIGdldCByYXdBbmNob3IoKSB7XG4gICAgbGV0IHQgPSB0aGlzLmdldEFuY2hvclN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5W3RdID09IDEgPyB0aGlzLmJpbmFyeS5zdWJhcnJheSh0ICsgMSwgdCArIDMzKSA6IE0yLkJ1ZmZlci5hbGxvYygwKTtcbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLnJhd0FuY2hvci50b1N0cmluZygpO1xuICB9XG4gIGdldCByYXdUYWdzKCkge1xuICAgIGxldCB0ID0gdGhpcy5nZXRUYWdzU3RhcnQoKSwgcjE4ID0gSSh0aGlzLmJpbmFyeS5zdWJhcnJheSh0ICsgOCwgdCArIDE2KSk7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5LnN1YmFycmF5KHQgKyAxNiwgdCArIDE2ICsgcjE4KTtcbiAgfVxuICBnZXQgdGFncygpIHtcbiAgICBsZXQgdCA9IHRoaXMuZ2V0VGFnc1N0YXJ0KCk7XG4gICAgaWYgKEkodGhpcy5iaW5hcnkuc3ViYXJyYXkodCwgdCArIDgpKSA9PSAwKSByZXR1cm4gW107XG4gICAgbGV0IG4gPSBJKHRoaXMuYmluYXJ5LnN1YmFycmF5KHQgKyA4LCB0ICsgMTYpKTtcbiAgICByZXR1cm4gUShNMi5CdWZmZXIuZnJvbSh0aGlzLmJpbmFyeS5zdWJhcnJheSh0ICsgMTYsIHQgKyAxNiArIG4pKSk7XG4gIH1cbiAgZ2V0IHRhZ3NCNjRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5tYXAoKHIxOCkgPT4gKHsgbmFtZTogRTIuZGVmYXVsdC5lbmNvZGUocjE4Lm5hbWUpLCB2YWx1ZTogRTIuZGVmYXVsdC5lbmNvZGUocjE4LnZhbHVlKSB9KSk7XG4gIH1cbiAgZ2V0U3RhcnRPZkRhdGEoKSB7XG4gICAgbGV0IHQgPSB0aGlzLmdldFRhZ3NTdGFydCgpLCByMTggPSB0aGlzLmJpbmFyeS5zdWJhcnJheSh0ICsgOCwgdCArIDE2KSwgbiA9IEkocjE4KTtcbiAgICByZXR1cm4gdCArIDE2ICsgbjtcbiAgfVxuICBnZXQgcmF3RGF0YSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuZ2V0VGFnc1N0YXJ0KCksIHIxOCA9IHRoaXMuYmluYXJ5LnN1YmFycmF5KHQgKyA4LCB0ICsgMTYpLCBuID0gSShyMTgpLCBpID0gdCArIDE2ICsgbjtcbiAgICByZXR1cm4gdGhpcy5iaW5hcnkuc3ViYXJyYXkoaSwgdGhpcy5iaW5hcnkubGVuZ3RoKTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gRTIuZGVmYXVsdC5lbmNvZGUodGhpcy5yYXdEYXRhKTtcbiAgfVxuICBnZXRSYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5O1xuICB9XG4gIGFzeW5jIHNpZ24odCkge1xuICAgIHJldHVybiB0aGlzLl9pZCA9IGF3YWl0IFd0Mih0aGlzLCB0KSwgdGhpcy5yYXdJZDtcbiAgfVxuICBhc3luYyBzZXRTaWduYXR1cmUodCkge1xuICAgIHRoaXMuYmluYXJ5LnNldCh0LCAyKSwgdGhpcy5faWQgPSBNMi5CdWZmZXIuZnJvbShhd2FpdCB4MigpLmhhc2godCkpO1xuICB9XG4gIGlzU2lnbmVkKCkge1xuICAgIHJldHVybiAodGhpcy5faWQ/Lmxlbmd0aCA/PyAwKSA+IDA7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHNpZ25hdHVyZTogdGhpcy5zaWduYXR1cmUsIG93bmVyOiB0aGlzLm93bmVyLCB0YXJnZXQ6IHRoaXMudGFyZ2V0LCB0YWdzOiB0aGlzLnRhZ3MubWFwKCh0KSA9PiAoeyBuYW1lOiBFMi5kZWZhdWx0LmVuY29kZSh0Lm5hbWUpLCB2YWx1ZTogRTIuZGVmYXVsdC5lbmNvZGUodC52YWx1ZSkgfSkpLCBkYXRhOiB0aGlzLmRhdGEgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgdmVyaWZ5KHQpIHtcbiAgICBpZiAodC5ieXRlTGVuZ3RoIDwgZ3IyKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHIxOCA9IG5ldyBfMih0KSwgbiA9IHIxOC5zaWduYXR1cmVUeXBlLCBpID0gcjE4LmdldFRhZ3NTdGFydCgpLCBvID0gSSh0LnN1YmFycmF5KGksIGkgKyA4KSksIHMgPSB0LnN1YmFycmF5KGkgKyA4LCBpICsgMTYpLCB1ID0gSShzKTtcbiAgICBpZiAodSA+IHR0MikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvID4gMCkgdHJ5IHtcbiAgICAgIGlmIChRKE0yLkJ1ZmZlci5mcm9tKHQuc3ViYXJyYXkoaSArIDE2LCBpICsgMTYgKyB1KSkpLmxlbmd0aCAhPT0gbykgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaCA9IHd0MltuXSwgcDIgPSBhd2FpdCB2KHIxOCk7XG4gICAgcmV0dXJuIGF3YWl0IGgudmVyaWZ5KHIxOC5yYXdPd25lciwgcDIsIHIxOC5yYXdTaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIGdldFNpZ25hdHVyZURhdGEoKSB7XG4gICAgcmV0dXJuIHYodGhpcyk7XG4gIH1cbiAgZ2V0VGFnc1N0YXJ0KCkge1xuICAgIGxldCB0ID0gdGhpcy5nZXRUYXJnZXRTdGFydCgpLCByMTggPSB0aGlzLmJpbmFyeVt0XSA9PSAxLCBuID0gdCArIChyMTggPyAzMyA6IDEpLCBpID0gdGhpcy5iaW5hcnlbbl0gPT0gMTtcbiAgICByZXR1cm4gbiArPSBpID8gMzMgOiAxLCBuO1xuICB9XG4gIGdldFRhcmdldFN0YXJ0KCkge1xuICAgIHJldHVybiAyICsgdGhpcy5zaWduYXR1cmVMZW5ndGggKyB0aGlzLm93bmVyTGVuZ3RoO1xuICB9XG4gIGdldEFuY2hvclN0YXJ0KCkge1xuICAgIGxldCB0ID0gdGhpcy5nZXRUYXJnZXRTdGFydCgpICsgMSwgcjE4ID0gdGhpcy5iaW5hcnlbdGhpcy5nZXRUYXJnZXRTdGFydCgpXSA9PSAxO1xuICAgIHJldHVybiB0ICs9IHIxOCA/IDMyIDogMCwgdDtcbiAgfVxufTtcbnZhciB5cjIgPSBDKHozKCksIDEpO1xuZnVuY3Rpb24gZ2UyKGUsIHQsIHIxOCkge1xuICBsZXQgbiA9IHQucHVibGljS2V5LCBpID0gcjE4Py50YXJnZXQgPyB5cjIuZGVmYXVsdC50b0J1ZmZlcihyMTgudGFyZ2V0KSA6IG51bGwsIG8gPSAxICsgKGk/LmJ5dGVMZW5ndGggPz8gMCksIHMgPSByMTg/LmFuY2hvciA/IEJ1ZmZlci5mcm9tKHIxOC5hbmNob3IpIDogbnVsbCwgdSA9IDEgKyAocz8uYnl0ZUxlbmd0aCA/PyAwKSwgaCA9IChyMTg/LnRhZ3M/Lmxlbmd0aCA/PyAwKSA+IDAgPyBkdDIocjE4LnRhZ3MpIDogbnVsbCwgcDIgPSAxNiArIChoID8gaC5ieXRlTGVuZ3RoIDogMCksIGYyID0gQnVmZmVyLmZyb20oZSksIGMyID0gZjIuYnl0ZUxlbmd0aCwgVTIgPSAyICsgdC5zaWduYXR1cmVMZW5ndGggKyB0Lm93bmVyTGVuZ3RoICsgbyArIHUgKyBwMiArIGMyLCBsID0gQnVmZmVyLmFsbG9jKFUyKTtcbiAgaWYgKGwuc2V0KFZ0Mih0LnNpZ25hdHVyZVR5cGUpLCAwKSwgbC5zZXQobmV3IFVpbnQ4QXJyYXkodC5zaWduYXR1cmVMZW5ndGgpLmZpbGwoMCksIDIpLCBuLmJ5dGVMZW5ndGggIT09IHQub3duZXJMZW5ndGgpIHRocm93IG5ldyBFcnJvcihgT3duZXIgbXVzdCBiZSAke3Qub3duZXJMZW5ndGh9IGJ5dGVzLCBidXQgd2FzIGluY29ycmVjdGx5ICR7bi5ieXRlTGVuZ3RofWApO1xuICBsLnNldChuLCAyICsgdC5zaWduYXR1cmVMZW5ndGgpO1xuICBsZXQgUjIgPSAyICsgdC5zaWduYXR1cmVMZW5ndGggKyB0Lm93bmVyTGVuZ3RoO1xuICBpZiAobFtSMl0gPSBpID8gMSA6IDAsIGkpIHtcbiAgICBpZiAoaS5ieXRlTGVuZ3RoICE9PSAzMikgdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgbXVzdCBiZSAzMiBieXRlcyBidXQgd2FzIGluY29ycmVjdGx5ICR7aS5ieXRlTGVuZ3RofWApO1xuICAgIGwuc2V0KGksIFIyICsgMSk7XG4gIH1cbiAgbGV0IEcyID0gUjIgKyBvLCBZMiA9IEcyICsgMTtcbiAgaWYgKGxbRzJdID0gcyA/IDEgOiAwLCBzKSB7XG4gICAgaWYgKFkyICs9IHMuYnl0ZUxlbmd0aCwgcy5ieXRlTGVuZ3RoICE9PSAzMikgdGhyb3cgbmV3IEVycm9yKFwiQW5jaG9yIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gICAgbC5zZXQocywgRzIgKyAxKTtcbiAgfVxuICBsLnNldCh4dDIocjE4Py50YWdzPy5sZW5ndGggPz8gMCksIFkyKTtcbiAgbGV0IHdyMiA9IHh0MihoPy5ieXRlTGVuZ3RoID8/IDApO1xuICBsLnNldCh3cjIsIFkyICsgOCksIGggJiYgbC5zZXQoaCwgWTIgKyAxNik7XG4gIGxldCBkcjIgPSBZMiArIHAyO1xuICByZXR1cm4gbC5zZXQoZjIsIGRyMiksIG5ldyBfMihsKTtcbn1cbnZhciBfdDIgPSB7IC4uLkx0MiB9O1xuZ2xvYmFsVGhpcy5hcmJ1bmRsZXMgPz89IF90MjtcbnZhciB3bjIgPSBfdDI7XG52YXIgZG4yID0gX3QyO1xuXG4vLyBzcmMvY2xpZW50L2Jyb3dzZXIvd2FsbGV0LmpzXG5pZiAoIWdsb2JhbFRoaXMuQnVmZmVyKSBnbG9iYWxUaGlzLkJ1ZmZlciA9IGltcG9ydF9idWZmZXIuQnVmZmVyO1xudmFyIHsgRGF0YUl0ZW0gfSA9IGJ1bmRsZV9leHBvcnRzO1xuZnVuY3Rpb24gY3JlYXRlRGF0YUl0ZW1TaWduZXIoYXJ3ZWF2ZVdhbGxldCkge1xuICBjb25zdCBzaWduZXIgPSBhc3luYyAoeyBkYXRhLCB0YWdzLCB0YXJnZXQsIGFuY2hvciwgY3JlYXRlRGF0YUl0ZW0gPSAoYnVmKSA9PiBuZXcgRGF0YUl0ZW0oYnVmKSB9KSA9PiB7XG4gICAgY29uc3QgdmlldyA9IGF3YWl0IGFyd2VhdmVXYWxsZXQuc2lnbkRhdGFJdGVtKHsgZGF0YSwgdGFncywgdGFyZ2V0LCBhbmNob3IgfSk7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSBjcmVhdGVEYXRhSXRlbShpbXBvcnRfYnVmZmVyLkJ1ZmZlci5mcm9tKHZpZXcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGF3YWl0IGRhdGFJdGVtLmlkLFxuICAgICAgcmF3OiBhd2FpdCBkYXRhSXRlbS5nZXRSYXcoKVxuICAgIH07XG4gIH07XG4gIHJldHVybiBzaWduZXI7XG59XG5cbi8vIHNyYy9pbmRleC5icm93c2VyLmpzXG52YXIgR0FURVdBWV9VUkwgPSBnbG9iYWxUaGlzLkdBVEVXQVlfVVJMIHx8IHZvaWQgMDtcbnZhciBNVV9VUkwgPSBnbG9iYWxUaGlzLk1VX1VSTCB8fCB2b2lkIDA7XG52YXIgQ1VfVVJMID0gZ2xvYmFsVGhpcy5DVV9VUkwgfHwgdm9pZCAwO1xudmFyIEdSQVBIUUxfVVJMID0gZ2xvYmFsVGhpcy5HUkFQSFFMX1VSTCB8fCB2b2lkIDA7XG52YXIgR1JBUEhRTF9NQVhfUkVUUklFUyA9IGdsb2JhbFRoaXMuR1JBUEhRTF9NQVhfUkVUUklFUyB8fCB2b2lkIDA7XG52YXIgR1JBUEhRTF9SRVRSWV9CQUNLT0ZGID0gZ2xvYmFsVGhpcy5HUkFQSFFMX1JFVFJZX0JBQ0tPRkYgfHwgdm9pZCAwO1xudmFyIHsgcmVzdWx0LCByZXN1bHRzLCBtZXNzYWdlLCBzcGF3biwgbW9uaXRvciwgdW5tb25pdG9yLCBkcnlydW4sIGFzc2lnbiB9ID0gY29ubmVjdCh7IEdBVEVXQVlfVVJMLCBNVV9VUkwsIENVX1VSTCwgR1JBUEhRTF9VUkwsIEdSQVBIUUxfTUFYX1JFVFJJRVMsIEdSQVBIUUxfUkVUUllfQkFDS09GRiB9KTtcbnZhciBjcmVhdGVEYXRhSXRlbVNpZ25lcjIgPSB3YWxsZXRfZXhwb3J0cy5jcmVhdGVEYXRhSXRlbVNpZ25lcjtcbmV4cG9ydCB7XG4gIGFzc2lnbixcbiAgY29ubmVjdCxcbiAgY3JlYXRlRGF0YUl0ZW1TaWduZXIyIGFzIGNyZWF0ZURhdGFJdGVtU2lnbmVyLFxuICBkcnlydW4sXG4gIG1lc3NhZ2UsXG4gIG1vbml0b3IsXG4gIHJlc3VsdCxcbiAgcmVzdWx0cyxcbiAgc2VyaWFsaXplQ3JvbixcbiAgc3Bhd24sXG4gIHVubW9uaXRvclxufTtcbi8qISBCdW5kbGVkIGxpY2Vuc2UgaW5mb3JtYXRpb246XG5cbmllZWU3NTQvaW5kZXguanM6XG4gICgqISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICopXG5cbmJ1ZmZlci9pbmRleC5qczpcbiAgKCohXG4gICAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICAgKlxuICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICAgKiBAbGljZW5zZSAgTUlUXG4gICAqKVxuXG53YXJwLWFyYnVuZGxlcy9idWlsZC93ZWIvZXNtL2J1bmRsZS5qczpcbiAgKCohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcbiAgXG4gIGllZWU3NTQvaW5kZXguanM6XG4gICAgKCohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKilcbiAgXG4gIGJ1ZmZlci9pbmRleC5qczpcbiAgICAoKiFcbiAgICAgKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gICAgICogQGxpY2Vuc2UgIE1JVFxuICAgICAqKVxuICAqKVxuKi9cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@permaweb/aoconnect/dist/browser.js\n");

/***/ })

};
;